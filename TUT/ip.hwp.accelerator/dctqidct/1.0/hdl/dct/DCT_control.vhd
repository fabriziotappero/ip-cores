------------------------------------------------------------------------------
-- Author        : Timo Alho
-- e-mail        : timo.a.alho@tut.fi
-- Date          : 11.08.2004 13:28:09
-- File          : DCT_control.vhd
-- Design        : VHDL Entity for dct.DCT_control.symbol
-- Generated by Mentor Graphics' HDL Designer 2003.1 (Build 399)
------------------------------------------------------------------------------
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
LIBRARY dct;
USE dct.DCT_pkg.all;
LIBRARY common_da;

ENTITY DCT_control IS
   PORT( 
      clk              : IN     std_logic;
      next_block_ready : IN     std_logic;
      rst_n            : IN     std_logic;
      wr_new_data      : IN     std_logic;
      DC               : OUT    std_logic;
      load_dct_input   : OUT    std_logic;
      load_dct_output  : OUT    std_logic;
      out_clk_en       : OUT    std_logic;
      rdaddr           : OUT    std_logic_vector (5 DOWNTO 0);
      ready_for_rx     : OUT    std_logic;
      sel_input        : OUT    std_logic;
      start_dct        : OUT    std_logic;
      stop_dct         : OUT    std_logic;
      we               : OUT    std_logic;
      wr_out           : OUT    std_logic;
      wraddr           : OUT    std_logic_vector (5 DOWNTO 0)
   );

-- Declarations

END DCT_control ;

------------------------------------------------------------------------------
-- Author        : Timo Alho
-- e-mail        : timo.a.alho@tut.fi
-- Date          : 11.08.2004 13:28:10
-- File          : DCT_control.vhd
-- Design        : VHDL Architecture for dct.DCT_control.symbol
-- Generated by Mentor Graphics' HDL Designer 2003.1 (Build 399)
------------------------------------------------------------------------------
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
LIBRARY dct;
USE dct.DCT_pkg.all;

ARCHITECTURE fsm OF DCT_control IS

   -- Architecture Declarations
   signal wait_counter_r : unsigned (4 downto 0);
   signal col_nr_r : unsigned(2 downto 0);
   signal row_rd_nr_r : unsigned(2 downto 0);
   signal row_wr_nr_r : unsigned(2 downto 0);
   
   signal in_counter_r : unsigned(2 downto 0);
   --signal in_counter_next : unsigned(2 downto 0);
   
   signal out_counter_r : unsigned(2 downto 0);
   --signal out_counter_next : unsigned(2 downto 0);
   
   signal output_ready : std_logic;
   
   signal load_rows : std_logic;
   signal load_columns : std_logic;
   signal save_result : std_logic;
   signal result_out : std_logic;
   signal col_ready : std_logic;

   TYPE CSM_STATE_TYPE IS (
      start,
      start_col_calc,
      wait_col_calc,
      stop_last_row,
      wait_row_calc,
      wait_data,
      stop_and_start_next_col,
      stop_col_calc,
      stop_last_col,
      dummy0,
      start_row_calc,
      stop_row_calc,
      wait_output_free,
      stop_and_start_next_row,
      dummy1,
      wt_nxt
   );
   TYPE CSM1_STATE_TYPE IS (
      o_ready,
      wr_col_to_ram,
      result_to_buffer,
      result_to_buffer2,
      res_out1,
      wait_output
   );
   TYPE CSM2_STATE_TYPE IS (
      i_ready,
      i_load_row,
      i_load_column,
      wait_ram_rd,
      wait_load,
      wait_1st_data
   );


   -- Declare current and next state signals
   SIGNAL csm_current_state : CSM_STATE_TYPE ;
   SIGNAL csm_next_state : CSM_STATE_TYPE ;
   SIGNAL csm1_current_state : CSM1_STATE_TYPE ;
   SIGNAL csm1_next_state : CSM1_STATE_TYPE ;
   SIGNAL csm2_current_state : CSM2_STATE_TYPE ;
   SIGNAL csm2_next_state : CSM2_STATE_TYPE ;

   -- Declare any pre-registered internal signals
   SIGNAL DC_int : std_logic  ;
   SIGNAL wr_out_int : std_logic  ;

BEGIN

   ----------------------------------------------------------------------------
   csm_clocked : PROCESS(
      clk,
      rst_n
   )
   ----------------------------------------------------------------------------
   BEGIN
      IF (rst_n = '0') THEN
         csm_current_state <= start;
         -- Reset Values
         col_nr_r <= (others => '0');
         row_rd_nr_r <= (others => '0');
         row_wr_nr_r <= (others => '0');
         wait_counter_r <= (others => '0');
      ELSIF (clk'EVENT AND clk = '1') THEN
         csm_current_state <= csm_next_state;
         -- Default Assignment To Internals

         -- Combined Actions for internal signals only
         CASE csm_current_state IS
         WHEN start_col_calc =>
            wait_counter_r <= (others => '0');
         WHEN wait_col_calc =>
            row_rd_nr_r <= (others => '0');
            wait_counter_r <= wait_counter_r + 1;
         WHEN stop_last_row =>
            row_rd_nr_r <= (others => '0');
            col_nr_r <= (others => '0');
         WHEN wait_row_calc =>
            --wait until row is processed
            wait_counter_r <= wait_counter_r + 1;
         WHEN stop_and_start_next_col =>
            col_nr_r <= col_nr_r + 1;
            row_wr_nr_r <= col_nr_r;
            wait_counter_r <= (others => '0');
         WHEN stop_col_calc =>
            col_nr_r <= col_nr_r + 1;
            row_wr_nr_r <= col_nr_r;
         WHEN stop_last_col =>
            col_nr_r <= (others => '0');
            row_wr_nr_r <= col_nr_r;
            wait_counter_r <= (others => '0');
            --load current block's QP parameter to output
         WHEN dummy0 =>
            --wait until last element of first row is read from memory
            wait_counter_r <= wait_counter_r+1;
         WHEN start_row_calc =>
            row_rd_nr_r <= row_rd_nr_r + 1;
            wait_counter_r <= (others => '0');
         WHEN stop_row_calc =>
            --stop calculation of current row
            col_nr_r <= col_nr_r + 1;
         WHEN stop_and_start_next_row =>
            row_rd_nr_r <= row_rd_nr_r + 1;
            col_nr_r <= col_nr_r + 1;
            wait_counter_r <= (others => '0');
         WHEN OTHERS =>
            NULL;
         END CASE;

      END IF;

   END PROCESS csm_clocked;

   ----------------------------------------------------------------------------
   csm_nextstate : PROCESS (
      col_nr_r,
      col_ready,
      csm_current_state,
      next_block_ready,
      wait_counter_r
   )
   ----------------------------------------------------------------------------
   BEGIN
      CASE csm_current_state IS
      WHEN start =>
            csm_next_state <= wait_data;
      WHEN start_col_calc =>
            csm_next_state <= wait_col_calc;
      WHEN wait_col_calc =>
         IF (col_nr_r =7 AND
         wait_counter_r = DCT_inputw_co) THEN
            csm_next_state <= stop_last_col;
         ELSIF (col_ready = '1' AND
         wait_counter_r = DCT_inputw_co) THEN
            csm_next_state <= stop_and_start_next_col;
         ELSIF (wait_counter_r = DCT_inputw_co) THEN
            csm_next_state <= stop_col_calc;
         ELSE
            csm_next_state <= wait_col_calc;
         END IF;
      WHEN stop_last_row =>
         IF (col_ready = '1' AND next_block_ready = '1') THEN
            csm_next_state <= start_col_calc;
         ELSE
            csm_next_state <= wt_nxt;
         END IF;
      WHEN wait_row_calc =>
         IF (wait_counter_r = DCT_dataw_co AND
         col_nr_r = 7) THEN
            csm_next_state <= stop_last_row;
         ELSIF (wait_counter_r = DCT_dataw_co AND
         next_block_ready = '1') THEN
            csm_next_state <= stop_and_start_next_row;
         ELSIF (wait_counter_r = DCT_dataw_co) THEN
            csm_next_state <= stop_row_calc;
         ELSE
            csm_next_state <= wait_row_calc;
         END IF;
      WHEN wait_data =>
         IF (col_ready = '1') THEN
            csm_next_state <= start_col_calc;
         ELSE
            csm_next_state <= wait_data;
         END IF;
      WHEN stop_and_start_next_col =>
            csm_next_state <= wait_col_calc;
      WHEN stop_col_calc =>
         IF (col_ready = '1') THEN
            csm_next_state <= start_col_calc;
         ELSE
            csm_next_state <= wait_data;
         END IF;
      WHEN stop_last_col =>
            csm_next_state <= dummy0;
      WHEN dummy0 =>
         IF (wait_counter_r = 2) THEN
            csm_next_state <= dummy1;
         ELSE
            csm_next_state <= dummy0;
         END IF;
      WHEN start_row_calc =>
            csm_next_state <= wait_row_calc;
      WHEN stop_row_calc =>
            csm_next_state <= wait_output_free;
      WHEN wait_output_free =>
         IF (next_block_ready = '1') THEN
            csm_next_state <= start_row_calc;
         ELSE
            csm_next_state <= wait_output_free;
         END IF;
      WHEN stop_and_start_next_row =>
            csm_next_state <= wait_row_calc;
      WHEN dummy1 =>
         IF (next_block_ready = '1') THEN
            csm_next_state <= start_row_calc;
         ELSE
            csm_next_state <= dummy1;
         END IF;
      WHEN wt_nxt =>
         IF (next_block_ready = '1') THEN
            csm_next_state <= wait_data;
         ELSE
            csm_next_state <= wt_nxt;
         END IF;
      WHEN OTHERS =>
         csm_next_state <= start;
      END CASE;

   END PROCESS csm_nextstate;

   ----------------------------------------------------------------------------
   csm_output : PROCESS (
      col_nr_r,
      csm_current_state,
      wait_counter_r
   )
   ----------------------------------------------------------------------------
   BEGIN
      -- Default Assignment
      start_dct <= '0';
      stop_dct <= '0';
      -- Default Assignment To Internals
      load_columns <= '0';
      load_rows <= '0';
      result_out <= '0';
      save_result <= '0';

      -- Combined Actions
      CASE csm_current_state IS
      WHEN start =>
         load_columns <= '1';
      WHEN start_col_calc =>
         --start calculation of column
         start_dct <= '1';
         if (col_nr_r /= 7) then
         load_columns <= '1';
         end if;
      WHEN wait_col_calc =>
         --wait few clock cycles while column is being processed
         if (col_nr_r = 7 AND wait_counter_r = 5) then
         --last column is being processed so we can start loading input "buffer" with values of first row
         load_rows <= '1';
         end if;
      WHEN stop_last_row =>
         --stop calculation of the last row
         stop_dct <= '1';
         result_out <= '1';
      WHEN wait_data =>
         --wait until there is new data available
      WHEN stop_and_start_next_col =>
         --stop calculation of current column, and start calculation of next column
         if (col_nr_r /=6) then 
         load_columns <= '1';
         end if;
         start_dct <=  '1';
         stop_dct <= '1';
         save_result <= '1';
      WHEN stop_col_calc =>
         --stop calculation of current column
         stop_dct <= '1';
         save_result <= '1';
      WHEN stop_last_col =>
         --stop calculation of last column
         stop_dct <= '1';
         save_result <= '1';
      WHEN start_row_calc =>
         --start calculation of row
         start_dct <= '1';
         if (col_nr_r /=7) then
           load_rows <= '1';
         else
           load_columns <= '1';
         end if;
      WHEN stop_row_calc =>
         stop_dct <= '1';
         result_out <= '1';
      WHEN wait_output_free =>
         --we must wait until next block is capable of receiving data
      WHEN stop_and_start_next_row =>
         --stop calculation of current row, and start next row
         start_dct <= '1';
         stop_dct <= '1';
         result_out <= '1';
         if (col_nr_r /= 6) then
           load_rows <= '1';
         else
           load_columns <= '1';
         end if;
      WHEN OTHERS =>
         NULL;
      END CASE;

   END PROCESS csm_output;

   ----------------------------------------------------------------------------
   csm1_clocked : PROCESS(
      clk,
      rst_n
   )
   ----------------------------------------------------------------------------
   BEGIN
      IF (rst_n = '0') THEN
         csm1_current_state <= o_ready;
         -- Reset Values
         DC <= '0';
         wr_out <= '0';
         out_counter_r <= (others => '0');
      ELSIF (clk'EVENT AND clk = '1') THEN
         csm1_current_state <= csm1_next_state;
         -- Registered output assignments
         DC <= DC_int;
         wr_out <= wr_out_int;

         -- Default Assignment To Internals

         -- Combined Actions for internal signals only
         CASE csm1_current_state IS
         WHEN o_ready =>
            out_counter_r <= (others => '0');
         WHEN wr_col_to_ram =>
            out_counter_r <= out_counter_r + 1;
         WHEN res_out1 =>
            out_counter_r <= out_counter_r + 1;
         WHEN OTHERS =>
            NULL;
         END CASE;

      END IF;

   END PROCESS csm1_clocked;

   ----------------------------------------------------------------------------
   csm1_nextstate : PROCESS (
      csm1_current_state,
      next_block_ready,
      out_counter_r,
      result_out,
      save_result
   )
   ----------------------------------------------------------------------------
   BEGIN
      CASE csm1_current_state IS
      WHEN o_ready =>
         IF (save_result = '1') THEN
            csm1_next_state <= result_to_buffer;
         ELSIF (result_out = '1') THEN
            csm1_next_state <= result_to_buffer2;
         ELSE
            csm1_next_state <= o_ready;
         END IF;
      WHEN wr_col_to_ram =>
         IF (out_counter_r = 7) THEN
            csm1_next_state <= o_ready;
         ELSE
            csm1_next_state <= wr_col_to_ram;
         END IF;
      WHEN result_to_buffer =>
            csm1_next_state <= wr_col_to_ram;
      WHEN result_to_buffer2 =>
         IF (next_block_ready = '1') THEN
            csm1_next_state <= res_out1;
         ELSE
            csm1_next_state <= wait_output;
         END IF;
      WHEN res_out1 =>
         IF (out_counter_r = 7) THEN
            csm1_next_state <= o_ready;
         ELSE
            csm1_next_state <= res_out1;
         END IF;
      WHEN wait_output =>
         IF (next_block_ready = '1') THEN
            csm1_next_state <= res_out1;
         ELSE
            csm1_next_state <= wait_output;
         END IF;
      WHEN OTHERS =>
         csm1_next_state <= o_ready;
      END CASE;

   END PROCESS csm1_nextstate;

   ----------------------------------------------------------------------------
   csm1_output : PROCESS (
      col_nr_r,
      csm1_current_state,
      out_counter_r
   )
   ----------------------------------------------------------------------------
   BEGIN
      -- Default Assignment
      DC_int <= '0';
      load_dct_output <= '0';
      out_clk_en <= '0';
      we <= '0';
      wr_out_int <= '0';
      -- Default Assignment To Internals
      output_ready <= '0';

      -- Combined Actions
      CASE csm1_current_state IS
      WHEN o_ready =>
         output_ready <= '1';
      WHEN wr_col_to_ram =>
         we <= '1';
         out_clk_en <= '1';
      WHEN result_to_buffer =>
         load_dct_output <= '1';
      WHEN result_to_buffer2 =>
         load_dct_output <= '1';
      WHEN res_out1 =>
         out_clk_en <= '1';
         wr_out_int <= '1';
         if (col_nr_r = 1 AND out_counter_r = 0) then
         DC_int <= '1';
         end if;
      WHEN OTHERS =>
         NULL;
      END CASE;

   END PROCESS csm1_output;

   ----------------------------------------------------------------------------
   csm2_clocked : PROCESS(
      clk,
      rst_n
   )
   ----------------------------------------------------------------------------
   BEGIN
      IF (rst_n = '0') THEN
         csm2_current_state <= i_ready;
         -- Reset Values
         in_counter_r <= (others => '0');
      ELSIF (clk'EVENT AND clk = '1') THEN
         csm2_current_state <= csm2_next_state;
         -- Default Assignment To Internals

         -- Combined Actions for internal signals only
         CASE csm2_current_state IS
         WHEN i_ready =>
            in_counter_r <= (OTHERS => '0');
         WHEN i_load_row =>
            in_counter_r <= in_counter_r + 1;
         WHEN i_load_column =>
            if (wr_new_data = '1') then
              in_counter_r <= in_counter_r + 1;
            end if;
         WHEN wait_ram_rd =>
            in_counter_r <= in_counter_r + 1;
         WHEN wait_1st_data =>
            if (wr_new_data = '1') then
             in_counter_r <= in_counter_r + 1;
            end if;
         WHEN OTHERS =>
            NULL;
         END CASE;

      END IF;

   END PROCESS csm2_clocked;

   ----------------------------------------------------------------------------
   csm2_nextstate : PROCESS (
      csm2_current_state,
      in_counter_r,
      load_columns,
      load_rows,
      wr_new_data
   )
   ----------------------------------------------------------------------------
   BEGIN
      CASE csm2_current_state IS
      WHEN i_ready =>
         IF (load_columns = '1') THEN
            csm2_next_state <= wait_1st_data;
         ELSIF (load_rows = '1') THEN
            csm2_next_state <= wait_ram_rd;
         ELSE
            csm2_next_state <= i_ready;
         END IF;
      WHEN i_load_row =>
         IF (in_counter_r = 7) THEN
            csm2_next_state <= wait_load;
         ELSE
            csm2_next_state <= i_load_row;
         END IF;
      WHEN i_load_column =>
         IF (in_counter_r = 7 AND wr_new_data = '1') THEN
            csm2_next_state <= i_ready;
         ELSE
            csm2_next_state <= i_load_column;
         END IF;
      WHEN wait_ram_rd =>
            csm2_next_state <= i_load_row;
      WHEN wait_load =>
            csm2_next_state <= i_ready;
      WHEN wait_1st_data =>
         IF (wr_new_data = '1') THEN
            csm2_next_state <= i_load_column;
         ELSE
            csm2_next_state <= wait_1st_data;
         END IF;
      WHEN OTHERS =>
         csm2_next_state <= i_ready;
      END CASE;

   END PROCESS csm2_nextstate;

   ----------------------------------------------------------------------------
   csm2_output : PROCESS (
      csm2_current_state,
      wr_new_data
   )
   ----------------------------------------------------------------------------
   BEGIN
      -- Default Assignment
      load_dct_input <= '0';
      ready_for_rx <= '0';
      sel_input <= '0';
      -- Default Assignment To Internals
      col_ready <= '0';

      -- Combined Actions
      CASE csm2_current_state IS
      WHEN i_ready =>
         col_ready <= '1';
      WHEN i_load_row =>
         sel_input <= '0'; -- load data from ram
         load_dct_input <= '1';
      WHEN i_load_column =>
         sel_input <= '1';
         if (wr_new_data = '1') then
           load_dct_input <= '1';
         end if;
      WHEN wait_ram_rd =>
         sel_input <= '0';
      WHEN wait_load =>
         sel_input <= '0';
         load_dct_input <= '1';
      WHEN wait_1st_data =>
         sel_input <= '1';
         ready_for_rx <= '1';
         if (wr_new_data = '1') then
          load_dct_input <= '1';
         end if;
      WHEN OTHERS =>
         NULL;
      END CASE;

   END PROCESS csm2_output;

   -- Concurrent Statements
wraddr <= conv_std_logic_vector(row_wr_nr_r & out_counter_r, 6);
rdaddr <= conv_std_logic_vector(in_counter_r & row_rd_nr_r, 6);

END fsm;
