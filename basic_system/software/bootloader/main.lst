   1              		.file	"main.c"
   9              	.Ltext0:
  10              		.align	2
  11              		.global	io_read_gpio0_pin
  13              	io_read_gpio0_pin:
  14              	.LFB2:
  15              		.file 1 "io_driver.c"
   1:io_driver.c   **** #include "io_driver.h"
   2:io_driver.c   **** #include "storm_core.h"
   3:io_driver.c   **** #include "storm_soc_basic.h"
   4:io_driver.c   **** 
   5:io_driver.c   **** // ################################################################################################
   6:io_driver.c   **** // General Purpose IO (GENERAL_PURPOSE_CONTROLLER_0)
   7:io_driver.c   **** // ################################################################################################
   8:io_driver.c   **** 
   9:io_driver.c   **** // ******************************************************************************
  10:io_driver.c   **** // Read general purpose IO port
  11:io_driver.c   ****    unsigned long io_read_gpio0_pin(unsigned char pin)
  12:io_driver.c   **** // ******************************************************************************
  13:io_driver.c   **** {
  16              	 args = 0, pretend = 0, frame = 0
  17              		@ frame_needed = 0, uses_anonymous_args = 0
  18              		@ link register save eliminated.
  19              	.LVL0:
  20              		.loc 1 14 0
  14:io_driver.c   **** 	unsigned long temp = GPIO0_IN & (1<<pin);
  21              	r3, #61440
  22 0000 E3E03A0F 		ldr	r1, [r3, #-4091]
  23 0004 E5131FFB 		.loc 1 13 0
  24              		and	r2, r0, #255
  25 0008 E20020FF 		.loc 1 16 0
  15:io_driver.c   **** 	return (temp);
  16:io_driver.c   **** }
  26              	r0, #1
  27 000c E3A00001 	.LVL1:
  28              		and	r0, r1, r0, asl r2
  29 0010 E0010210 		.loc 1 13 0
  30              		@ lr needed for prologue
  31              		.loc 1 16 0
  32              		mov	pc, lr
  33 0014 E1A0F00E 	.LFE2:
  35              		.align	2
  36              		.global	io_read_gpio0_port
  38              	io_read_gpio0_port:
  39              	.LFB3:
  40              		.loc 1 22 0
  17:io_driver.c   **** 
  18:io_driver.c   **** // ******************************************************************************
  19:io_driver.c   **** // Read general purpose IO port
  20:io_driver.c   ****    unsigned long io_read_gpio0_port(void)
  21:io_driver.c   **** // ******************************************************************************
  22:io_driver.c   **** {
  41              	etend = 0, frame = 0
  42              		@ frame_needed = 0, uses_anonymous_args = 0
  43              		@ link register save eliminated.
  44              		.loc 1 23 0
  23:io_driver.c   **** 	return GPIO0_IN;
  45              		r3, #61440
  46 0018 E3E03A0F 		ldr	r0, [r3, #-4091]
  47 001c E5130FFB 		.loc 1 22 0
  48              		@ lr needed for prologue
  49              		.loc 1 24 0
  24:io_driver.c   **** }
  50              	pc, lr
  51 0020 E1A0F00E 	.LFE3:
  53              		.align	2
  54              		.global	io_set_gpio0_pin
  56              	io_set_gpio0_pin:
  57              	.LFB4:
  58              		.loc 1 30 0
  25:io_driver.c   **** 
  26:io_driver.c   **** // ******************************************************************************
  27:io_driver.c   **** // Set general purpose IO port
  28:io_driver.c   ****    void io_set_gpio0_pin(unsigned char pin)
  29:io_driver.c   **** // ******************************************************************************
  30:io_driver.c   **** {
  59              	 0, pretend = 0, frame = 0
  60              		@ frame_needed = 0, uses_anonymous_args = 0
  61              		@ link register save eliminated.
  62              	.LVL2:
  63              		.loc 1 31 0
  31:io_driver.c   **** 	GPIO0_OUT = GPIO0_OUT | (1<<pin);
  64              	r1, #61440
  65 0024 E3E01A0F 		ldr	r3, [r1, #-4095]
  66 0028 E5113FFF 		.loc 1 30 0
  67              		and	r0, r0, #255
  68 002c E20000FF 		.loc 1 31 0
  69              		mov	r2, #1
  70 0030 E3A02001 		orr	r3, r3, r2, asl r0
  71 0034 E1833012 		.loc 1 30 0
  72              		@ lr needed for prologue
  73              		.loc 1 31 0
  74              		str	r3, [r1, #-4095]
  75 0038 E5013FFF 		.loc 1 32 0
  32:io_driver.c   **** }
  76              	.LFE4:
  78              		.align	2
  79              		.global	io_clr_gpio0_pin
  81              	io_clr_gpio0_pin:
  82              	.LFB5:
  83              		.loc 1 38 0
  84              		@ args = 0, pretend = 0, frame = 0
  33:io_driver.c   **** 
  34:io_driver.c   **** // ******************************************************************************
  35:io_driver.c   **** // Clear general purpose IO port
  36:io_driver.c   ****    void io_clr_gpio0_pin(unsigned char pin)
  37:io_driver.c   **** // ******************************************************************************
  38:io_driver.c   **** {
  85              	needed = 0, uses_anonymous_args = 0
  86              		@ link register save eliminated.
  87              	.LVL3:
  88              		and	r0, r0, #255
  89              		.loc 1 39 0
  90 0040 E20000FF 		mov	r2, #1
  39:io_driver.c   **** 	GPIO0_OUT = GPIO0_OUT & ~(1<<pin);
  91              	2, r2, asl r0
  92 0044 E3A02001 		mvn	r1, #61440
  93 0048 E1A02012 		ldr	r3, [r1, #-4095]
  94 004c E3E01A0F 		mvn	r2, r2
  95 0050 E5113FFF 		and	r3, r3, r2
  96 0054 E1E02002 		.loc 1 38 0
  97 0058 E0033002 		@ lr needed for prologue
  98              		.loc 1 39 0
  99              		str	r3, [r1, #-4095]
 100              		.loc 1 40 0
 101 005c E5013FFF 		mov	pc, lr
  40:io_driver.c   **** }
 102              	ze	io_clr_gpio0_pin, .-io_clr_gpio0_pin
 103 0060 E1A0F00E 		.align	2
 104              		.global	io_toggle_gpio0_pin
 106              	io_toggle_gpio0_pin:
 107              	.LFB6:
 108              		.loc 1 45 0
 109              		@ args = 0, pretend = 0, frame = 0
 110              		@ frame_needed = 0, uses_anonymous_args = 0
  41:io_driver.c   **** // ******************************************************************************
  42:io_driver.c   **** // Set general purpose IO port
  43:io_driver.c   ****    void io_toggle_gpio0_pin(unsigned char pin)
  44:io_driver.c   **** // ******************************************************************************
  45:io_driver.c   **** {
 111              	egister save eliminated.
 112              	.LVL4:
 113              		.loc 1 46 0
 114              		mvn	r1, #61440
 115              		ldr	r3, [r1, #-4095]
  46:io_driver.c   **** 	GPIO0_OUT = GPIO0_OUT ^ (1<<pin);
 116              	 1 45 0
 117 0064 E3E01A0F 		and	r0, r0, #255
 118 0068 E5113FFF 		.loc 1 46 0
 119              		mov	r2, #1
 120 006c E20000FF 		eor	r3, r3, r2, asl r0
 121              		.loc 1 45 0
 122 0070 E3A02001 		@ lr needed for prologue
 123 0074 E0233012 		.loc 1 46 0
 124              		str	r3, [r1, #-4095]
 125              		.loc 1 47 0
 126              		mov	pc, lr
 127 0078 E5013FFF 	.LFE6:
  47:io_driver.c   **** }
 128              	ggle_gpio0_pin, .-io_toggle_gpio0_pin
 129 007c E1A0F00E 		.align	2
 130              		.global	io_set_gpio0_port
 132              	io_set_gpio0_port:
 133              	.LFB7:
 134              		.loc 1 53 0
 135              		@ args = 0, pretend = 0, frame = 0
 136              		@ frame_needed = 0, uses_anonymous_args = 0
  48:io_driver.c   **** 
  49:io_driver.c   **** // ******************************************************************************
  50:io_driver.c   **** // Clear general purpose IO port
  51:io_driver.c   ****    void io_set_gpio0_port(unsigned long value)
  52:io_driver.c   **** // ******************************************************************************
  53:io_driver.c   **** {
 137              	egister save eliminated.
 138              	.LVL5:
 139              		.loc 1 54 0
 140              		mvn	r3, #61440
 141              		.loc 1 53 0
  54:io_driver.c   **** 	GPIO0_OUT = value;
 142              	 needed for prologue
 143 0080 E3E03A0F 		.loc 1 54 0
 144              		str	r0, [r3, #-4095]
 145              		.loc 1 55 0
 146              		mov	pc, lr
 147 0084 E5030FFF 	.LFE7:
  55:io_driver.c   **** }
 148              		io_set_gpio0_port, .-io_set_gpio0_port
 149 0088 E1A0F00E 		.align	2
 150              		.global	io_set_pwm
 152              	io_set_pwm:
 153              	.LFB8:
 154              		.loc 1 67 0
 155              		@ args = 0, pretend = 0, frame = 0
 156              		@ frame_needed = 0, uses_anonymous_args = 0
  56:io_driver.c   **** 
  57:io_driver.c   **** 
  58:io_driver.c   **** 
  59:io_driver.c   **** // ################################################################################################
  60:io_driver.c   **** // Pulse-Width-Modulation Controller
  61:io_driver.c   **** // ################################################################################################
  62:io_driver.c   **** 
  63:io_driver.c   **** // ******************************************************************************
  64:io_driver.c   **** // Set pwm value
  65:io_driver.c   ****    void io_set_pwm(unsigned char port, unsigned char data)
  66:io_driver.c   **** // ******************************************************************************
  67:io_driver.c   **** {
 157              	nd	r0, r0, #255
 158              		.loc 1 71 0
 159              		cmp	r0, #7
 160              		.loc 1 67 0
 161 008c E20000FF 		stmfd	sp!, {r4, lr}
  68:io_driver.c   **** 	unsigned long temp = 0;
  69:io_driver.c   **** 
  70:io_driver.c   **** 	// value adjustment
  71:io_driver.c   **** 	if(port > 7)
 162              	0:
 163 0090 E3500007 		.loc 1 71 0
 164              		mov	ip, #0
 165 0094 E92D4010 		mvn	lr, #255
 166              		.loc 1 67 0
 167              		and	r1, r1, #255
 168 0098 E3A0C000 		.loc 1 71 0
 169 009c E3E0E0FF 		bhi	.L16
 170              		.loc 1 83 0
 171 00a0 E20110FF 		sub	r3, r0, #4
 172              		and	r3, r3, #255
 173 00a4 8A000011 		.loc 1 74 0
  72:io_driver.c   **** 		port = 0;
  73:io_driver.c   **** 
  74:io_driver.c   **** 	if(port < 4){
  75:io_driver.c   **** 		temp = PWM0_CONF0; // get working copy
  76:io_driver.c   **** 		temp = temp & ~(0xFF << (port*8)); // clear old value
  77:io_driver.c   **** 		temp = temp | (unsigned long)(data << (port*8)); // insert new value
  78:io_driver.c   **** 		PWM0_CONF0 = temp;
  79:io_driver.c   **** 	}
  80:io_driver.c   **** 	else{
  81:io_driver.c   **** 		port = port-4;
  82:io_driver.c   **** 		temp = PWM0_CONF1; // get working copy
  83:io_driver.c   **** 		temp = temp & ~(0xFF << (port*8)); // clear old value
 174              		.loc 1 83 0
 175 00a8 E2403004 		mov	lr, r3, asl #3
 176 00ac E20330FF 		.loc 1 82 0
 177              		mvn	r4, #61440
 178 00b0 E3500003 		.loc 1 74 0
 179              		mov	ip, r0, asl #3
 180 00b4 E1A0E183 		bls	.L22
 181              		.loc 1 83 0
 182 00b8 E3E04A0F 		mov	r3, #255
 183              		mov	r3, r3, asl lr
 184 00bc E1A0C180 		.loc 1 82 0
 185 00c0 9A000007 		ldr	r2, [r4, #-3979]
 186              	.LVL7:
 187 00c4 E3A030FF 		.loc 1 83 0
 188 00c8 E1A03E13 		mvn	r3, r3
 189              		and	r2, r2, r3
 190 00cc E5142F8B 	.LVL8:
 191              		.loc 1 84 0
 192              		orr	r2, r2, r1, asl lr
 193 00d0 E1E03003 	.LVL9:
 194 00d4 E0022003 		.loc 1 85 0
 195              		str	r2, [r4, #-3979]
  84:io_driver.c   **** 		temp = temp | (unsigned long)(data << (port*8)); // insert new value
 196              	LVL10:
 197 00d8 E1822E11 	.L22:
 198              		.loc 1 74 0
  85:io_driver.c   **** 		PWM0_CONF1 = temp;
 199              	v	r3, #255
 200 00dc E5042F8B 		mov	r3, r3, asl ip
 201 00e0 E8BD8010 		mvn	lr, r3
 202              	.L16:
 203              		.loc 1 75 0
 204              		mvn	r2, #61440
 205 00e4 E3A030FF 		ldr	r3, [r2, #-3983]
 206 00e8 E1A03C13 	.LVL11:
 207 00ec E1E0E003 		.loc 1 76 0
 208              		and	r3, r3, lr
 209              	.LVL12:
 210 00f0 E3E02A0F 		.loc 1 77 0
 211 00f4 E5123F8F 		orr	r3, r3, r1, asl ip
 212              	.LVL13:
 213              		.loc 1 78 0
 214 00f8 E003300E 		str	r3, [r2, #-3983]
 215              		ldmfd	sp!, {r4, pc}
 216              	.LFE8:
 218              		.align	2
 219              		.global	io_get_pwm
 221 0104 E8BD8010 	io_get_pwm:
 222              	.LFB9:
 223              		.loc 1 93 0
 224              		@ args = 0, pretend = 0, frame = 0
 225              		@ frame_needed = 0, uses_anonymous_args = 0
 226              		@ link register save eliminated.
 227              	.LVL14:
 228              		and	r0, r0, #255
  86:io_driver.c   **** 	}
  87:io_driver.c   **** }
  88:io_driver.c   **** 
  89:io_driver.c   **** // ******************************************************************************
  90:io_driver.c   **** // Set pwm value
  91:io_driver.c   ****    unsigned char io_get_pwm(unsigned char port)
  92:io_driver.c   **** // ******************************************************************************
  93:io_driver.c   **** {
 229              	 1 93 0
 230              		@ lr needed for prologue
 231              		.loc 1 97 0
 232              		mov	r2, #0
 233              		bhi	.L26
 234 0108 E20000FF 		.loc 1 104 0
  94:io_driver.c   **** 	unsigned long temp = 0;
  95:io_driver.c   **** 
  96:io_driver.c   **** 	// value adjustment
  97:io_driver.c   **** 	if(port > 7)
 235              	3, r0, #4
 236 010c E3500007 		.loc 1 100 0
 237              		cmp	r0, #3
 238              		.loc 1 104 0
 239              		and	r2, r3, #255
 240 0110 E3A02000 		.loc 1 100 0
 241 0114 8A00000A 		bls	.L31
  98:io_driver.c   **** 		port = 0;
  99:io_driver.c   **** 
 100:io_driver.c   **** 	if(port < 4)
 101:io_driver.c   **** 		temp = PWM0_CONF0; // get config register
 102:io_driver.c   **** 	else{
 103:io_driver.c   **** 		port = port-4;
 104:io_driver.c   **** 		temp = PWM0_CONF1; // get config register
 242              	 104 0
 243 0118 E2403004 		mvn	r3, #61440
 244              		ldr	r0, [r3, #-3979]
 245 011c E3500003 	.LVL15:
 246              		mov	r2, r2, asl #3
 247 0120 E20320FF 		mov	r0, r0, lsr r2
 248              	.LVL16:
 249 0124 9A000005 		and	r0, r0, #255
 250              		.loc 1 110 0
 251 0128 E3E03A0F 		mov	pc, lr
 252 012c E5130F8B 	.LVL17:
 253              	.L31:
 254 0130 E1A02182 		.loc 1 100 0
 255 0134 E1A00230 		mov	r2, r0, asl #3
 256              	.L26:
 257 0138 E20000FF 		.loc 1 101 0
 105:io_driver.c   **** 	}
 106:io_driver.c   **** 
 107:io_driver.c   **** 	temp = temp >> (port*8); // only keep designated byte
 108:io_driver.c   **** 
 109:io_driver.c   **** 	return (unsigned char)temp;
 110:io_driver.c   **** }
 258              		ldr	r0, [r3, #-3983]
 259 013c E1A0F00E 	.LVL18:
 260              		.loc 1 104 0
 261              		mov	r0, r0, lsr r2
 262              	.LVL19:
 263 0140 E1A02180 		and	r0, r0, #255
 264              		.loc 1 110 0
 265              		mov	pc, lr
 266 0144 E3E03A0F 	.LFE9:
 268              		.align	2
 269              		.global	io_uart0_read_byte
 271              	io_uart0_read_byte:
 272 0150 E20000FF 	.LFB10:
 273              		.loc 1 122 0
 274 0154 E1A0F00E 		@ args = 0, pretend = 0, frame = 0
 275              		@ frame_needed = 0, uses_anonymous_args = 0
 276              		@ link register save eliminated.
 277              		.loc 1 123 0
 278              		mvn	r2, #61440
 279              		ldr	r3, [r2, #-4067]
 280              		tst	r3, #2
 281              		mvn	r0, #0
 111:io_driver.c   **** 
 112:io_driver.c   **** 
 113:io_driver.c   **** 
 114:io_driver.c   **** // ################################################################################################
 115:io_driver.c   **** // General Purpose UART "miniUART" (UART_0)
 116:io_driver.c   **** // ################################################################################################
 117:io_driver.c   **** 
 118:io_driver.c   **** // ******************************************************************************
 119:io_driver.c   **** // Read one byte via UART 0
 120:io_driver.c   ****    int io_uart0_read_byte(void)
 121:io_driver.c   **** // ******************************************************************************
 122:io_driver.c   **** {
 282              	 [r2, #-4071]
 283              		.loc 1 122 0
 284              		@ lr needed for prologue
 285              		.loc 1 127 0
 123:io_driver.c   **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 286              		pc, lr
 287 0158 E3E02A0F 	.LFE10:
 289 0160 E3130002 		.align	2
 290 0164 E3E00000 		.global	io_uart0_send_byte
 124:io_driver.c   **** 		return UART0_DATA;
 291              	e	io_uart0_send_byte, %function
 292 0168 15120FE7 	io_uart0_send_byte:
 293              	.LFB11:
 294              		.loc 1 133 0
 125:io_driver.c   **** 	else
 126:io_driver.c   **** 		return -1;
 127:io_driver.c   **** }
 295              	rgs = 0, pretend = 0, frame = 0
 296 016c E1A0F00E 		@ frame_needed = 0, uses_anonymous_args = 0
 297              		@ link register save eliminated.
 298              	.LVL20:
 299              		@ lr needed for prologue
 300              		mvn	r2, #61440
 301              	.L39:
 302              		.loc 1 134 0
 303              		ldr	r3, [r2, #-4067]
 128:io_driver.c   **** 
 129:io_driver.c   **** // ******************************************************************************
 130:io_driver.c   **** // Write one byte via UART 0
 131:io_driver.c   ****    int io_uart0_send_byte(int ch)
 132:io_driver.c   **** // ******************************************************************************
 133:io_driver.c   **** {
 304              	#1
 305              		beq	.L39
 306              		.loc 1 135 0
 307              		and	r3, r0, #255
 308              		str	r3, [r2, #-4071]
 309              	.LVL21:
 310 0170 E3E02A0F 		.loc 1 137 0
 311              		mov	pc, lr
 134:io_driver.c   **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 313 0174 E5123FE3 		.align	2
 314 0178 E3130001 		.global	io_spi0_config
 135:io_driver.c   **** 	UART0_DATA = (ch & 0x000000FF);
 316              	pi0_config:
 317 0180 E20030FF 	.LFB12:
 318 0184 E5023FE7 		.loc 1 149 0
 319              		@ args = 0, pretend = 0, frame = 0
 136:io_driver.c   **** 	return ch;
 137:io_driver.c   **** }
 320              	rame_needed = 0, uses_anonymous_args = 0
 321 0188 E1A0F00E 		@ link register save eliminated.
 322              	.LVL22:
 323              		and	r0, r0, #255
 324              		.loc 1 153 0
 325              		cmp	r0, #1
 326              		.loc 1 156 0
 327              		orr	r2, r1, #1024
 328              		.loc 1 154 0
 138:io_driver.c   **** 
 139:io_driver.c   **** 
 140:io_driver.c   **** 
 141:io_driver.c   **** // ################################################################################################
 142:io_driver.c   **** // Serial Peripherial Interface (SPI_CONTROLLER_0)
 143:io_driver.c   **** // ################################################################################################
 144:io_driver.c   **** 
 145:io_driver.c   **** // ******************************************************************************
 146:io_driver.c   **** // Configure SPI 0
 147:io_driver.c   ****    void io_spi0_config(unsigned char auto_cs, unsigned long data_size)
 148:io_driver.c   **** // ******************************************************************************
 149:io_driver.c   **** {
 329              	, #61440
 330              		orr	r1, r1, #9216
 331              	.LVL23:
 332              		.loc 1 156 0
 333              		mvnne	r3, #61440
 334 018c E20000FF 		.loc 1 149 0
 150:io_driver.c   **** 	// devices update their serial input on a rising edge of sclk,
 151:io_driver.c   **** 	// so we need to update the mosi output of the core before
 152:io_driver.c   **** 	// -> at the falling edge of sclk = set SPI_TX_NEG
 153:io_driver.c   **** 	if(auto_cs == 1)
 335              	needed for prologue
 336 0190 E3500001 		.loc 1 154 0
 154:io_driver.c   **** 		SPI0_CONF = (1<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // auto assert cs
 155:io_driver.c   **** 	else
 156:io_driver.c   **** 		SPI0_CONF = (0<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // manual assert cs
 337              	treq	r1, [r3, #-4047]
 338 0194 E3812B01 		.loc 1 156 0
 339              		strne	r2, [r3, #-4047]
 340 0198 03E03A0F 		mov	pc, lr
 341 019c E3811B09 	.LFE12:
 343              		.align	2
 344 01a0 13E03A0F 		.global	io_spi0_speed
 346              	io_spi0_speed:
 347              	.LFB13:
 348 01a4 05031FCF 		.loc 1 163 0
 349              		@ args = 0, pretend = 0, frame = 0
 350 01a8 15032FCF 		@ frame_needed = 0, uses_anonymous_args = 0
 351 01ac E1A0F00E 		@ link register save eliminated.
 352              	.LVL24:
 353              		.loc 1 164 0
 354              		mvn	r3, #61440
 355              		.loc 1 163 0
 356              		@ lr needed for prologue
 357              		.loc 1 164 0
 358              		str	r0, [r3, #-4043]
 157:io_driver.c   **** }
 158:io_driver.c   **** 
 159:io_driver.c   **** // ******************************************************************************
 160:io_driver.c   **** // Configure SPI 0 CLK frequency -> (sys_clk/(spi_clk*2))-1
 161:io_driver.c   ****    void io_spi0_speed(unsigned long clk_divider)
 162:io_driver.c   **** // ******************************************************************************
 163:io_driver.c   **** {
 359              	 lr
 360              	.LFE13:
 362              		.align	2
 363              		.global	io_spi0_trans
 164:io_driver.c   **** 	SPI0_PRSC = clk_divider; // (sys_clk/(spi_clk*2))-1;
 364              	e	io_spi0_trans, %function
 365 01b0 E3E03A0F 	io_spi0_trans:
 366              	.LFB14:
 367              		.loc 1 171 0
 368              		@ args = 0, pretend = 0, frame = 0
 369 01b4 E5030FCB 		@ frame_needed = 0, uses_anonymous_args = 0
 165:io_driver.c   **** }
 370              	k register save eliminated.
 371 01b8 E1A0F00E 	.LVL25:
 372              		@ lr needed for prologue
 373              		mvn	r2, #61440
 374              	.L53:
 375              		.loc 1 173 0
 376              		ldr	r3, [r2, #-4047]
 377              		tst	r3, #256
 378              		bne	.L53
 166:io_driver.c   **** 
 167:io_driver.c   **** // ******************************************************************************
 168:io_driver.c   **** // Sends/receives max 32 bits via SPI, CS and config must be done outside
 169:io_driver.c   ****    unsigned long io_spi0_trans(unsigned long data)
 170:io_driver.c   **** // ******************************************************************************
 171:io_driver.c   **** {
 379              	74 0
 380              		str	r0, [r2, #-4031]
 381              		.loc 1 175 0
 382              		ldr	r3, [r2, #-4047]
 383              		orr	r3, r3, #256
 384              		str	r3, [r2, #-4047]
 385 01bc E3E02A0F 		mvn	r2, #61440
 386              	.L55:
 172:io_driver.c   **** 	// spi transmission
 173:io_driver.c   **** 	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for prev tx to finish
 387              	176 0
 388 01c0 E5123FCF 		ldr	r3, [r2, #-4047]
 389 01c4 E3130C01 		tst	r3, #256
 390 01c8 1AFFFFFC 		bne	.L55
 174:io_driver.c   **** 	SPI0_DAT0 = data;
 391              	c 1 178 0
 392 01cc E5020FBF 		ldr	r0, [r2, #-4031]
 175:io_driver.c   **** 	SPI0_CONF = SPI0_CONF | (1<<SPI_BUSY); // start transmitter
 393              	VL26:
 394 01d0 E5123FCF 		.loc 1 179 0
 395 01d4 E3833C01 		mov	pc, lr
 396 01d8 E5023FCF 	.LFE14:
 398              		.align	2
 176:io_driver.c   **** 	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for rx to finish
 399              	al	io_spi0_enable
 401 01e4 E3130C01 	io_spi0_enable:
 402 01e8 1AFFFFFC 	.LFB15:
 177:io_driver.c   **** 
 178:io_driver.c   **** 	return SPI0_DAT0;
 403              	c 1 185 0
 404 01ec E5120FBF 		@ args = 0, pretend = 0, frame = 0
 405              		@ frame_needed = 0, uses_anonymous_args = 0
 179:io_driver.c   **** }
 406              	link register save eliminated.
 407 01f0 E1A0F00E 	.LVL27:
 408              		.loc 1 186 0
 409              		mvn	r1, #61440
 410              		ldr	r3, [r1, #-4039]
 411              		.loc 1 185 0
 412              		and	r0, r0, #255
 413              		.loc 1 186 0
 414              		mov	r2, #1
 180:io_driver.c   **** 
 181:io_driver.c   **** // ******************************************************************************
 182:io_driver.c   **** // Controls the CS of SPI0, enables a connected CS (turns it LOW)
 183:io_driver.c   ****    void io_spi0_enable(unsigned char device)
 184:io_driver.c   **** // ******************************************************************************
 185:io_driver.c   **** {
 415              	r3, r2, asl r0
 416              		.loc 1 185 0
 417              		@ lr needed for prologue
 418              		.loc 1 186 0
 419              		str	r3, [r1, #-4039]
 186:io_driver.c   **** 	SPI0_SCSR = SPI0_SCSR | (1<<device);
 420              	 1 187 0
 421 01f4 E3E01A0F 		mov	pc, lr
 422 01f8 E5113FC7 	.LFE15:
 424 01fc E20000FF 		.align	2
 425              		.global	io_spi0_disable
 427 0204 E1833012 	io_spi0_disable:
 428              	.LFB16:
 429              		.loc 1 193 0
 430              		@ args = 0, pretend = 0, frame = 0
 431 0208 E5013FC7 		@ frame_needed = 0, uses_anonymous_args = 0
 187:io_driver.c   **** }
 432              	ster save eliminated.
 433 020c E1A0F00E 	.LVL28:
 434              		and	r0, r0, #255
 435              		.loc 1 194 0
 436              		mov	r2, #1
 437              		mov	r2, r2, asl r0
 438              		mvn	r1, #61440
 439              		ldr	r3, [r1, #-4039]
 440              		mvn	r2, r2
 188:io_driver.c   **** 
 189:io_driver.c   **** // ******************************************************************************
 190:io_driver.c   **** // Controls the CS of SPI0, disables a connected CS (turns it HIGH)
 191:io_driver.c   ****    void io_spi0_disable(unsigned char device)
 192:io_driver.c   **** // ******************************************************************************
 193:io_driver.c   **** {
 441              	r3, r2
 442              		.loc 1 193 0
 443              		@ lr needed for prologue
 444              		.loc 1 194 0
 445              		str	r3, [r1, #-4039]
 446 0210 E20000FF 		.loc 1 195 0
 194:io_driver.c   **** 	SPI0_SCSR = SPI0_SCSR & ~(1<<device);
 447              	c, lr
 448 0214 E3A02001 	.LFE16:
 450 021c E3E01A0F 		.align	2
 451 0220 E5113FC7 		.global	io_i2c0_speed
 453 0228 E0033002 	io_i2c0_speed:
 454              	.LFB17:
 455              		.loc 1 208 0
 456              		@ args = 0, pretend = 0, frame = 0
 457 022c E5013FC7 		@ frame_needed = 0, uses_anonymous_args = 0
 195:io_driver.c   **** }
 458              	ister save eliminated.
 459 0230 E1A0F00E 	.LVL29:
 460              		.loc 1 209 0
 461              		mvn	r2, #61440
 462              		ldr	r3, [r2, #-3991]
 463              		.loc 1 211 0
 464              		mov	r1, r0, lsr #8
 465              		.loc 1 209 0
 466              		bic	r3, r3, #128
 196:io_driver.c   **** 
 197:io_driver.c   **** 
 198:io_driver.c   **** 
 199:io_driver.c   **** 
 200:io_driver.c   **** // ################################################################################################
 201:io_driver.c   **** // Inter Intergrated Circuit Interface (I²C_CONTROLLER_0)
 202:io_driver.c   **** // ################################################################################################
 203:io_driver.c   **** 
 204:io_driver.c   **** // ******************************************************************************
 205:io_driver.c   **** // Configure SPI 0 CLK frequency -> (sys_clk/(5*i2c_clock)-1
 206:io_driver.c   ****    void io_i2c0_speed(unsigned long clk_divider)
 207:io_driver.c   **** // ******************************************************************************
 208:io_driver.c   **** {
 467              	[r2, #-3991]
 468              		.loc 1 210 0
 469              		str	r0, [r2, #-3999]
 470              		.loc 1 211 0
 471              		str	r1, [r2, #-3995]
 209:io_driver.c   **** 	I2C0_CTRL = I2C0_CTRL & ~(1<<I2C_EN); // disable i2c core
 472              	 1 212 0
 473 0234 E3E02A0F 		ldr	r3, [r2, #-3991]
 474 0238 E5123F97 		orr	r3, r3, #128
 210:io_driver.c   **** 	I2C0_PRLO = clk_divider;
 211:io_driver.c   **** 	I2C0_PRHI = clk_divider >> 8;
 475              	oc 1 208 0
 476 023c E1A01420 		@ lr needed for prologue
 477              		.loc 1 212 0
 478 0240 E3C33080 		str	r3, [r2, #-3991]
 479 0244 E5023F97 		.loc 1 213 0
 480              		mov	pc, lr
 481 0248 E5020F9F 	.LFE17:
 483 024c E5021F9B 		.align	2
 212:io_driver.c   **** 	I2C0_CTRL = I2C0_CTRL | (1<<I2C_EN); // enable i2c core
 484              	io_i2c0_byte_transfer
 486 0254 E3833080 	io_i2c0_byte_transfer:
 487              	.LFB18:
 488              		.loc 1 223 0
 489              		@ args = 4, pretend = 0, frame = 0
 490 0258 E5023F97 		@ frame_needed = 0, uses_anonymous_args = 0
 213:io_driver.c   **** }
 491              	
 492 025c E1A0F00E 		stmfd	sp!, {r4, r5, lr}
 493              	.LCFI1:
 494              		.loc 1 226 0
 495              		mov	ip, #144
 496              		.loc 1 225 0
 497              		and	r4, r1, #254
 498              		mvn	lr, #61440
 499              	.LVL31:
 214:io_driver.c   **** 
 215:io_driver.c   **** // ******************************************************************************
 216:io_driver.c   **** // Read/write byte from/to I²C slave, max 2 address bytes
 217:io_driver.c   ****    int io_i2c0_byte_transfer(unsigned char rw,        // 'r' read / 'w' write cycle
 218:io_driver.c   ****                              unsigned char id,        // device ID
 219:io_driver.c   **** 							 unsigned long data_adr,  // byte address
 220:io_driver.c   **** 							 unsigned char adr_bytes, // number of adr bytes
 221:io_driver.c   **** 							 unsigned char data)      // data byte
 222:io_driver.c   **** // ******************************************************************************
 223:io_driver.c   **** {
 500              	223 0
 501              		ldrb	r5, [sp, #15]	@ zero_extendqisi2
 502              		and	r0, r0, #255
 503              		.loc 1 225 0
 504 0260 E92D4030 		str	r4, [lr, #-3987]
 505              		.loc 1 223 0
 224:io_driver.c   **** 	// transfer slave identification address
 225:io_driver.c   **** 	I2C0_DATA = id & 0xFE;                  // device id and write
 226:io_driver.c   **** 	I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 506              	1, r1, #255
 507 0264 E3A0C090 		.loc 1 226 0
 508              		str	ip, [lr, #-4015]
 509 0268 E20140FE 		.loc 1 223 0
 510 026c E3E0EA0F 		mov	r4, r2
 511              		and	ip, r3, #255
 512              	.LVL32:
 513 0270 E5DD500F 	.L69:
 514 0274 E20000FF 		.loc 1 227 0
 515              		ldr	r3, [lr, #-4015]
 516 0278 E50E4F93 		tst	r3, #2
 517              		bne	.L69
 518 027c E20110FF 		.loc 1 228 0
 519              		ldr	r3, [lr, #-4015]
 520 0280 E50ECFAF 		tst	r3, #128
 521              		mvnne	r0, #0
 522 0284 E1A04002 	.LVL33:
 523 0288 E203C0FF 		ldmnefd	sp!, {r4, r5, pc}
 524              	.L80:
 525              		.loc 1 232 0
 227:io_driver.c   **** 	while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 526              	09
 527 028c E51E3FAF 		.loc 1 233 0
 528 0290 E3130002 		sub	r3, ip, #1
 529 0294 1AFFFFFC 		and	ip, r3, #255
 228:io_driver.c   **** 	if((I2C0_STAT & (1<<I2C_RXACK)) != 0)   // ack received?
 530              	c 1 234 0
 531 0298 E51E3FAF 		cmp	ip, #1
 532 029c E3130080 		.loc 1 235 0
 533 02a0 13E00000 		moveq	r2, r4, lsr #8
 534              		mvneq	r3, #61440
 535 02a4 18BD8030 		.loc 1 237 0
 536              		mvnne	r3, #61440
 229:io_driver.c   **** 		return -1;
 230:io_driver.c   **** 
 231:io_driver.c   **** 	// transfer data address
 232:io_driver.c   **** 	while(adr_bytes != 0){
 537              	 235 0
 538 02a8 E35C0000 		streq	r2, [r3, #-3987]
 539 02ac 0A000012 		.loc 1 237 0
 233:io_driver.c   **** 		adr_bytes--;
 540              	rne	r4, [r3, #-3987]
 541 02b0 E24C3001 		.loc 1 238 0
 542 02b4 E203C0FF 		mvn	r2, #61440
 234:io_driver.c   **** 		if(adr_bytes == 1)
 543              	v	r3, #16
 544 02b8 E35C0001 		str	r3, [r2, #-4015]
 235:io_driver.c   **** 			I2C0_DATA = data_adr >> 8;          // high byte
 545              	78:
 546 02bc 01A02424 		.loc 1 239 0
 547 02c0 03E03A0F 		ldr	r3, [r2, #-4015]
 236:io_driver.c   **** 		else
 237:io_driver.c   **** 			I2C0_DATA = data_adr;               // low byte
 548              	t	r3, #2
 549 02c4 13E03A0F 		bne	.L78
 550              		.loc 1 240 0
 551 02c8 05032F93 		ldr	r3, [r2, #-4015]
 552              		tst	r3, #128
 553 02cc 15034F93 		beq	.L80
 238:io_driver.c   **** 		I2C0_CMD = (1<<I2C_WR);                 // write cycle
 554              	0, #1
 555 02d0 E3E02A0F 		ldmfd	sp!, {r4, r5, pc}
 556 02d4 E3A03010 	.LVL34:
 557 02d8 E5023FAF 	.L109:
 558              	.LVL35:
 239:io_driver.c   **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 559              	 1 244 0
 560 02dc E5123FAF 		cmp	r0, #119
 561 02e0 E3130002 		bne	.L83
 562 02e4 1AFFFFFC 		.loc 1 246 0
 240:io_driver.c   **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0)   // ack received?
 563              		r3, #61440
 564 02e8 E5123FAF 		.loc 1 247 0
 565 02ec E3130080 		mov	r2, #80
 566 02f0 0AFFFFEC 		.loc 1 246 0
 567 02f4 E3E00001 		str	r5, [r3, #-3987]
 568 02f8 E8BD8030 		.loc 1 247 0
 569              		str	r2, [r3, #-4015]
 570              		mov	r2, r3
 571              	.L85:
 241:io_driver.c   **** 			return -2;
 242:io_driver.c   **** 	}
 243:io_driver.c   **** 
 244:io_driver.c   **** 	if(rw == 'w'){
 572              	48 0
 573 02fc E3500077 		ldr	r3, [r2, #-4015]
 574 0300 1A00000C 		tst	r3, #2
 245:io_driver.c   **** 		// write adressed byte
 246:io_driver.c   **** 		I2C0_DATA = data;                       // send data
 575              	e	.L85
 576 0304 E3E03A0F 		.loc 1 249 0
 247:io_driver.c   **** 		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_WR);  // stop condition and write cycle
 577              	dr	r3, [r2, #-4015]
 578 0308 E3A02050 		ands	r0, r3, #128
 579              	.LVL36:
 580 030c E5035F93 		ldmeqfd	sp!, {r4, r5, pc}
 581              	.L87:
 582 0310 E5032FAF 		.loc 1 265 0
 583 0314 E1A02003 		mvn	r0, #2
 584              		.loc 1 269 0
 248:io_driver.c   **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 585              	p!, {r4, r5, pc}
 586 0318 E5123FAF 	.LVL37:
 587 031c E3130002 	.L83:
 588 0320 1AFFFFFC 		.loc 1 255 0
 249:io_driver.c   **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0)   // ack received?
 589              		r0, #114
 590 0324 E5123FAF 		mvnne	r0, #3
 591 0328 E2130080 	.LVL38:
 592              		ldmnefd	sp!, {r4, r5, pc}
 593 032c 08BD8030 		.loc 1 257 0
 594              		orr	r3, r1, #1
 250:io_driver.c   **** 			return -3;
 251:io_driver.c   **** 		else
 252:io_driver.c   **** 			return 0;
 253:io_driver.c   **** 	}
 254:io_driver.c   **** 
 255:io_driver.c   **** 	if(rw == 'r'){
 256:io_driver.c   **** 		// re-send control byte - this time with read-bit
 257:io_driver.c   **** 		I2C0_DATA = id | 0x01;                  // device id and READ
 258:io_driver.c   **** 		I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 259:io_driver.c   **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 260:io_driver.c   **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0)   // ack received?
 261:io_driver.c   **** 			return -3;
 262:io_driver.c   **** 		// read adressed byte
 263:io_driver.c   **** 		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_RD) | (1<<I2C_ACK);
 264:io_driver.c   **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 265:io_driver.c   **** 		return I2C0_DATA;
 595              	2, #61440
 596 0330 E3E00002 		.loc 1 258 0
 266:io_driver.c   **** 	}
 267:io_driver.c   **** 
 268:io_driver.c   **** 	return -4;
 269:io_driver.c   **** }
 597              	ov	r1, #144
 598 0334 E8BD8030 	.LVL39:
 599              		.loc 1 257 0
 600              		str	r3, [r2, #-3987]
 601              		.loc 1 258 0
 602 0338 E3500072 		str	r1, [r2, #-4015]
 603 033c 13E00003 	.L91:
 604              		.loc 1 259 0
 605 0340 18BD8030 		ldr	r3, [r2, #-4015]
 606              		tst	r3, #2
 607 0344 E3813001 		bne	.L91
 608 0348 E3E02A0F 		.loc 1 260 0
 609              		ldr	r3, [r2, #-4015]
 610 034c E3A01090 		tst	r3, #128
 611              		bne	.L87
 612              		.loc 1 263 0
 613 0350 E5023F93 		mov	r3, #104
 614              		str	r3, [r2, #-4015]
 615 0354 E5021FAF 		mvn	r0, #61440
 616              	.L94:
 617              		.loc 1 264 0
 618 0358 E5123FAF 		ldr	r3, [r0, #-4015]
 619 035c E3130002 		tst	r3, #2
 620 0360 1AFFFFFC 		bne	.L94
 621              		.loc 1 265 0
 622 0364 E5123FAF 		ldr	r0, [r0, #-3987]
 623 0368 E3130080 		ldmfd	sp!, {r4, r5, pc}
 624 036c 1AFFFFEF 	.LFE18:
 626 0370 E3A03068 		.align	2
 627 0374 E5023FAF 		.global	get_syscpreg
 629              	get_syscpreg:
 630              	.LFB19:
 631 037c E5103FAF 		.loc 1 282 0
 632 0380 E3130002 		@ args = 0, pretend = 0, frame = 0
 633 0384 1AFFFFFC 		@ frame_needed = 0, uses_anonymous_args = 0
 634              		@ link register save eliminated.
 635 0388 E5100F93 	.LVL40:
 636 038c E8BD8030 		and	r0, r0, #255
 637              		@ lr needed for prologue
 638              		.loc 1 284 0
 639              		cmp	r0, #13
 640              		ldrls	pc, [pc, r0, asl #2]
 641              		b	.L111
 642              		.p2align 2
 643              	.L121:
 270:io_driver.c   **** 
 271:io_driver.c   **** 
 272:io_driver.c   **** 
 273:io_driver.c   **** 
 274:io_driver.c   **** // ################################################################################################
 275:io_driver.c   **** // System
 276:io_driver.c   **** // ################################################################################################
 277:io_driver.c   **** 
 278:io_driver.c   **** // ******************************************************************************
 279:io_driver.c   **** // read system coprocessor register x
 280:io_driver.c   ****    unsigned long get_syscpreg(unsigned char index)
 281:io_driver.c   **** // ******************************************************************************
 282:io_driver.c   **** {
 644              	L111
 645              		.word	.L111
 646              		.word	.L111
 647              		.word	.L115
 648              		.word	.L111
 649 0390 E20000FF 		.word	.L116
 650              		.word	.L117
 283:io_driver.c   **** 	unsigned long _cp_val;
 284:io_driver.c   **** 	switch(index){
 651              	.L111
 652 0394 E350000D 		.word	.L118
 653 0398 979FF100 		.word	.L119
 654 039c EA000015 		.word	.L120
 655              	.L112:
 656              		.loc 1 285 0
 657 03a0 000003D8 		mrc p15,0,r0, c0, c0
 658 03a4 00000420 	.LVL41:
 659 03a8 00000418 		mov	pc, lr
 660 03ac 000003F8 	.LVL42:
 661 03b0 000003F8 	.L120:
 662 03b4 000003F8 		.loc 1 298 0
 663 03b8 00000410 		mrc p15,0,r0,c13,c13
 664 03bc 000003F8 	.LVL43:
 665 03c0 00000408 	.LVL44:
 666 03c4 00000400 		.loc 1 304 0
 667 03c8 000003F8 		mov	pc, lr
 668 03cc 000003F0 	.LVL45:
 669 03d0 000003E8 	.L119:
 670 03d4 000003E0 		.loc 1 297 0
 671              		mrc p15,0,r0,c12,c12
 285:io_driver.c   **** 		case ID_REG_0:   asm volatile ("mrc p15,0,%0, c0, c0" : "=r" (_cp_val) : /* no inputs */  ); brea
 672              	LVL47:
 673 03d8 EE100F10 	.L118:
 674              		.loc 1 296 0
 675 03dc E1A0F00E 		mrc p15,0,r0,c11,c11
 676              	.LVL48:
 677              		mov	pc, lr
 286:io_driver.c   **** 		case ID_REG_1:   asm volatile ("mrc p15,0,%0, c1, c1" : "=r" (_cp_val) : /* no inputs */  ); brea
 287:io_driver.c   **** 		case ID_REG_2:   asm volatile ("mrc p15,0,%0, c2, c2" : "=r" (_cp_val) : /* no inputs */  ); brea
 288:io_driver.c   **** //		case 3:          asm volatile ("mrc p15,0,%0, c3, c3" : "=r" (_cp_val) : /* no inputs */  ); br
 289:io_driver.c   **** //		case 4:          asm volatile ("mrc p15,0,%0, c4, c4" : "=r" (_cp_val) : /* no inputs */  ); br
 290:io_driver.c   **** //		case 5:          asm volatile ("mrc p15,0,%0, c5, c5" : "=r" (_cp_val) : /* no inputs */  ); br
 291:io_driver.c   **** 		case SYS_CTRL_0: asm volatile ("mrc p15,0,%0, c6, c6" : "=r" (_cp_val) : /* no inputs */  ); brea
 292:io_driver.c   **** //		case 7:          asm volatile ("mrc p15,0,%0, c7, c7" : "=r" (_cp_val) : /* no inputs */  ); br
 293:io_driver.c   **** 		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); brea
 294:io_driver.c   **** 		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); brea
 295:io_driver.c   **** //		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); br
 296:io_driver.c   **** 		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); brea
 297:io_driver.c   **** 		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); brea
 298:io_driver.c   **** 		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); brea
 678              	:
 679 03e0 EE1D0F1D 	.L111:
 680              		.loc 1 284 0
 681              		mov	r0, #0
 299:io_driver.c   **** //		case 14:         asm volatile ("mrc p15,0,%0,c14,c14" : "=r" (_cp_val) : /* no inputs */  ); br
 300:io_driver.c   **** //		case 15:         asm volatile ("mrc p15,0,%0,c15,c15" : "=r" (_cp_val) : /* no inputs */  ); br
 301:io_driver.c   **** 		default:         _cp_val = 0; break;
 302:io_driver.c   **** 	}
 303:io_driver.c   **** 	return _cp_val;
 304:io_driver.c   **** }
 682              	50:
 683 03e4 E1A0F00E 		mov	pc, lr
 684              	.LVL51:
 685              	.L117:
 686              		.loc 1 294 0
 687 03e8 EE1C0F1C 		mrc p15,0,r0, c9, c9
 688              	.LVL52:
 689 03ec E1A0F00E 		mov	pc, lr
 690              	.LVL53:
 691              	.L116:
 692              		.loc 1 293 0
 693 03f0 EE1B0F1B 		mrc p15,0,r0, c8, c8
 694              	.LVL54:
 695 03f4 E1A0F00E 		mov	pc, lr
 696              	.LVL55:
 697              	.L115:
 698              		.loc 1 291 0
 699 03f8 E3A00000 		mrc p15,0,r0, c6, c6
 700              	.LVL56:
 701 03fc E1A0F00E 		mov	pc, lr
 702              	.LVL57:
 703              	.L114:
 704              		.loc 1 287 0
 705 0400 EE190F19 		mrc p15,0,r0, c2, c2
 706              	.LVL58:
 707 0404 E1A0F00E 		mov	pc, lr
 708              	.LVL59:
 709              	.L113:
 710              		.loc 1 286 0
 711 0408 EE180F18 		mrc p15,0,r0, c1, c1
 712              	.LVL60:
 713 040c E1A0F00E 		mov	pc, lr
 714              	.LFE19:
 716              		.align	2
 717 0410 EE160F16 		.global	set_syscpreg
 719 0414 E1A0F00E 	set_syscpreg:
 720              	.LFB20:
 721              		.loc 1 310 0
 722              		@ args = 0, pretend = 0, frame = 0
 723 0418 EE120F12 		@ frame_needed = 0, uses_anonymous_args = 0
 724              		@ link register save eliminated.
 725 041c E1A0F00E 	.LVL61:
 726              		and	r1, r1, #255
 727              		.loc 1 311 0
 728              		sub	r1, r1, #6
 729 0420 EE110F11 	.LVL62:
 730              		.loc 1 310 0
 731 0424 E1A0F00E 		@ lr needed for prologue
 732              		.loc 1 311 0
 733              		cmp	r1, #7
 734              		ldrls	pc, [pc, r1, asl #2]
 735              		b	.L131
 736              		.p2align 2
 737              	.L130:
 738              		.word	.L126
 305:io_driver.c   **** 
 306:io_driver.c   **** // ******************************************************************************
 307:io_driver.c   **** // write system coprocessor register x
 308:io_driver.c   ****    void set_syscpreg(unsigned long _cp_val, unsigned char index)
 309:io_driver.c   **** // ******************************************************************************
 310:io_driver.c   **** {
 739              	d	.L127
 740              		.word	.L128
 741              		.word	.L129
 742              	.L129:
 743              		.loc 1 325 0
 744 0428 E20110FF 		mcr p15,0,r0,c13,c13,0
 311:io_driver.c   **** 	switch(index){
 745              	
 746 042c E2411006 		mov	pc, lr
 747              	.L126:
 748              		.loc 1 318 0
 749              		mcr p15,0,r0, c6, c6,0
 750              		mov	pc, lr
 751 0430 E3510007 	.L127:
 752 0434 979FF101 		.loc 1 323 0
 753 0438 EA000008 		mcr p15,0,r0,c11,c11,0
 754              		mov	pc, lr
 755              	.L128:
 756 043c 00000464 		.loc 1 324 0
 757 0440 00000460 		mcr p15,0,r0,c12,c12,0
 758 0444 00000460 		mov	pc, lr
 759 0448 00000460 	.LFE20:
 761 0450 0000046C 		.align	2
 762 0454 00000474 		.global	get_cmsr
 764              	get_cmsr:
 312:io_driver.c   **** //		case ID_REG_0:   asm volatile ("mcr p15,0,%0, c0, c0,0" : /* no outputs */ : "r" (_cp_val)); br
 313:io_driver.c   **** //		case ID_REG_1:   asm volatile ("mcr p15,0,%0, c1, c1,0" : /* no outputs */ : "r" (_cp_val)); br
 314:io_driver.c   **** //		case ID_REG_2:   asm volatile ("mcr p15,0,%0, c2, c2,0" : /* no outputs */ : "r" (_cp_val)); br
 315:io_driver.c   **** //		case 3:          asm volatile ("mcr p15,0,%0, c3, c3,0" : /* no outputs */ : "r" (_cp_val)); br
 316:io_driver.c   **** //		case 4:          asm volatile ("mcr p15,0,%0, c4, c4,0" : /* no outputs */ : "r" (_cp_val)); br
 317:io_driver.c   **** //		case 5:          asm volatile ("mcr p15,0,%0, c5, c5,0" : /* no outputs */ : "r" (_cp_val)); br
 318:io_driver.c   **** 		case SYS_CTRL_0: asm volatile ("mcr p15,0,%0, c6, c6,0" : /* no outputs */ : "r" (_cp_val)); brea
 319:io_driver.c   **** //		case 7:          asm volatile ("mcr p15,0,%0, c7, c7,0" : /* no outputs */ : "r" (_cp_val)); br
 320:io_driver.c   **** //		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); br
 321:io_driver.c   **** //		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); br
 322:io_driver.c   **** //		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); br
 323:io_driver.c   **** 		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); brea
 324:io_driver.c   **** 		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); brea
 325:io_driver.c   **** 		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); brea
 765              	 0
 766 045c EE0D0F1D 		@ args = 0, pretend = 0, frame = 0
 767              		@ frame_needed = 0, uses_anonymous_args = 0
 768 0460 E1A0F00E 		@ link register save eliminated.
 769              		@ lr needed for prologue
 770              		.loc 1 337 0
 771 0464 EE060F16 		 mrs r0, cpsr
 772 0468 E1A0F00E 	.LVL63:
 773              	.LVL64:
 774              		.loc 1 339 0
 775 046c EE0B0F1B 		mov	pc, lr
 776 0470 E1A0F00E 	.LFE21:
 778              		.align	2
 779 0474 EE0C0F1C 		.global	set_cmsr
 781              	set_cmsr:
 782              	.LFB22:
 783              		.loc 1 345 0
 784              		@ args = 0, pretend = 0, frame = 0
 785              		@ frame_needed = 0, uses_anonymous_args = 0
 786              		@ link register save eliminated.
 787              	.LVL65:
 326:io_driver.c   **** //		case 14:         asm volatile ("mcr p15,0,%0,c14,c14,0" : /* no outputs */ : "r" (_cp_val)); br
 327:io_driver.c   **** //		case 15:         asm volatile ("mcr p15,0,%0,c15,c15,0" : /* no outputs */ : "r" (_cp_val)); br
 328:io_driver.c   **** 		default:         break;
 329:io_driver.c   **** 	}
 330:io_driver.c   **** }
 331:io_driver.c   **** // ******************************************************************************
 332:io_driver.c   **** // read CMSR value
 333:io_driver.c   ****    unsigned long get_cmsr(void)
 334:io_driver.c   **** // ******************************************************************************
 335:io_driver.c   **** {
 788              	ue
 789              		.loc 1 346 0
 790              		 msr cpsr, r0
 791              		.loc 1 347 0
 792              		mov	pc, lr
 336:io_driver.c   **** 	unsigned long _cmsr;
 337:io_driver.c   **** 	asm volatile (" mrs %0, cpsr" : "=r" (_cmsr) : /* no inputs */  );
 793              	2:
 795              		.align	2
 796              		.global	io_enable_irq
 338:io_driver.c   **** 	return _cmsr;
 339:io_driver.c   **** }
 797              	pe	io_enable_irq, %function
 798 0480 E1A0F00E 	io_enable_irq:
 799              	.LFB23:
 800              		.loc 1 353 0
 801              		@ args = 0, pretend = 0, frame = 0
 802              		@ frame_needed = 0, uses_anonymous_args = 0
 803              		str	lr, [sp, #-4]!
 804              	.LCFI2:
 805              		.loc 1 354 0
 340:io_driver.c   **** 
 341:io_driver.c   **** // ******************************************************************************
 342:io_driver.c   **** // write CMSR value
 343:io_driver.c   ****    void set_cmsr(unsigned long _cmsr)
 344:io_driver.c   **** // ******************************************************************************
 345:io_driver.c   **** {
 806              	msr
 807              		.loc 1 356 0
 808              		bic	r0, r0, #128
 809              		.loc 1 357 0
 810              		ldr	lr, [sp], #4
 811              		.loc 1 356 0
 346:io_driver.c   **** 	asm volatile (" msr cpsr, %0" : /* no outputs */ : "r" (_cmsr)  );
 812              	_cmsr
 813 0484 E129F000 	.LFE23:
 347:io_driver.c   **** }
 814              	size	io_enable_irq, .-io_enable_irq
 815 0488 E1A0F00E 		.align	2
 816              		.global	io_disable_irq
 818              	io_disable_irq:
 819              	.LFB24:
 820              		.loc 1 363 0
 821              		@ args = 0, pretend = 0, frame = 0
 822              		@ frame_needed = 0, uses_anonymous_args = 0
 348:io_driver.c   **** 
 349:io_driver.c   **** // ******************************************************************************
 350:io_driver.c   **** // Enable global IRQ
 351:io_driver.c   ****    void io_enable_irq(void)
 352:io_driver.c   **** // ******************************************************************************
 353:io_driver.c   **** {
 823              	[sp, #-4]!
 824              	.LCFI3:
 825              		.loc 1 364 0
 826 048c E52DE004 		bl	get_cmsr
 827              		.loc 1 366 0
 354:io_driver.c   **** 	unsigned long _cmsr = get_cmsr();
 828              	r0, r0, #128
 829 0490 EBFFFFFE 		.loc 1 367 0
 355:io_driver.c   **** 	_cmsr = _cmsr & ~(1<<CMSR_IRQ);
 356:io_driver.c   **** 	set_cmsr(_cmsr);
 830              	dr	lr, [sp], #4
 831 0494 E3C00080 		.loc 1 366 0
 357:io_driver.c   **** }
 832              		set_cmsr
 833 0498 E49DE004 	.LFE24:
 835 049c EAFFFFFE 		.align	2
 836              		.global	uart0_printf
 838              	uart0_printf:
 839              	.LFB25:
 840              		.file 2 "uart.c"
 841              		.loc 2 7 0
 842              		@ args = 0, pretend = 0, frame = 0
 358:io_driver.c   **** 
 359:io_driver.c   **** // ******************************************************************************
 360:io_driver.c   **** // Disable global IRQ
 361:io_driver.c   ****    void io_disable_irq(void)
 362:io_driver.c   **** // ******************************************************************************
 363:io_driver.c   **** {
 843              	eded = 0, uses_anonymous_args = 0
 844              	.LVL66:
 845              		stmfd	sp!, {r4, lr}
 846 04a0 E52DE004 	.LCFI4:
 847              		.loc 2 7 0
 364:io_driver.c   **** 	unsigned long _cmsr = get_cmsr();
 848              	r4, r0
 849 04a4 EBFFFFFE 		.loc 2 10 0
 365:io_driver.c   **** 	_cmsr = _cmsr | (1<<CMSR_IRQ);
 366:io_driver.c   **** 	set_cmsr(_cmsr);
 850              	drb	r0, [r0, #0]	@ zero_extendqisi2
 851 04a8 E3800080 	.LVL67:
 367:io_driver.c   **** }
 852              	mp	r0, #0
 853 04ac E49DE004 		bne	.L145
 854              		b	.L141
 855 04b0 EAFFFFFE 	.LVL68:
 856              	.L147:
 857              		ldrb	r0, [r4, #1]!	@ zero_extendqisi2
 858              	.LVL69:
 859              		cmp	r0, #0
 860              		beq	.L141
 861              	.L145:
 862              		.loc 2 11 0
 863              		bl	io_uart0_send_byte
   1:uart.c        **** #include "uart.h"
   2:uart.c        **** 
   3:uart.c        **** // ############################################################################################
   4:uart.c        **** // Print text string via UART 0
   5:uart.c        ****    const char *uart0_printf(const char *string)
   6:uart.c        **** // ############################################################################################
   7:uart.c        **** {
 864              		r0, #0
 865              		bgt	.L147
 866              	.LVL71:
 867              	.L141:
 868 04b4 E92D4010 		.loc 2 16 0
 869              		mov	r0, r4
 870              	.LVL72:
 871 04b8 E1A04000 		ldmfd	sp!, {r4, pc}
   8:uart.c        **** 	char ch;
   9:uart.c        **** 
  10:uart.c        **** 	while ((ch = *string)){
 873 04bc E5D00000 		.align	2
 874              		.global	uart0_scanf
 876 04c4 1A000003 	uart0_scanf:
 877 04c8 EA000005 	.LFB26:
 878              		.loc 2 22 0
 879              		@ args = 0, pretend = 0, frame = 0
 880 04cc E5F40001 		@ frame_needed = 0, uses_anonymous_args = 0
 881              	.LVL73:
 882 04d0 E3500000 		stmfd	sp!, {r4, r5, r6, lr}
 883 04d4 0A000002 	.LCFI5:
 884              		.loc 2 25 0
  11:uart.c        **** 		if (io_uart0_send_byte(ch)<=0)
 885              	 #0
 886 04d8 EBFFFFFE 		.loc 2 22 0
 887              		mov	r5, r0
 888 04dc E3500000 		and	r6, r2, #255
 889 04e0 CAFFFFF9 		.loc 2 25 0
 890              		ldmlefd	sp!, {r4, r5, r6, pc}
 891              	.LVL74:
  12:uart.c        **** 			break;
  13:uart.c        **** 		string++;
  14:uart.c        **** 	}
  15:uart.c        **** 	return string;
  16:uart.c        **** }
 892              		.loc 2 26 0
 893 04e4 E1A00004 		bl	io_uart0_read_byte
 894              	.LVL75:
 895 04e8 E8BD8010 	.LVL76:
 896              		.loc 2 27 0
 897              		cmn	r0, #1
 898              		.loc 2 28 0
 899              		and	r3, r0, #255
 900              	.LVL77:
 901              		.loc 2 27 0
 902              		beq	.L151
  17:uart.c        **** 
  18:uart.c        **** // ############################################################################################
  19:uart.c        **** // Read text string via UART 0
  20:uart.c        ****    void uart0_scanf(unsigned char *buffer, int length, unsigned char en_echo)
  21:uart.c        **** // ############################################################################################
  22:uart.c        **** {
 903              	0
 904              		cmp	r6, #1
 905              	.LVL78:
 906              		.loc 2 29 0
 907 04ec E92D4070 		strb	r3, [r5, #0]
 908              	.LVL79:
  23:uart.c        **** 	int temp = 0;
  24:uart.c        **** 
  25:uart.c        **** 	while(length > 0){
 909              	2 31 0
 910 04f0 E2514000 		mov	r0, r3
 911              	.LVL80:
 912 04f4 E1A05000 		.loc 2 29 0
 913 04f8 E20260FF 		add	r5, r5, #1
 914              		.loc 2 30 0
 915 04fc D8BD8070 		beq	.L158
 916              	.LVL81:
 917              	.L153:
  26:uart.c        **** 		temp = io_uart0_read_byte();
 918              	2 0
 919 0500 EBFFFFFE 		sub	r4, r4, #1
 920              	.LVL82:
 921              	.L151:
  27:uart.c        **** 		if(temp != -1){
 922              	c 2 25 0
 923 0504 E3700001 		cmp	r4, #0
  28:uart.c        **** 			temp = (unsigned char)(temp & 0x000000FF);
 924              	gt	.L156
 925 0508 E20030FF 		ldmfd	sp!, {r4, r5, r6, pc}
 926              	.LVL83:
 927              	.L158:
 928 050c 0A000005 		.loc 2 31 0
  29:uart.c        **** 			*buffer++ = temp;
  30:uart.c        **** 			if(en_echo == 1)
 929              	o_uart0_send_byte
 930 0510 E3560001 	.LVL84:
 931              		b	.L153
 932              	.LFE26:
 934              		.align	2
  31:uart.c        **** 				io_uart0_send_byte(temp); // echo
 935              	al	uart0_print_buffer
 937              	uart0_print_buffer:
 938              	.LFB27:
 939 051c E2855001 		.loc 2 41 0
 940              		@ args = 0, pretend = 0, frame = 0
 941 0520 0A000003 		@ frame_needed = 0, uses_anonymous_args = 0
 942              	.LVL85:
 943              		stmfd	sp!, {r4, r5, lr}
  32:uart.c        **** 			length--;
 944              	.loc 2 43 0
 945 0524 E2444001 		subs	r4, r1, #0
 946              		.loc 2 41 0
 947              		mov	r5, r0
 948              		.loc 2 43 0
 949 0528 E3540000 		ldmlefd	sp!, {r4, r5, pc}
 950 052c CAFFFFF3 	.LVL86:
 951 0530 E8BD8070 	.L163:
 952              		.loc 2 45 0
 953              		ldrb	r0, [r5], #1	@ zero_extendqisi2
 954              	.LVL87:
 955 0534 EBFFFFFE 		bl	io_uart0_send_byte
 956              	.LVL88:
 957 0538 EAFFFFF9 		.loc 2 43 0
 958              		subs	r4, r4, #1
 959              		bne	.L163
 960              		ldmfd	sp!, {r4, r5, pc}
 961              	.LFE27:
 963              		.align	2
 964              		.global	long_to_hex_string
  33:uart.c        **** 		}
  34:uart.c        **** 	}
  35:uart.c        **** }
  36:uart.c        **** 
  37:uart.c        **** // ############################################################################################
  38:uart.c        **** // Print character buffer via UART 0
  39:uart.c        ****    void uart0_print_buffer(unsigned char *buffer, int size)
  40:uart.c        **** // ############################################################################################
  41:uart.c        **** {
 965              	ring, %function
 966              	long_to_hex_string:
 967              	.LFB28:
 968              		.file 3 "utilities.c"
 969 053c E92D4030 		.loc 3 9 0
 970              		@ args = 0, pretend = 0, frame = 0
  42:uart.c        **** 	unsigned char char_buffer = 0;
  43:uart.c        **** 	while(size > 0){
 971              	me_needed = 0, uses_anonymous_args = 0
 972 0540 E2514000 	.LVL89:
 973              		stmfd	sp!, {r4, lr}
 974 0544 E1A05000 	.LCFI7:
 975              		.loc 3 9 0
 976 0548 D8BD8030 		and	r4, r2, #255
 977              		.loc 3 14 0
 978              		cmp	r4, #8
  44:uart.c        **** 		char_buffer = *buffer++;
  45:uart.c        **** 		io_uart0_send_byte(char_buffer);
 979              	4, #8
 980 054c E4D50001 		bhi	.L168
 981              	.LVL90:
 982 0550 EBFFFFFE 		.loc 3 16 0
 983              		cmp	r4, #0
 984              		.loc 3 39 0
 985 0554 E2544001 		moveq	r4, #1
 986 0558 1AFFFFFB 	.L168:
 987 055c E8BD8030 		mov	r2, r1
 988              	.LVL91:
 989              		mov	lr, r4
 990              	.LVL92:
 991              	.L170:
 992              		.loc 3 22 0
 993              		mov	r3, lr, asl #2
 994              		.loc 3 21 0
 995              		cmp	lr, #1
   1:utilities.c   **** #include "utilities.h"
   2:utilities.c   **** 
   3:utilities.c   **** // ############################################################################################
   4:utilities.c   **** // Convert 4/8/12/16/20/24/28/32 bit hexadecimal value to ASCII string
   5:utilities.c   ****    void long_to_hex_string(unsigned long data,    // max 32 bit data word
   6:utilities.c   ****                            unsigned char *buffer, // buffer to store the string
   7:utilities.c   **** 						   unsigned char numbers) // number of places, max 8
   8:utilities.c   **** // ############################################################################################
   9:utilities.c   **** {
 996              		r3, r3, #4
 997              		.loc 3 21 0
 998              		mov	ip, r0
 999              	.LVL93:
 1000 0560 E92D4010 		.loc 3 22 0
 1001              		movhi	ip, r0, lsr r3
 1002              		.loc 3 26 0
 1003 0564 E20240FF 		sub	r3, lr, #1
  10:utilities.c   **** 	unsigned char temp_char = 0;
  11:utilities.c   **** 	unsigned long temp_data = 0;
  12:utilities.c   **** 
  13:utilities.c   **** 	// fit into range
  14:utilities.c   **** 	if(numbers > 8)
 1004              	25 0
 1005 0568 E3540008 		and	ip, ip, #15
 1006 056c 83A04008 	.LVL94:
 1007 0570 8A000001 		.loc 3 26 0
 1008              		and	lr, r3, #255
  15:utilities.c   **** 		numbers = 8;
  16:utilities.c   **** 	if(numbers < 1)
 1009              	 3 29 0
 1010 0574 E3540000 		cmp	ip, #9
  17:utilities.c   **** 		numbers = 1;
  18:utilities.c   **** 
  19:utilities.c   **** 	while(numbers > 0){
  20:utilities.c   **** 		// isolate one 4-bit value
  21:utilities.c   **** 		if(numbers > 1)
  22:utilities.c   **** 			temp_data = data >> ((numbers-1)*4);
  23:utilities.c   **** 		else
  24:utilities.c   **** 			temp_data = data;
  25:utilities.c   **** 		temp_data = temp_data & 0x0000000F;
  26:utilities.c   **** 		numbers--;
  27:utilities.c   **** 
  28:utilities.c   **** 		// convert 4-bit value temp_data to char temp_char
  29:utilities.c   **** 		if(temp_data < 10)
  30:utilities.c   **** 			temp_char = '0' + temp_data;
  31:utilities.c   **** 		else
  32:utilities.c   **** 			temp_char = 'A' + temp_data - 10;
  33:utilities.c   **** 
  34:utilities.c   **** 		// save character
  35:utilities.c   **** 		*buffer++ = temp_char;
  36:utilities.c   **** 	}
  37:utilities.c   **** 
  38:utilities.c   **** 	*buffer++ = 0; // terminate string
  39:utilities.c   **** }
 1011              	loc 3 30 0
 1012 0578 03A04001 		add	r3, ip, #48
 1013              	.LVL95:
 1014 057c E1A02001 		.loc 3 32 0
 1015              		addhi	r3, ip, #55
 1016 0580 E1A0E004 		.loc 3 19 0
 1017              		cmp	lr, #0
 1018              		.loc 3 35 0
 1019              		strb	r3, [r2], #1
 1020 0584 E1A0310E 		.loc 3 19 0
 1021              		bne	.L170
 1022 0588 E35E0001 		.loc 3 38 0
 1023              		sub	r3, r4, #1
 1024 058c E2433004 	.LVL96:
 1025              		and	r3, r3, #255
 1026 0590 E1A0C000 		add	r3, r1, r3
 1027              		strb	lr, [r3, #1]
 1028              		.loc 3 39 0
 1029 0594 81A0C330 		ldmfd	sp!, {r4, pc}
 1030              	.LFE28:
 1032              		.align	2
 1033 059c E20CC00F 		.global	hex_string_to_long
 1035              	hex_string_to_long:
 1036 05a0 E203E0FF 	.LFB29:
 1037              		.loc 3 47 0
 1038 05a4 E35C0009 		@ args = 0, pretend = 0, frame = 0
 1039              		@ frame_needed = 0, uses_anonymous_args = 0
 1040 05a8 E28C3030 	.LVL97:
 1041              		and	r1, r1, #255
 1042              		.loc 3 52 0
 1043 05ac 828C3037 		cmp	r1, #8
 1044              		.loc 3 47 0
 1045 05b0 E35E0000 		stmfd	sp!, {r4, lr}
 1046              	.LCFI8:
 1047 05b4 E4C23001 		.loc 3 47 0
 1048              		mov	r4, r0
 1049 05b8 1AFFFFF1 		.loc 3 52 0
 1050              		bhi	.L182
 1051 05bc E2443001 	.LVL98:
 1052              		.loc 3 54 0
 1053 05c0 E20330FF 		cmp	r1, #0
 1054 05c4 E0813003 		beq	.L182
 1055 05c8 E5C3E001 		mov	r0, #0
 1056              	.LVL99:
 1057 05cc E8BD8010 		b	.L185
 1058              	.LVL100:
 1059              	.L186:
 1060              		.loc 3 58 0
 1061              		sub	r3, r1, #1
 1062              	.LVL101:
 1063              		and	r1, r3, #255
 1064              		.loc 3 70 0
  40:utilities.c   **** 
  41:utilities.c   **** 
  42:utilities.c   **** // ############################################################################################
  43:utilities.c   **** // Convert 1/2/3/4/5/6/7/8 hex-chars to 32 bit value
  44:utilities.c   ****    unsigned long hex_string_to_long(unsigned char *buffer, // string char buffer
  45:utilities.c   **** 						            unsigned char numbers) // number of places, max 8
  46:utilities.c   **** // ############################################################################################
  47:utilities.c   **** {
 1065              	57 0
 1066              		cmp	r1, #0
 1067              		.loc 3 70 0
 1068              		orr	r0, r0, r2, asl r3
 1069 05d0 E20110FF 		.loc 3 57 0
  48:utilities.c   **** 	unsigned long temp_char = 0;
  49:utilities.c   **** 	unsigned long temp_data = 0;
  50:utilities.c   **** 
  51:utilities.c   **** 	// fit into range
  52:utilities.c   **** 	if(numbers > 8)
 1070              	qfd	sp!, {r4, pc}
 1071 05d4 E3510008 	.L185:
 1072              		.loc 3 60 0
 1073 05d8 E92D4010 		ldrb	r3, [r4], #1	@ zero_extendqisi2
 1074              	.LVL103:
 1075              		.loc 3 61 0
 1076 05dc E1A04000 		sub	r2, r3, #48
 1077              	.LVL104:
 1078 05e0 8A000016 		cmp	r2, #9
 1079              		.loc 3 63 0
  53:utilities.c   **** 		return 0;
  54:utilities.c   **** 	if(numbers < 1)
 1080              	3, #65
 1081 05e4 E3510000 		.loc 3 61 0
 1082 05e8 0A000014 		bls	.L186
 1083 05ec E3A00000 		.loc 3 63 0
 1084              		cmp	ip, #5
 1085 05f0 EA000006 		.loc 3 65 0
 1086              		sub	lr, r3, #97
 1087              		.loc 3 64 0
  55:utilities.c   **** 		return 0;
  56:utilities.c   **** 
  57:utilities.c   **** 	while(numbers > 0){
  58:utilities.c   **** 		numbers--;
 1088              	 r3, #55
 1089 05f4 E2413001 		.loc 3 63 0
 1090              		bls	.L186
 1091 05f8 E20310FF 		.loc 3 65 0
  59:utilities.c   **** 
  60:utilities.c   **** 		temp_char = (unsigned long)(*buffer++); // isolate one char
  61:utilities.c   **** 		if((temp_char > '0'-1) && (temp_char < '9'+1))
  62:utilities.c   **** 			temp_char = temp_char - '0';
  63:utilities.c   **** 		else if((temp_char > 'A'-1) && (temp_char < 'F'+1))
  64:utilities.c   **** 			temp_char = temp_char - 'A' + 10;
  65:utilities.c   **** 		else if((temp_char > 'a'-1) && (temp_char < 'f'+1))
  66:utilities.c   **** 			temp_char = temp_char - 'a' + 10;
  67:utilities.c   **** 		else
  68:utilities.c   **** 			return 0;
  69:utilities.c   **** 		temp_char = temp_char & 0x0F;
  70:utilities.c   **** 		temp_data = temp_data | (temp_char << 4*numbers);
 1092              		lr, #5
 1093 05fc E202200F 		.loc 3 66 0
 1094              		sub	r2, r3, #87
 1095 0600 E1A03101 		.loc 3 65 0
 1096              		bls	.L186
 1097 0604 E3510000 	.LVL105:
 1098              	.L182:
 1099 0608 E1800312 		.loc 3 57 0
 1100              		mov	r0, #0
 1101 060c 08BD8010 	.LVL106:
 1102              		.loc 3 74 0
 1103              		ldmfd	sp!, {r4, pc}
 1104 0610 E4D43001 	.LFE29:
 1106              		.align	2
 1107 0614 E2432030 		.global	qbytes_to_long
 1109 0618 E3520009 	qbytes_to_long:
 1110              	.LFB30:
 1111 061c E243C041 		.loc 3 81 0
 1112              		@ args = 0, pretend = 0, frame = 0
 1113 0620 9AFFFFF3 		@ frame_needed = 0, uses_anonymous_args = 0
 1114              		@ link register save eliminated.
 1115 0624 E35C0005 	.LVL107:
 1116              		mov	r3, r0
 1117 0628 E243E061 		.loc 3 84 0
 1118              		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 1119 062c E2432037 	.LVL108:
 1120              		.loc 3 83 0
 1121 0630 9AFFFFEF 		add	ip, r3, #1
 1122              	.LVL109:
 1123 0634 E35E0005 		.loc 3 84 0
 1124              		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 1125 0638 E2432057 		.loc 3 85 0
 1126              		ldrb	r1, [ip, #2]	@ zero_extendqisi2
 1127 063c 9AFFFFEC 		.loc 3 84 0
 1128              		mov	r0, r0, asl #16
 1129              		orr	r0, r0, r2, asl #24
 1130              	.LVL110:
 1131 0640 E3A00000 		.loc 3 85 0
 1132              		ldrb	r3, [ip, #1]	@ zero_extendqisi2
  71:utilities.c   **** 	}
  72:utilities.c   **** 
  73:utilities.c   **** 	return temp_data;
  74:utilities.c   **** }
 1133              	 88 0
 1134 0644 E8BD8010 		orr	r0, r0, r3, asl #8
 1135              	.LVL113:
 1136              		.loc 3 81 0
 1137              		@ lr needed for prologue
 1138              		.loc 3 88 0
 1139              		mov	pc, lr
 1140              	.LFE30:
  75:utilities.c   **** 
  76:utilities.c   **** 
  77:utilities.c   **** // ############################################################################################
  78:utilities.c   **** // Concate 4 bytes (chars) to single 32 bit value
  79:utilities.c   ****    unsigned long qbytes_to_long(unsigned char *buffer)
  80:utilities.c   **** // ############################################################################################
  81:utilities.c   **** {
 1142              	
 1143              		.global	delay
 1145              	delay:
 1146              	.LFB31:
 1147 0648 E1A03000 		.loc 3 95 0
  82:utilities.c   **** 	unsigned long temp = 0;
  83:utilities.c   **** 	temp = temp | (0xFF000000 & (*buffer++ << 24));
  84:utilities.c   **** 	temp = temp | (0x00FF0000 & (*buffer++ << 16));
 1148              	gs = 0, pretend = 0, frame = 0
 1149 064c E5D00001 		@ frame_needed = 0, uses_anonymous_args = 0
 1150              		@ link register save eliminated.
 1151              	.LVL114:
 1152 0650 E283C001 		.loc 3 96 0
 1153              		rsb	r3, r0, r0, asl #5
 1154              		add	r0, r0, r3, asl #2
 1155 0654 E5D32000 	.LVL115:
  85:utilities.c   **** 	temp = temp | (0x0000FF00 & (*buffer++ <<  8));
 1156              	 r0, r0, asl #2
 1157 0658 E5DC1002 		mov	r0, r0, asl #4
 1158              	.LVL116:
 1159 065c E1A00800 		.loc 3 97 0
 1160 0660 E1800C02 		cmp	r0, #0
 1161              		.loc 3 95 0
 1162              		@ lr needed for prologue
 1163 0664 E5DC3001 		.loc 3 97 0
 1164              		movle	pc, lr
 1165 0668 E1800001 	.L200:
 1166              		.loc 3 98 0
  86:utilities.c   **** 	temp = temp | (0x000000FF & (*buffer++ <<  0));
  87:utilities.c   **** 	return temp;
  88:utilities.c   **** }
 1167              	3 97 0
 1168 066c E1800403 		subs	r0, r0, #1
 1169              		bne	.L200
 1170              		mov	pc, lr
 1171              	.LFE31:
 1173 0670 E1A0F00E 		.section	.rodata.str1.4,"aMS",%progbits,1
 1174              		.align	2
 1175              	.LC0:
 1176              		.ascii	"\015\012\015\012\015\012+--------------------------"
 1177              		.ascii	"--------------------------------------+\015\012\000"
 1178              		.align	2
 1179              	.LC1:
 1180              		.ascii	"|    <<< STORM Core Processor System - By Stephan N"
  89:utilities.c   **** 
  90:utilities.c   **** 
  91:utilities.c   **** // ############################################################################################
  92:utilities.c   **** // simple delay routine
  93:utilities.c   ****    void delay(int time) // waits time*10000 clock ticks
  94:utilities.c   **** // ############################################################################################
  95:utilities.c   **** {
 1181              	g >>>    |\015\012\000"
 1182              		.align	2
 1183              	.LC2:
 1184              		.ascii	"+--------------------------------------------------"
 1185              		.ascii	"--------------+\015\012\000"
  96:utilities.c   **** 	time = time*2500*4;
 1186              	gn	2
 1187 0674 E0603280 	.LC3:
 1188 0678 E0800103 		.ascii	"|         Bootloader for STORM SoC   Version: 20120"
 1189              		.ascii	"524-D         |\015\012\000"
 1190 067c E0800100 		.align	2
 1191 0680 E1A00200 	.LC4:
 1192              		.ascii	"|               Contact: stnolting@googlemail.com  "
  97:utilities.c   **** 	while(time > 0){
 1193              		"              |\015\012\000"
 1194 0684 E3500000 		.align	2
 1195              	.LC5:
 1196              		.ascii	"+--------------------------------------------------"
 1197              		.ascii	"--------------+\015\012\015\012\000"
 1198 0688 D1A0F00E 		.align	2
 1199              	.LC6:
  98:utilities.c   **** 		asm volatile ("NOP");
 1200              		" < Welcome to the STORM SoC bootloader console! >\015"
 1201 068c E1A00000 		.ascii	"\012 < Select an operation from the menu below or p"
 1202              		.ascii	"ress >\015\012\000"
 1203 0690 E2500001 		.align	2
 1204 0694 1AFFFFFC 	.LC7:
 1205 0698 E1A0F00E 		.ascii	" < the boot key for immediate application start. >\015"
 1206              		.ascii	"\012\015\012\000"
 1207              		.align	2
 1208              	.LC8:
 1209              		.ascii	" 0 - boot from core RAM (start application)\015\012"
 1210              		.ascii	" 1 - program core RAM via UART_0\015\012 2 - core R"
 1211 0000 0D0A0D0A 		.ascii	"AM dump\015\012\000"
 1211      0D0A2B2D 
 1211      2D2D2D2D 
 1211      2D2D2D2D 
 1211      2D2D2D2D 
 1212 0021 2D2D2D2D 		.align	2
 1212      2D2D2D2D 
 1212      2D2D2D2D 
 1212      2D2D2D2D 
 1212      2D2D2D2D 
 1213 004b 00       	.LC9:
 1214              		.ascii	" 3 - boot from I2C EEPROM\015\012 4 - program I2C E"
 1215 004c 7C202020 		.ascii	"EPROM via UART_0\015\012 5 - show content of I2C EE"
 1215      203C3C3C 
 1215      2053544F 
 1215      524D2043 
 1215      6F726520 
 1216 007f 6F6C7469 		.ascii	"PROM\015\012\000"
 1216      6E67203E 
 1216      3E3E2020 
 1216      20207C0D 
 1216      0A00
 1217 0091 000000   		.align	2
 1218              	.LC10:
 1219 0094 2B2D2D2D 		.ascii	" a - automatic boot configuration\015\012 h - help\015"
 1219      2D2D2D2D 
 1219      2D2D2D2D 
 1219      2D2D2D2D 
 1219      2D2D2D2D 
 1220 00c7 2D2D2D2D 		.ascii	"\012 r - restart system\015\012\015\012Select: \000"
 1220      2D2D2D2D 
 1220      2D2D2D2D 
 1220      2D2D2B0D 
 1220      0A00
 1221 00d9 000000   		.align	2
 1222              	.LC11:
 1223 00dc 7C202020 		.ascii	"\015\012\015\012Application will start automaticall"
 1223      20202020 
 1223      2020426F 
 1223      6F746C6F 
 1223      61646572 
 1224 010f 3532342D 		.ascii	"y after download.\015\012-> Waiting for 'storm_prog"
 1224      44202020 
 1224      20202020 
 1224      20207C0D 
 1224      0A00
 1225 0121 000000   		.ascii	"ram.bin' in byte-stream mode...\000"
 1226              		.align	2
 1227 0124 7C202020 	.LC12:
 1227      20202020 
 1227      20202020 
 1227      20202020 
 1227      436F6E74 
 1228 0157 20202020 		.ascii	" ERROR! Program file too big!\015\012\015\012\000"
 1228      20202020 
 1228      20202020 
 1228      20207C0D 
 1228      0A00
 1229 0169 000000   		.align	2
 1230              	.LC13:
 1231 016c 2B2D2D2D 		.ascii	" Invalid programming file!\015\012\015\012Select: \000"
 1231      2D2D2D2D 
 1231      2D2D2D2D 
 1231      2D2D2D2D 
 1231      2D2D2D2D 
 1232 019f 2D2D2D2D 		.align	2
 1232      2D2D2D2D 
 1232      2D2D2D2D 
 1232      2D2D2B0D 
 1232      0A0D0A00 
 1233 01b3 00       	.LC14:
 1234              		.ascii	"\015\012\015\012Abort dumping by pressing any key.\015"
 1235 01b4 203C2057 		.ascii	"\012Press any key to continue.\015\012\015\012\000"
 1235      656C636F 
 1235      6D652074 
 1235      6F207468 
 1235      65205354 
 1236 01e6 0A203C20 		.align	2
 1236      53656C65 
 1236      63742061 
 1236      6E206F70 
 1236      65726174 
 1237 0216 72657373 	.LC15:
 1237      203E0D0A 
 1237      00
 1238 021f 00       		.ascii	"\015\012\015\012Dumping completed.\015\012\015\012S"
 1239              		.ascii	"elect: \000"
 1240 0220 203C2074 		.align	2
 1240      68652062 
 1240      6F6F7420 
 1240      6B657920 
 1240      666F7220 
 1241 0253 0A0D0A00 	.LC16:
 1242 0257 00       		.ascii	"\015\012\015\012Enter device address (2x hex_chars,"
 1243              		.ascii	" set LSB to '0'): \000"
 1244 0258 2030202D 		.align	2
 1244      20626F6F 
 1244      74206672 
 1244      6F6D2063 
 1244      6F726520 
 1245 0285 2031202D 	.LC17:
 1245      2070726F 
 1245      6772616D 
 1245      20636F72 
 1245      65205241 
 1246 02b2 414D2064 		.ascii	" Invalid address!\015\012\015\012Select: \000"
 1246      756D700D 
 1246      0A00
 1247              		.align	2
 1248              	.LC18:
 1249 02bc 2033202D 		.ascii	"\015\012Application will start automatically after "
 1249      20626F6F 
 1249      74206672 
 1249      6F6D2049 
 1249      32432045 
 1250 02e9 4550524F 		.ascii	"upload.\015\012-> Loading boot image...\000"
 1250      4D207669 
 1250      61205541 
 1250      52545F30 
 1250      0D0A2035 
 1251 0316 50524F4D 		.align	2
 1251      0D0A00
 1252 031d 000000   	.LC19:
 1253              		.ascii	" Upload complete\015\012\000"
 1254 0320 2061202D 		.align	2
 1254      20617574 
 1254      6F6D6174 
 1254      69632062 
 1254      6F6F7420 
 1255 034d 0A207220 	.LC20:
 1255      2D207265 
 1255      73746172 
 1255      74207379 
 1255      7374656D 
 1256 036e 0000     		.ascii	" Invalid boot device or file!\015\012\015\012Select"
 1257              		.ascii	": \000"
 1258 0370 0D0A0D0A 		.align	2
 1258      4170706C 
 1258      69636174 
 1258      696F6E20 
 1258      77696C6C 
 1259 0397 79206166 	.LC21:
 1259      74657220 
 1259      646F776E 
 1259      6C6F6164 
 1259      2E0D0A2D 
 1260 03c4 72616D2E 		.ascii	"\015\012Invalid address!\015\012\015\012Select: \000"
 1260      62696E27 
 1260      20696E20 
 1260      62797465 
 1260      2D737472 
 1261              		.align	2
 1262              	.LC22:
 1263 03e4 20455252 		.ascii	"\015\012Data will overwrite RAM content!\015\012-> "
 1263      4F522120 
 1263      50726F67 
 1263      72616D20 
 1263      66696C65 
 1264 0406 0000     		.ascii	"Waiting for 'storm_program.bin' in byte-stream mode"
 1265              		.ascii	"...\000"
 1266 0408 20496E76 		.align	2
 1266      616C6964 
 1266      2070726F 
 1266      6772616D 
 1266      6D696E67 
 1267 042f 00       	.LC23:
 1268              		.ascii	" Download completed\015\012\000"
 1269 0430 0D0A0D0A 		.align	2
 1269      41626F72 
 1269      74206475 
 1269      6D70696E 
 1269      67206279 
 1270 0457 0A507265 	.LC24:
 1270      73732061 
 1270      6E79206B 
 1270      65792074 
 1270      6F20636F 
 1271 0477 00       		.ascii	"Writing buffer to i2c EEPROM...\000"
 1272              		.align	2
 1273 0478 0D0A0D0A 	.LC25:
 1273      44756D70 
 1273      696E6720 
 1273      636F6D70 
 1273      6C657465 
 1274 0493 656C6563 		.ascii	" Completed\015\012\015\012\000"
 1274      743A2000 
 1275 049b 00       		.align	2
 1276              	.LC26:
 1277 049c 0D0A0D0A 		.ascii	" Invalid boot device or file!\015\012\015\012\000"
 1277      456E7465 
 1277      72206465 
 1277      76696365 
 1277      20616464 
 1278 04c3 20736574 		.align	2
 1278      204C5342 
 1278      20746F20 
 1278      27302729 
 1278      3A2000
 1279 04d6 0000     	.LC27:
 1280              		.ascii	"Select: \000"
 1281 04d8 20496E76 		.align	2
 1281      616C6964 
 1281      20616464 
 1281      72657373 
 1281      210D0A0D 
 1282 04f6 0000     	.LC28:
 1283              		.ascii	"\015\012\015\012Enter device address (2 hex-chars, "
 1284 04f8 0D0A4170 		.ascii	"set LSB to '0'): \000"
 1284      706C6963 
 1284      6174696F 
 1284      6E207769 
 1284      6C6C2073 
 1285 0525 75706C6F 		.align	2
 1285      61642E0D 
 1285      0A2D3E20 
 1285      4C6F6164 
 1285      696E6720 
 1286 0547 00       	.LC29:
 1287              		.ascii	"\015\012\015\012Abort dumping by pressing any key. "
 1288 0548 2055706C 		.ascii	"If no data is shown,\015\012\000"
 1288      6F616420 
 1288      636F6D70 
 1288      6C657465 
 1288      0D0A00
 1289 055b 00       		.align	2
 1290              	.LC30:
 1291 055c 20496E76 		.ascii	"the selected device is not responding. Press any ke"
 1291      616C6964 
 1291      20626F6F 
 1291      74206465 
 1291      76696365 
 1292 0583 3A2000   		.ascii	"y to continue.\015\012\015\012\000"
 1293 0586 0000     		.align	2
 1294              	.LC31:
 1295 0588 0D0A496E 		.ascii	"\015\012\015\012Automatic boot configuration for po"
 1295      76616C69 
 1295      64206164 
 1295      64726573 
 1295      73210D0A 
 1296 05a7 00       		.ascii	"wer-up:\015\012\000"
 1297              		.align	2
 1298 05a8 0D0A4461 	.LC32:
 1298      74612077 
 1298      696C6C20 
 1298      6F766572 
 1298      77726974 
 1299 05cf 57616974 		.ascii	"[3210] configuration DIP switch\015\012 0000 - Star"
 1299      696E6720 
 1299      666F7220 
 1299      2773746F 
 1299      726D5F70 
 1300 0602 2E2E2E00 		.ascii	"t bootloader console\015\012 0001 - Automatic boot "
 1301 0606 0000     		.ascii	"from core RAM\015\012\000"
 1302              		.align	2
 1303 0608 20446F77 	.LC33:
 1303      6E6C6F61 
 1303      6420636F 
 1303      6D706C65 
 1303      7465640D 
 1304 061e 0000     		.ascii	" 0010 - Automatic boot from I2C EEPROM (Address 0xA"
 1305              		.ascii	"0)\015\012\015\012Select: \000"
 1306 0620 57726974 		.align	2
 1306      696E6720 
 1306      62756666 
 1306      65722074 
 1306      6F206932 
 1307              	.LC34:
 1308              		.ascii	"\015\012\015\012STORM SoC bootloader\015\012\000"
 1309 0640 20436F6D 		.align	2
 1309      706C6574 
 1309      65640D0A 
 1309      0D0A00
 1310 064f 00       	.LC35:
 1311              		.ascii	"'0': Execute program in RAM.\015\012\000"
 1312 0650 20496E76 		.align	2
 1312      616C6964 
 1312      20626F6F 
 1312      74206465 
 1312      76696365 
 1313 0672 0000     	.LC36:
 1314              		.ascii	"'1': Write 'storm_program.bin' to the core's RAM vi"
 1315 0674 53656C65 		.ascii	"a UART.\015\012\000"
 1315      63743A20 
 1315      00
 1316 067d 000000   		.align	2
 1317              	.LC37:
 1318 0680 0D0A0D0A 		.ascii	"'2': Print current content of complete core RAM.\015"
 1318      456E7465 
 1318      72206465 
 1318      76696365 
 1318      20616464 
 1319 06a7 73657420 		.ascii	"\012\000"
 1319      4C534220 
 1319      746F2027 
 1319      3027293A 
 1319      2000
 1320 06b9 000000   		.align	2
 1321              	.LC38:
 1322 06bc 0D0A0D0A 		.ascii	"'3': Load boot image from EEPROM and start applicat"
 1322      41626F72 
 1322      74206475 
 1322      6D70696E 
 1322      67206279 
 1323 06e3 4966206E 		.ascii	"ion.\015\012\000"
 1323      6F206461 
 1323      74612069 
 1323      73207368 
 1323      6F776E2C 
 1324 06fa 0000     		.align	2
 1325              	.LC39:
 1326 06fc 74686520 		.ascii	"'4': Write 'storm_program.bin' to I2C EEPROM via UA"
 1326      73656C65 
 1326      63746564 
 1326      20646576 
 1326      69636520 
 1327 072f 7920746F 		.ascii	"RT.\015\012\000"
 1327      20636F6E 
 1327      74696E75 
 1327      652E0D0A 
 1327      0D0A00
 1328 0742 0000     		.align	2
 1329              	.LC40:
 1330 0744 0D0A0D0A 		.ascii	"'5': Print content of I2C EEPROM.\015\012\000"
 1330      4175746F 
 1330      6D617469 
 1330      6320626F 
 1330      6F742063 
 1331 076b 7765722D 		.align	2
 1331      75703A0D 
 1331      0A00
 1332 0775 000000   	.LC41:
 1333              		.ascii	"'a': Show DIP switch configurations for automatic b"
 1334 0778 5B333231 		.ascii	"oot.\015\012\000"
 1334      305D2063 
 1334      6F6E6669 
 1334      67757261 
 1334      74696F6E 
 1335 07a5 7420626F 		.align	2
 1335      6F746C6F 
 1335      61646572 
 1335      20636F6E 
 1335      736F6C65 
 1336 07d2 66726F6D 	.LC42:
 1336      20636F72 
 1336      65205241 
 1336      4D0D0A00 
 1337 07e2 0000     		.ascii	"'h': Show this screen.\015\012\000"
 1338              		.align	2
 1339 07e4 20303031 	.LC43:
 1339      30202D20 
 1339      4175746F 
 1339      6D617469 
 1339      6320626F 
 1340 0817 30290D0A 		.ascii	"'r': Reset system.\015\012\015\012\000"
 1340      0D0A5365 
 1340      6C656374 
 1340      3A2000
 1341 0826 0000     		.align	2
 1342              	.LC44:
 1343 0828 0D0A0D0A 		.ascii	"Boot EEPROM: 24xxnnn (like 24AA64), 7 bit address +"
 1343      53544F52 
 1343      4D20536F 
 1343      4320626F 
 1343      6F746C6F 
 1344 0843 00       		.ascii	" dont-care bit,\015\012\000"
 1345              		.align	2
 1346 0844 2730273A 	.LC45:
 1346      20457865 
 1346      63757465 
 1346      2070726F 
 1346      6772616D 
 1347 0863 00       		.ascii	"connected to I2C_CONTROLLER_0, operating frequency "
 1348              		.ascii	"is 100kHz,\015\012\000"
 1349 0864 2731273A 		.align	2
 1349      20577269 
 1349      74652027 
 1349      73746F72 
 1349      6D5F7072 
 1350 0897 61205541 	.LC46:
 1350      52542E0D 
 1350      0A00
 1351 08a1 000000   		.ascii	"maximum EEPROM size = 65536 byte => 16 bit addresse"
 1352              		.ascii	"s,\015\012\000"
 1353 08a4 2732273A 		.align	2
 1353      20507269 
 1353      6E742063 
 1353      75727265 
 1353      6E742063 
 1354 08d5 0A00     	.LC47:
 1355 08d7 00       		.ascii	"fixed boot device address: 0xA0\015\012\015\012\000"
 1356              		.align	2
 1357 08d8 2733273A 	.LC48:
 1357      204C6F61 
 1357      6420626F 
 1357      6F742069 
 1357      6D616765 
 1358 090b 696F6E2E 		.ascii	"Terminal setup: 9600 baud, 8 data bits, no parity, "
 1358      0D0A00
 1359 0912 0000     		.ascii	"1 stop bit\015\012\015\012\000"
 1360              		.align	2
 1361 0914 2734273A 	.LC49:
 1361      20577269 
 1361      74652027 
 1361      73746F72 
 1361      6D5F7072 
 1362 0947 52542E0D 		.ascii	"For more information see the STORM Core / STORM SoC"
 1362      0A00
 1363 094d 000000   		.ascii	" datasheet\015\012\000"
 1364              		.align	2
 1365 0950 2735273A 	.LC50:
 1365      20507269 
 1365      6E742063 
 1365      6F6E7465 
 1365      6E74206F 
 1366              		.ascii	"http://opencores.org/project,storm_core\015\012\000"
 1367              		.align	2
 1368 0974 2761273A 	.LC51:
 1368      2053686F 
 1368      77204449 
 1368      50207377 
 1368      69746368 
 1369 09a7 6F6F742E 		.ascii	"http://opencores.org/project,storm_soc\015\012\000"
 1369      0D0A00
 1370 09ae 0000     		.align	2
 1371              	.LC52:
 1372 09b0 2768273A 		.ascii	"Contact: stnolting@googlemail.com\015\012\000"
 1372      2053686F 
 1372      77207468 
 1372      69732073 
 1372      63726565 
 1373 09c9 000000   		.align	2
 1374              	.LC53:
 1375 09cc 2772273A 		.ascii	"(c) 2012 by Stephan Nolting\015\012\015\012Select: "
 1375      20526573 
 1375      65742073 
 1375      79737465 
 1375      6D2E0D0A 
 1376 09e3 00       		.ascii	"\000"
 1377              		.align	2
 1378 09e4 426F6F74 	.LC54:
 1378      20454550 
 1378      524F4D3A 
 1378      20323478 
 1378      786E6E6E 
 1379 0a17 20646F6E 		.ascii	"\015\012\015\012We'll send you back - to the future"
 1379      742D6361 
 1379      72652062 
 1379      69742C0D 
 1379      0A00
 1380 0a29 000000   		.ascii	"!.\015\012\015\012\000"
 1381              		.align	2
 1382 0a2c 636F6E6E 	.LC55:
 1382      65637465 
 1382      6420746F 
 1382      20493243 
 1382      5F434F4E 
 1383 0a5f 69732031 		.ascii	" - Doctor Emmet L. Brown\015\012\015\012Select: \000"
 1383      30306B48 
 1383      7A2C0D0A 
 1383      00
 1384              		.align	2
 1385              	.LC56:
 1386 0a6c 6D617869 		.ascii	" Invalid operation!\015\012Try again: \000"
 1386      6D756D20 
 1386      45455052 
 1386      4F4D2073 
 1386      697A6520 
 1387 0a9f 732C0D0A 		.align	2
 1387      00
 1388              	.LC57:
 1389              		.ascii	"\015\012\015\012-> Starting application...\015\012\015"
 1390 0aa4 66697865 		.ascii	"\012\000"
 1390      6420626F 
 1390      6F742064 
 1390      65766963 
 1390      65206164 
 1391              		.align	2
 1392              	.LC58:
 1393 0ac8 5465726D 		.ascii	"\015\012\015\012Aborted!\000"
 1393      696E616C 
 1393      20736574 
 1393      75703A20 
 1393      39363030 
 1394 0afb 31207374 		.text
 1394      6F702062 
 1394      69740D0A 
 1394      0D0A00
 1395 0b0a 0000     		.align	2
 1396              		.global	main
 1398 0b3f 20646174 	main:
 1398      61736865 
 1398      65740D0A 
 1398      00
 1399              	.LFB32:
 1400              		.file 4 "main.c"
 1401 0b4c 68747470 		.loc 4 12 0
 1401      3A2F2F6F 
 1401      70656E63 
 1401      6F726573 
 1401      2E6F7267 
 1402 0b76 0000     		@ args = 0, pretend = 0, frame = 8
 1403              		@ frame_needed = 0, uses_anonymous_args = 0
 1404 0b78 68747470 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 1404      3A2F2F6F 
 1404      70656E63 
 1404      6F726573 
 1404      2E6F7267 
 1405 0ba1 000000   	.LCFI9:
 1406              		.loc 4 18 0
 1407 0ba4 436F6E74 		mov	r0, #0
 1407      6163743A 
 1407      2073746E 
 1407      6F6C7469 
 1407      6E674067 
 1408              		.loc 4 12 0
 1409              		sub	sp, sp, #12
 1410 0bc8 28632920 	.LCFI10:
 1410      32303132 
 1410      20627920 
 1410      53746570 
 1410      68616E20 
 1411 0bef 00       		.loc 4 18 0
 1412              		bl	io_set_gpio0_port
 1413              		.loc 4 19 0
 1414 0bf0 0D0A0D0A 		mov	r1, #13
 1414      5765276C 
 1414      6C207365 
 1414      6E642079 
 1414      6F752062 
 1415 0c17 212E0D0A 		mov	r0, #195
 1415      0D0A00
 1416 0c1e 0000     		bl	set_syscpreg
 1417              		.loc 4 22 0
 1418 0c20 202D2044 		mov	r0, #99
 1418      6F63746F 
 1418      7220456D 
 1418      6D657420 
 1418      4C2E2042 
 1419 0c45 000000   		bl	io_i2c0_speed
 1420              		.loc 4 25 0
 1421 0c48 20496E76 		mov	r0, #6
 1421      616C6964 
 1421      206F7065 
 1421      72617469 
 1421      6F6E210D 
 1422 0c69 000000   		bl	get_syscpreg
 1423              		mov	r1, #6
 1424 0c6c 0D0A0D0A 		orr	r0, r0, #8
 1424      2D3E2053 
 1424      74617274 
 1424      696E6720 
 1424      6170706C 
 1425 0c8d 0A00     		bl	set_syscpreg
 1426 0c8f 00       		.loc 4 28 0
 1427              		mov	r0, #13
 1428 0c90 0D0A0D0A 		bl	get_syscpreg
 1428      41626F72 
 1428      74656421 
 1428      00
 1429 0c9d 000000   		.loc 4 29 0
 1430              		mov	r0, r0, lsr #17
 1431              		mvn	r0, r0
 1432              		and	r0, r0, #15
 1433              		cmp	r0, #1
 1434              		moveq	r4, #48
 1435              	.LVL117:
   1:main.c        **** #include "storm_core.h"
   2:main.c        **** #include "storm_soc_basic.h"
   3:main.c        **** #include "io_driver.c"
   4:main.c        **** #include "uart.c"
   5:main.c        **** #include "utilities.c"
   6:main.c        **** 
   7:main.c        **** 
   8:main.c        **** // ############################################################################################
   9:main.c        **** // STORM SoC Bootloader
  10:main.c        ****    int main(void)
  11:main.c        **** // ############################################################################################
  12:main.c        **** {
 1436              	printf
 1437              		.loc 4 37 0
 1438              		ldr	r0, .L325+4
 1439 069c E92D45F0 		bl	uart0_printf
 1440              		.loc 4 38 0
  13:main.c        **** 	int function_sel, data, i, start_app = 0;
  14:main.c        **** 	unsigned long *data_pointer, word_buffer, adr_buffer, cnt;
  15:main.c        **** 	unsigned char buffer[5], char_tmp, *char_pointer, device_id;
  16:main.c        **** 
  17:main.c        **** 	// show reset ack
  18:main.c        **** 	io_set_gpio0_port(0);
 1441              	r0, .L325+8
 1442 06a0 E3A00000 		bl	uart0_printf
 1443              		.loc 4 39 0
 1444 06a4 E24DD00C 		ldr	r0, .L325+12
 1445              		bl	uart0_printf
 1446              		.loc 4 40 0
 1447 06a8 EBFFFFFE 		ldr	r0, .L325+16
  19:main.c        **** 	set_syscpreg(0xC3, SYS_IO);
 1448              	t0_printf
 1449 06ac E3A0100D 		.loc 4 41 0
 1450 06b0 E3A000C3 		ldr	r0, .L325+20
 1451 06b4 EBFFFFFE 		bl	uart0_printf
  20:main.c        **** 
  21:main.c        **** 	// init I²C
  22:main.c        **** 	io_i2c0_speed(0x0063); // 100kHz
 1452              	c 4 43 0
 1453 06b8 E3A00063 		ldr	r0, .L325+24
 1454 06bc EBFFFFFE 		bl	uart0_printf
  23:main.c        **** 
  24:main.c        **** 	// enable write-through strategy
  25:main.c        **** 	set_syscpreg(get_syscpreg(SYS_CTRL_0) | (1<<DC_WTHRU), SYS_CTRL_0);
 1455              	oc 4 44 0
 1456 06c0 E3A00006 		ldr	r0, .L325+28
 1457 06c4 EBFFFFFE 		bl	uart0_printf
 1458 06c8 E3A01006 		.loc 4 47 0
 1459 06cc E3800008 		ldr	r0, .L325+32
 1460 06d0 EBFFFFFE 		bl	uart0_printf
  26:main.c        **** 
  27:main.c        **** 	// Check config switches for immediate boot-config
  28:main.c        **** 	function_sel = (int)((~(get_syscpreg(SYS_IO) >> 17)) & 0x0F);
 1461              	4 48 0
 1462 06d4 E3A0000D 		ldr	r0, .L325+36
 1463 06d8 EBFFFFFE 		bl	uart0_printf
  29:main.c        **** 	switch(function_sel){
 1464              	oc 4 49 0
 1465 06dc E1A008A0 		ldr	r0, .L325+40
 1466 06e0 E1E00000 		bl	uart0_printf
 1467 06e4 E200000F 		add	sl, sp, #7
 1468 06e8 E3500001 	.LVL118:
 1469 06ec 03A04030 	.L207:
 1470              		.loc 4 54 0
 1471 06f0 028DA007 		bl	io_uart0_read_byte
 1472 06f4 0A00001A 		mov	r4, r0
 1473 06f8 E3500002 	.LVL119:
 1474 06fc 0A000070 	.L206:
  30:main.c        **** 		case 1: function_sel = '0'; goto main_menu; break; // auto start application from RAM
  31:main.c        **** 		case 2: function_sel = '3'; goto main_menu; start_app = 1; device_id = 0xA0; break; // auto boot 
  32:main.c        **** 		default: break;
  33:main.c        **** 	}
  34:main.c        **** 
  35:main.c        **** 	// Intro screen
  36:main.c        **** 	uart0_printf("\r\n\r\n\r\n+----------------------------------------------------------------+\r\n")
 1475              	0
 1476 0700 E59F07EC 		mov	r0, #13
 1477 0704 EBFFFFFE 		bl	get_syscpreg
  37:main.c        **** 	uart0_printf(            "|    <<< STORM Core Processor System - By Stephan Nolting >>>    |\r\n")
 1478              	t	r0, #65536
 1479 0708 E59F07E8 		.loc 4 132 0
 1480 070c EBFFFFFE 		moveq	r6, #1
  38:main.c        **** 	uart0_printf(            "+----------------------------------------------------------------+\r\n")
 1481              	L120:
 1482 0710 E59F07E4 		moveq	r5, #160
 1483 0714 EBFFFFFE 	.LVL121:
  39:main.c        **** 	uart0_printf(            "|         Bootloader for STORM SoC   Version: 20120524-D         |\r\n")
 1484              	oc 4 59 0
 1485 0718 E59F07E0 		bne	.L315
 1486 071c EBFFFFFE 	.LVL122:
  40:main.c        **** 	uart0_printf(            "|               Contact: stnolting@googlemail.com                |\r\n")
 1487              	43:
 1488 0720 E59F07DC 		.loc 4 139 0
 1489 0724 EBFFFFFE 		mov	r4, #0
  41:main.c        **** 	uart0_printf(            "+----------------------------------------------------------------+\r\n\r
 1490              	L123:
 1491 0728 E59F07D8 		.loc 4 137 0
 1492 072c EBFFFFFE 		ldr	r0, .L325+44
  42:main.c        **** 
  43:main.c        **** 	uart0_printf(            " < Welcome to the STORM SoC bootloader console! >\r\n < Select an operat
 1493              		uart0_printf
 1494 0730 E59F07D4 	.LVL124:
 1495 0734 EBFFFFFE 		.loc 4 139 0
  44:main.c        **** 	uart0_printf(            " < the boot key for immediate application start. >\r\n\r\n");
 1496              	v	r1, r5
 1497 0738 E59F07D0 		mov	r2, r4
 1498 073c EBFFFFFE 		mov	r3, #2
  45:main.c        **** 
  46:main.c        **** 	// Console menu
  47:main.c        **** 	uart0_printf(" 0 - boot from core RAM (start application)\r\n 1 - program core RAM via UART_0\r\n 
 1499              	v	r0, #114
 1500 0740 E59F07CC 		str	r4, [sp, #0]
 1501 0744 EBFFFFFE 		bl	io_i2c0_byte_transfer
  48:main.c        **** 	uart0_printf(" 3 - boot from I2C EEPROM\r\n 4 - program I2C EEPROM via UART_0\r\n 5 - show content
 1502              	oc 4 140 0
 1503 0748 E59F07C8 		mov	r1, r5
 1504 074c EBFFFFFE 		.loc 4 139 0
  49:main.c        **** 	uart0_printf(" a - automatic boot configuration\r\n h - help\r\n r - restart system\r\n\r\nSelect:
 1505              	rb	r0, [sp, #7]
 1506 0750 E59F07C4 		.loc 4 140 0
 1507 0754 EBFFFFFE 		mov	r2, #1
 1508 0758 E28DA007 		mov	r3, #2
 1509              		mov	r0, #114
 1510              		str	r4, [sp, #0]
  50:main.c        **** 
  51:main.c        **** 	while(1){
  52:main.c        **** 
  53:main.c        **** 		// console input
  54:main.c        **** 		function_sel = io_uart0_read_byte();
 1511              	_i2c0_byte_transfer
 1512 075c EBFFFFFE 		.loc 4 141 0
 1513 0760 E1A04000 		mov	r2, #2
 1514              		mov	r3, r2
 1515              		.loc 4 140 0
  55:main.c        **** 
  56:main.c        **** main_menu:
  57:main.c        **** 
  58:main.c        **** 		// boot button
  59:main.c        **** 		if (((get_syscpreg(SYS_IO) >> 16) & 0x01) == 0){
 1516              		r0, [sp, #8]
 1517 0764 E3A0000D 		.loc 4 141 0
 1518 0768 EBFFFFFE 		mov	r1, r5
 1519 076c E3100801 		mov	r0, #114
  60:main.c        **** 			function_sel = '3';
  61:main.c        **** 			start_app    = 1;
  62:main.c        **** 			device_id    = 0xA0;
  63:main.c        **** 		}
  64:main.c        **** 
  65:main.c        **** 		// main functions
  66:main.c        **** 		switch(function_sel){
  67:main.c        **** 
  68:main.c        **** 			// boot from RAM (start application)
  69:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  70:main.c        **** 			case '0':
  71:main.c        **** 				io_uart0_send_byte((char)function_sel);
  72:main.c        **** 				start_app = 1;
  73:main.c        **** 				break;
  74:main.c        **** 
  75:main.c        **** 			// load ram via UART0
  76:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  77:main.c        **** 			case '1':
  78:main.c        **** 				io_uart0_send_byte((char)function_sel);
  79:main.c        **** 				uart0_printf("\r\n\r\nApplication will start automatically after download.\r\n-> Waiting for 's
  80:main.c        **** 				uart0_scanf(buffer,4,0); // get storm master boot record code
  81:main.c        **** 				if((buffer[0] == 'S') && (buffer[1] == 'M') && (buffer[2] == 'B') && (buffer[3] == 'R')){
  82:main.c        **** 					uart0_scanf(buffer,4,0); // get image size
  83:main.c        **** 					adr_buffer = qbytes_to_long(buffer);
  84:main.c        **** 					if (adr_buffer > RAM_SIZE-8){
  85:main.c        **** 						uart0_printf(" ERROR! Program file too big!\r\n\r\n");
  86:main.c        **** 						break;
  87:main.c        **** 					}
  88:main.c        **** 					data_pointer = 0;
  89:main.c        **** 					while(data_pointer != adr_buffer+4){
  90:main.c        **** 						uart0_scanf(buffer,4,0); // get word
  91:main.c        **** 						*data_pointer = qbytes_to_long(buffer); // store memory entry
  92:main.c        **** 						data_pointer = data_pointer + 1;
  93:main.c        **** 					}
  94:main.c        **** 					start_app = 1;
  95:main.c        **** 				}
  96:main.c        **** 				else
  97:main.c        **** 					uart0_printf(" Invalid programming file!\r\n\r\nSelect: ");
  98:main.c        **** 				break;
  99:main.c        **** 
 100:main.c        **** 			// ram memory dump
 101:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 102:main.c        **** 			case '2':
 103:main.c        **** 				io_uart0_send_byte((char)function_sel);
 104:main.c        **** 				uart0_printf("\r\n\r\nAbort dumping by pressing any key.\r\nPress any key to continue.\r\n\r\n"
 105:main.c        **** 				while(io_uart0_read_byte() == -1);
 106:main.c        **** 				while(io_uart0_read_byte() != -1);
 107:main.c        **** 				data_pointer = 0;
 108:main.c        **** 				while(data_pointer != RAM_SIZE){
 109:main.c        **** 					word_buffer = *data_pointer;
 110:main.c        **** 					io_uart0_send_byte(word_buffer >> 24);
 111:main.c        **** 					io_uart0_send_byte(word_buffer >> 16);
 112:main.c        **** 					io_uart0_send_byte(word_buffer >>  8);
 113:main.c        **** 					io_uart0_send_byte(word_buffer >>  0);
 114:main.c        **** 					data_pointer++;
 115:main.c        **** 					if(io_uart0_read_byte() != -1){
 116:main.c        **** 						break;
 117:main.c        **** 						uart0_printf("\r\n\r\nAborted!");
 118:main.c        **** 					}
 119:main.c        **** 				}
 120:main.c        **** 				uart0_printf("\r\n\r\nDumping completed.\r\n\r\nSelect: ");
 121:main.c        **** 				break;
 122:main.c        **** 
 123:main.c        **** 			// boot from I²C EEPROM
 124:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 125:main.c        **** 			case '3':
 126:main.c        **** 				if(start_app == 0){
 127:main.c        **** 					io_uart0_send_byte((char)function_sel);
 128:main.c        **** 					uart0_printf("\r\n\r\nEnter device address (2x hex_chars, set LSB to '0'): ");
 129:main.c        **** 					uart0_scanf(buffer,2,1);
 130:main.c        **** 					device_id = (unsigned char)hex_string_to_long(buffer, 2);
 131:main.c        **** 					if(device_id == 0){
 132:main.c        **** 						uart0_printf(" Invalid address!\r\n\r\nSelect: ");
 1520              		r4, [sp, #0]
 1521 0770 03A06001 		bl	io_i2c0_byte_transfer
 1522              		.loc 4 142 0
 1523 0774 03A050A0 		mov	r3, #2
 1524              		.loc 4 141 0
 1525              		strb	r0, [sp, #9]
 1526 0778 1A000035 		.loc 4 142 0
 1527              		mov	r1, r5
 1528              		mov	r0, #114
 133:main.c        **** 						break;
 134:main.c        **** 					}
 135:main.c        **** 				}
 136:main.c        **** 
 137:main.c        **** 				uart0_printf("\r\nApplication will start automatically after upload.\r\n-> Loading boot image..
 138:main.c        **** 				cnt = 0;
 139:main.c        **** 				buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1529              	#3
 1530 077c E3A04000 		str	r4, [sp, #0]
 1531              		bl	io_i2c0_byte_transfer
 1532              		.loc 4 143 0
 1533 0780 E59F0798 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1534 0784 EBFFFFFE 		.loc 4 142 0
 1535              		and	r0, r0, #255
 1536              		.loc 4 143 0
 1537 0788 E1A01005 		cmp	r3, #83
 1538 078c E1A02004 		.loc 4 142 0
 1539 0790 E3A03002 		strb	r0, [sp, #10]
 1540 0794 E3A00072 		.loc 4 143 0
 1541 0798 E58D4000 		bne	.L244
 1542 079c EBFFFFFE 		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 140:main.c        **** 				buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1543              	beq	.L316
 1544 07a0 E1A01005 	.L244:
 1545              		.loc 4 162 0
 1546 07a4 E5CD0007 		ldr	r0, .L325+48
 1547              		bl	uart0_printf
 1548 07a8 E3A02001 		.loc 4 317 0
 1549 07ac E3A03002 		cmp	r6, #0
 1550 07b0 E3A00072 		beq	.L207
 1551 07b4 E58D4000 	.LVL125:
 1552 07b8 EBFFFFFE 	.L225:
 141:main.c        **** 				buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1553              	3 0
 1554 07bc E3A02002 		ldr	r0, .L325+52
 1555 07c0 E1A03002 	.LVL126:
 1556              		bl	uart0_printf
 1557 07c4 E5CD0008 		.loc 4 324 0
 1558              		mov	r1, #13
 1559 07c8 E1A01005 		mov	r0, #0
 1560 07cc E3A00072 		bl	set_syscpreg
 1561 07d0 E58D4000 		.loc 4 327 0
 1562 07d4 EBFFFFFE 		mov	r0, #6
 142:main.c        **** 				buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1563              	scpreg
 1564 07d8 E3A03002 		mov	r1, #6
 1565              		bic	r0, r0, #8
 1566 07dc E5CD0009 		bl	set_syscpreg
 1567              		.loc 4 330 0
 1568 07e0 E1A01005 		mov pc, #0
 1569 07e4 E3A00072 	.L285:
 1570 07e8 E3A02003 		b	.L285
 1571 07ec E58D4000 	.LVL127:
 1572 07f0 EBFFFFFE 	.L315:
 143:main.c        **** 				if((buffer[0] == 'S') && (buffer[1] == 'M') && (buffer[2] == 'B') && (buffer[3] == 'R')){
 1573              	 0
 1574 07f4 E5DD3007 		cmp	r4, #52
 1575              		beq	.L216
 1576 07f8 E20000FF 		bgt	.L222
 1577              		cmp	r4, #49
 1578 07fc E3530053 		beq	.L213
 1579              		ble	.L317
 1580 0800 E5CD000A 		cmp	r4, #50
 1581              		beq	.L214
 1582 0804 1A000002 		cmp	r4, #51
 1583 0808 E5DD3008 		bne	.L210
 1584 080c E353004D 		.loc 4 127 0
 1585 0810 0A000062 		mov	r0, r4
 1586              		bl	io_uart0_send_byte
 144:main.c        **** 					buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 145:main.c        **** 					buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 146:main.c        **** 					buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 147:main.c        **** 					buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 148:main.c        **** 					adr_buffer = qbytes_to_long(buffer);
 149:main.c        **** 					data_pointer = 0;
 150:main.c        **** 					while((data_pointer != adr_buffer+4) && (data_pointer < IRAM_SIZE)){
 151:main.c        **** 						buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 152:main.c        **** 						buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 153:main.c        **** 						buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 154:main.c        **** 						buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 155:main.c        **** 						*data_pointer = qbytes_to_long(buffer); // store memory entry
 156:main.c        **** 						data_pointer = data_pointer + 1;
 157:main.c        **** 					}
 158:main.c        **** 					uart0_printf(" Upload complete\r\n");
 159:main.c        **** 					start_app = 1;
 160:main.c        **** 				}
 161:main.c        **** 				else
 162:main.c        **** 					uart0_printf(" Invalid boot device or file!\r\n\r\nSelect: ");
 1587              		ldr	r0, .L325+56
 1588 0814 E59F0708 		bl	uart0_printf
 1589 0818 EBFFFFFE 		.loc 4 129 0
 163:main.c        **** 				break;
 164:main.c        **** 
 165:main.c        **** 			// program I²C EEPROM
 166:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 167:main.c        **** 			case '4':
 168:main.c        **** 				io_uart0_send_byte((char)function_sel);
 169:main.c        **** 				uart0_printf("\r\n\r\nEnter device address (2x hex_chars, set LSB to '0'): ");
 170:main.c        **** 				uart0_scanf(buffer,2,1);
 171:main.c        **** 				device_id = (unsigned char)hex_string_to_long(buffer, 2);
 172:main.c        **** 				if(device_id == 0){
 173:main.c        **** 					uart0_printf("\r\nInvalid address!\r\n\r\nSelect: ");
 174:main.c        **** 					break;
 175:main.c        **** 				}
 176:main.c        **** 
 177:main.c        **** 				uart0_printf("\r\nData will overwrite RAM content!\r\n-> Waiting for 'storm_program.bin' in byt
 178:main.c        **** 				uart0_scanf(buffer,4,0);
 179:main.c        **** 				if((buffer[0]=='S') && (buffer[1]=='M') && (buffer[2]=='B') && (buffer[3]=='R')){
 180:main.c        **** 					char_pointer = 0; // beginning of RAM
 181:main.c        **** 					*char_pointer++ = 'S'; asm volatile ("NOP");
 182:main.c        **** 					*char_pointer++ = 'M'; asm volatile ("NOP");
 183:main.c        **** 					*char_pointer++ = 'B'; asm volatile ("NOP");
 184:main.c        **** 					*char_pointer++ = 'R'; asm volatile ("NOP");
 185:main.c        **** 					uart0_scanf(buffer,4,0);
 186:main.c        **** 					*char_pointer++ = buffer[0];
 187:main.c        **** 					*char_pointer++ = buffer[1];
 188:main.c        **** 					*char_pointer++ = buffer[2];
 189:main.c        **** 					*char_pointer++ = buffer[3];
 190:main.c        **** 					cnt = qbytes_to_long(buffer);
 191:main.c        **** 					if(cnt > 0xFFFC){
 192:main.c        **** 						uart0_printf(" ERROR! Program file too big!\r\n\r\n");
 193:main.c        **** 						break;
 194:main.c        **** 					}
 195:main.c        **** 
 196:main.c        **** 					for(i=0; i<cnt+4; i++){
 197:main.c        **** 						data = -1;
 198:main.c        **** 						while(data == -1)
 199:main.c        **** 							data = io_uart0_read_byte();
 200:main.c        **** 						*char_pointer++ = (unsigned char)data;
 201:main.c        **** 					}
 202:main.c        **** 					uart0_printf(" Download completed\r\n");
 203:main.c        **** 
 204:main.c        **** 					uart0_printf("Writing buffer to i2c EEPROM...");
 205:main.c        **** 					char_pointer = 0; // beginning of RAM
 206:main.c        **** 					for(i=0; i<cnt+12; i++){
 207:main.c        **** 						char_tmp = *char_pointer++;
 208:main.c        **** 						while(io_i2c0_byte_transfer('w', device_id, i, 2, char_tmp) != 0);
 209:main.c        **** 					}
 210:main.c        **** 					uart0_printf(" Completed\r\n\r\n");
 211:main.c        **** 				}
 212:main.c        **** 				else
 213:main.c        **** 					uart0_printf(" Invalid boot device or file!\r\n\r\n");
 214:main.c        **** 				uart0_printf("Select: ");
 215:main.c        **** 				break;
 216:main.c        **** 
 217:main.c        **** 			// show content of I2C EEPROM
 218:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 219:main.c        **** 			case '5':
 220:main.c        **** 				io_uart0_send_byte((char)function_sel);
 221:main.c        **** 				uart0_printf("\r\n\r\nEnter device address (2 hex-chars, set LSB to '0'): ");
 222:main.c        **** 				uart0_scanf(buffer,2,1);
 223:main.c        **** 				device_id = (unsigned char)hex_string_to_long(buffer, 2);
 224:main.c        **** 				if(device_id == 0){
 225:main.c        **** 					uart0_printf(" Invalid address!\r\n\r\nSelect: ");
 226:main.c        **** 					break;
 227:main.c        **** 				}
 228:main.c        **** 				uart0_printf("\r\n\r\nAbort dumping by pressing any key. If no data is shown,\r\n");
 229:main.c        **** 				uart0_printf("the selected device is not responding. Press any key to continue.\r\n\r\n");
 230:main.c        **** 				while(io_uart0_read_byte() == -1);
 231:main.c        **** 				while(io_uart0_read_byte() != -1);
 232:main.c        **** 				for(i=0; i<0xFFFF; i++){
 233:main.c        **** 						data = -1;
 234:main.c        **** 						while(data < 0){
 235:main.c        **** 							data = io_i2c0_byte_transfer('r', device_id, i, 2, 0x00);
 236:main.c        **** 							if(io_uart0_read_byte() != -1){
 237:main.c        **** 								function_sel = 'X';
 238:main.c        **** 								break;
 239:main.c        **** 							}
 240:main.c        **** 						}
 241:main.c        **** 						if(function_sel == 'X'){
 242:main.c        **** 							uart0_printf("\r\n\r\nAborted!");
 243:main.c        **** 							break;
 244:main.c        **** 						}
 245:main.c        **** 						io_uart0_send_byte(data);
 246:main.c        **** 				}
 247:main.c        **** 				uart0_printf("\r\n\r\nDumping completed.\r\n\r\nSelect: ");
 248:main.c        **** 				break;
 249:main.c        **** 
 250:main.c        **** 			// Automatic boot configuration
 251:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 252:main.c        **** 			case 'a':
 253:main.c        **** 				io_uart0_send_byte((char)function_sel);
 254:main.c        **** 				uart0_printf("\r\n\r\nAutomatic boot configuration for power-up:\r\n");
 255:main.c        **** 				uart0_printf("[3210] configuration DIP switch\r\n 0000 - Start bootloader console\r\n 0001 - Au
 256:main.c        **** 				uart0_printf(" 0010 - Automatic boot from I2C EEPROM (Address 0xA0)\r\n\r\nSelect: ");
 257:main.c        **** 				break;
 258:main.c        **** 
 259:main.c        **** 			// Help screen
 260:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 261:main.c        **** 			case 'h':
 262:main.c        **** 				io_uart0_send_byte((char)function_sel);
 263:main.c        **** 				uart0_printf("\r\n\r\nSTORM SoC bootloader\r\n");
 264:main.c        **** 				uart0_printf("'0': Execute program in RAM.\r\n");
 265:main.c        **** 				uart0_printf("'1': Write 'storm_program.bin' to the core's RAM via UART.\r\n");
 266:main.c        **** 				uart0_printf("'2': Print current content of complete core RAM.\r\n");
 267:main.c        **** 				uart0_printf("'3': Load boot image from EEPROM and start application.\r\n");
 268:main.c        **** 				uart0_printf("'4': Write 'storm_program.bin' to I2C EEPROM via UART.\r\n");
 269:main.c        **** 				uart0_printf("'5': Print content of I2C EEPROM.\r\n");
 270:main.c        **** 				uart0_printf("'a': Show DIP switch configurations for automatic boot.\r\n");
 271:main.c        **** 				uart0_printf("'h': Show this screen.\r\n");
 272:main.c        **** 				uart0_printf("'r': Reset system.\r\n\r\n");
 273:main.c        **** 				uart0_printf("Boot EEPROM: 24xxnnn (like 24AA64), 7 bit address + dont-care bit,\r\n");
 274:main.c        **** 				uart0_printf("connected to I2C_CONTROLLER_0, operating frequency is 100kHz,\r\n");
 275:main.c        **** 				uart0_printf("maximum EEPROM size = 65536 byte => 16 bit addresses,\r\n");
 276:main.c        **** 				uart0_printf("fixed boot device address: 0xA0\r\n\r\n");
 277:main.c        **** 				uart0_printf("Terminal setup: 9600 baud, 8 data bits, no parity, 1 stop bit\r\n\r\n");
 278:main.c        **** 				uart0_printf("For more information see the STORM Core / STORM SoC datasheet\r\n");
 279:main.c        **** 				uart0_printf("http://opencores.org/project,storm_core\r\n");
 280:main.c        **** 				uart0_printf("http://opencores.org/project,storm_soc\r\n");
 281:main.c        **** 				uart0_printf("Contact: stnolting@googlemail.com\r\n");
 282:main.c        **** 				uart0_printf("(c) 2012 by Stephan Nolting\r\n\r\nSelect: ");
 283:main.c        **** 				break;
 284:main.c        **** 
 285:main.c        **** 			// back to the future
 286:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 287:main.c        **** 			case 'f':
 288:main.c        **** 				io_uart0_send_byte((char)function_sel);
 289:main.c        **** 				uart0_printf("\r\n\r\nWe'll send you back - to the future!.\r\n\r\n");
 290:main.c        **** 				uart0_printf(" - Doctor Emmet L. Brown\r\n\r\nSelect: ");
 291:main.c        **** 				break;
 292:main.c        **** 
 293:main.c        **** 			// restart system
 294:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 295:main.c        **** 			case 'r':
 296:main.c        **** 				io_uart0_send_byte((char)function_sel);
 297:main.c        **** 				asm volatile ("mov r0,     #0x0FF00000");
 298:main.c        **** 				asm volatile ("add pc, r0, #0xF0000000"); // jump to bootloader
 299:main.c        **** 				while(1);
 300:main.c        **** 				break;
 301:main.c        **** 
 302:main.c        **** 			// no input
 303:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 304:main.c        **** 			case -1:
 305:main.c        **** 				break;
 306:main.c        **** 
 307:main.c        **** 			// invalid selection
 308:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 309:main.c        **** 			default:
 310:main.c        **** 				io_uart0_send_byte((char)function_sel);
 311:main.c        **** 				uart0_printf(" Invalid operation!\r\nTry again: ");
 312:main.c        **** 				break;
 313:main.c        **** 
 314:main.c        **** 		}
 315:main.c        **** 
 316:main.c        **** 		// start application request
 317:main.c        **** 		if(start_app != 0)
 1590              	v	r0, sl
 1591 081c E3560000 		mov	r1, #2
 1592 0820 0AFFFFCD 		mov	r2, #1
 1593              		bl	uart0_scanf
 1594              		.loc 4 130 0
 318:main.c        **** 			break;
 319:main.c        **** 
 320:main.c        **** 	}
 321:main.c        **** 
 322:main.c        **** 	// start application
 323:main.c        **** 	uart0_printf("\r\n\r\n-> Starting application...\r\n\r\n");
 1595              	r1, #2
 1596 0824 E59F06FC 		mov	r0, sl
 1597              		bl	hex_string_to_long
 1598 0828 EBFFFFFE 		.loc 4 131 0
 324:main.c        **** 	set_syscpreg(0x00, SYS_IO);
 1599              	s	r1, r0, #255
 1600 082c E3A0100D 	.LVL128:
 1601 0830 E3A00000 		movne	r5, r1
 1602 0834 EBFFFFFE 		movne	r6, #0
 325:main.c        **** 
 326:main.c        **** 	// disable write-through strategy
 327:main.c        **** 	set_syscpreg(get_syscpreg(SYS_CTRL_0) & ~(1<<DC_WTHRU), SYS_CTRL_0);
 1603              		.L243
 1604 0838 E3A00006 	.LVL129:
 1605 083c EBFFFFFE 	.L311:
 1606 0840 E3A01006 		.loc 4 225 0
 1607 0844 E3C00008 		ldr	r0, .L325+60
 1608 0848 EBFFFFFE 		bl	uart0_printf
 328:main.c        **** 
 329:main.c        **** 	// jump to application
 330:main.c        **** 	asm volatile ("mov pc, #0");
 1609              	0:
 1610 084c E3A0F000 		b	.L207
 1611              	.LVL131:
 1612 0850 EAFFFFFE 	.L314:
 1613              		.loc 4 29 0
 1614              		mov	r4, #51
 1615              		add	sl, sp, #7
 1616 0854 E3540034 		b	.L206
 1617 0858 0A000028 	.LVL132:
 1618 085c CA00001B 	.L222:
 1619 0860 E3540031 		.loc 4 66 0
 1620 0864 0A000035 		cmp	r4, #102
 1621 0868 DA000097 		beq	.L219
 1622 086c E3540032 		ble	.L318
 1623 0870 0A0000A1 		cmp	r4, #104
 1624 0874 E3540033 		beq	.L220
 1625 0878 1A000097 		cmp	r4, #114
 1626              		bne	.L210
 1627 087c E1A00004 		.loc 4 296 0
 1628 0880 EBFFFFFE 		mov	r0, r4
 1629              		bl	io_uart0_send_byte
 1630 0884 E59F06A0 		.loc 4 297 0
 1631 0888 EBFFFFFE 		mov r0,     #0x0FF00000
 1632              		.loc 4 298 0
 1633 088c E1A0000A 		add pc, r0, #0xF0000000
 1634 0890 E3A01002 	.L284:
 1635 0894 E3A02001 		b	.L284
 1636 0898 EBFFFFFE 	.L216:
 1637              		.loc 4 168 0
 1638 089c E3A01002 		mov	r0, r4
 1639 08a0 E1A0000A 		bl	io_uart0_send_byte
 1640 08a4 EBFFFFFE 		.loc 4 169 0
 1641              		ldr	r0, .L325+56
 1642 08a8 E21010FF 		bl	uart0_printf
 1643              		.loc 4 170 0
 1644 08ac 11A05001 		mov	r0, sl
 1645 08b0 13A06000 		mov	r1, #2
 1646 08b4 1AFFFFB0 		mov	r2, #1
 1647              		bl	uart0_scanf
 1648              		.loc 4 171 0
 1649              		mov	r0, sl
 1650 08b8 E59F0670 		mov	r1, #2
 1651 08bc EBFFFFFE 		bl	hex_string_to_long
 1652              		.loc 4 172 0
 1653 08c0 EAFFFFA5 		ands	r8, r0, #255
 1654              		bne	.L253
 1655              		.loc 4 173 0
 1656              		ldr	r0, .L325+64
 1657 08c4 E3A04033 		bl	uart0_printf
 1658 08c8 E28DA007 		b	.L207
 1659 08cc EAFFFFA4 	.L213:
 1660              		.loc 4 78 0
 1661              		mov	r0, r4
 1662              		bl	io_uart0_send_byte
 1663 08d0 E3540066 		.loc 4 79 0
 1664 08d4 0A00002A 		ldr	r0, .L325+68
 1665 08d8 DA0000A5 		bl	uart0_printf
 1666 08dc E3540068 		.loc 4 80 0
 1667 08e0 0A000107 		mov	r0, sl
 1668 08e4 E3540072 		mov	r1, #4
 1669 08e8 1A00007B 		mov	r2, #0
 1670              		bl	uart0_scanf
 1671 08ec E1A00004 		.loc 4 81 0
 1672 08f0 EBFFFFFE 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1673              		cmp	r3, #83
 1674 08f4 E3A006FF 		bne	.L226
 1675              		ldrb	r3, [sp, #8]	@ zero_extendqisi2
 1676 08f8 E280F20F 		cmp	r3, #77
 1677              		beq	.L319
 1678 08fc EAFFFFFE 	.L226:
 1679              		.loc 4 97 0
 1680              		ldr	r0, .L325+72
 1681 0900 E1A00004 		bl	uart0_printf
 1682 0904 EBFFFFFE 		b	.L207
 1683              	.L219:
 1684 0908 E59F061C 		.loc 4 288 0
 1685 090c EBFFFFFE 		mov	r0, r4
 1686              		bl	io_uart0_send_byte
 1687 0910 E1A0000A 		.loc 4 289 0
 1688 0914 E3A01002 		ldr	r0, .L325+76
 1689 0918 E3A02001 		bl	uart0_printf
 1690 091c EBFFFFFE 		.loc 4 290 0
 1691              		ldr	r0, .L325+80
 1692 0920 E1A0000A 		bl	uart0_printf
 1693 0924 E3A01002 		b	.L207
 1694 0928 EBFFFFFE 	.LVL133:
 1695              	.L316:
 1696 092c E21080FF 		.loc 4 143 0
 1697 0930 1A00009C 		ldrb	r3, [sp, #9]	@ zero_extendqisi2
 1698              		cmp	r3, #66
 1699 0934 E59F05F8 		bne	.L244
 1700 0938 EBFFFFFE 		cmp	r0, #82
 1701 093c EAFFFF86 		bne	.L244
 1702              		.loc 4 144 0
 1703              		mov	r1, r5
 1704 0940 E1A00004 		mov	r2, #4
 1705 0944 EBFFFFFE 		sub	r3, r3, #64
 1706              		add	r0, r0, #32
 1707 0948 E59F05E8 		str	r4, [sp, #0]
 1708 094c EBFFFFFE 		bl	io_i2c0_byte_transfer
 1709              		.loc 4 145 0
 1710 0950 E1A0000A 		mov	r1, r5
 1711 0954 E3A01004 		.loc 4 144 0
 1712 0958 E3A02000 		strb	r0, [sp, #7]
 1713 095c EBFFFFFE 		.loc 4 145 0
 1714              		mov	r2, #5
 1715 0960 E5DD3007 		mov	r3, #2
 1716 0964 E3530053 		mov	r0, #114
 1717 0968 1A000002 		str	r4, [sp, #0]
 1718 096c E5DD3008 		bl	io_i2c0_byte_transfer
 1719 0970 E353004D 		.loc 4 146 0
 1720 0974 0A00010D 		mov	r1, r5
 1721              		.loc 4 145 0
 1722              		strb	r0, [sp, #8]
 1723 0978 E59F05BC 		.loc 4 146 0
 1724 097c EBFFFFFE 		mov	r2, #6
 1725 0980 EAFFFF75 		mov	r3, #2
 1726              		mov	r0, #114
 1727              		str	r4, [sp, #0]
 1728 0984 E1A00004 		bl	io_i2c0_byte_transfer
 1729 0988 EBFFFFFE 		.loc 4 147 0
 1730              		mov	r1, r5
 1731 098c E59F05AC 		.loc 4 146 0
 1732 0990 EBFFFFFE 		strb	r0, [sp, #9]
 1733              		.loc 4 147 0
 1734 0994 E59F05A8 		mov	r2, #7
 1735 0998 EBFFFFFE 		mov	r3, #2
 1736 099c EAFFFF6E 		mov	r0, #114
 1737              		str	r4, [sp, #0]
 1738              		bl	io_i2c0_byte_transfer
 1739              		strb	r0, [sp, #10]
 1740 09a0 E5DD3009 		.loc 4 148 0
 1741 09a4 E3530042 		mov	r0, sl
 1742 09a8 1AFFFF99 		bl	qbytes_to_long
 1743 09ac E3500052 		.loc 4 150 0
 1744 09b0 1AFFFF97 		adds	r7, r0, #4
 1745              		beq	.L249
 1746 09b4 E1A01005 	.LVL134:
 1747 09b8 E3A02004 		mov	r6, r4
 1748 09bc E2433040 	.LVL135:
 1749 09c0 E2800020 	.LVL136:
 1750 09c4 E58D4000 	.L251:
 1751 09c8 EBFFFFFE 		.loc 4 151 0
 1752              		add	r2, r4, #8
 1753 09cc E1A01005 		mov	r1, r5
 1754              		mov	r3, #2
 1755 09d0 E5CD0007 		mov	r0, #114
 1756              		str	r6, [sp, #0]
 1757 09d4 E3A02005 		bl	io_i2c0_byte_transfer
 1758 09d8 E3A03002 		.loc 4 152 0
 1759 09dc E3A00072 		add	r2, r4, #9
 1760 09e0 E58D4000 		.loc 4 151 0
 1761 09e4 EBFFFFFE 		strb	r0, [sp, #7]
 1762              		.loc 4 152 0
 1763 09e8 E1A01005 		mov	r1, r5
 1764              		mov	r3, #2
 1765 09ec E5CD0008 		mov	r0, #114
 1766              		str	r6, [sp, #0]
 1767 09f0 E3A02006 		bl	io_i2c0_byte_transfer
 1768 09f4 E3A03002 		.loc 4 153 0
 1769 09f8 E3A00072 		add	r2, r4, #10
 1770 09fc E58D4000 		.loc 4 152 0
 1771 0a00 EBFFFFFE 		strb	r0, [sp, #8]
 1772              		.loc 4 153 0
 1773 0a04 E1A01005 		mov	r1, r5
 1774              		mov	r3, #2
 1775 0a08 E5CD0009 		mov	r0, #114
 1776              		str	r6, [sp, #0]
 1777 0a0c E3A02007 		bl	io_i2c0_byte_transfer
 1778 0a10 E3A03002 		.loc 4 154 0
 1779 0a14 E3A00072 		add	r2, r4, #11
 1780 0a18 E58D4000 		.loc 4 153 0
 1781 0a1c EBFFFFFE 		strb	r0, [sp, #9]
 1782 0a20 E5CD000A 		.loc 4 154 0
 1783              		mov	r1, r5
 1784 0a24 E1A0000A 		mov	r3, #2
 1785 0a28 EBFFFFFE 		mov	r0, #114
 1786              		str	r6, [sp, #0]
 1787 0a2c E2907004 		bl	io_i2c0_byte_transfer
 1788 0a30 0A000022 		strb	r0, [sp, #10]
 1789              		.loc 4 155 0
 1790 0a34 E1A06004 		mov	r0, sl
 1791              		bl	qbytes_to_long
 1792              		str	r0, [r4], #4
 1793              		.loc 4 150 0
 1794              		cmp	r4, r7
 1795 0a38 E2842008 		cmpne	r4, #32768
 1796 0a3c E1A01005 		bcc	.L251
 1797 0a40 E3A03002 	.LVL137:
 1798 0a44 E3A00072 	.L249:
 1799 0a48 E58D6000 		.loc 4 158 0
 1800 0a4c EBFFFFFE 		ldr	r0, .L325+84
 1801              		bl	uart0_printf
 1802 0a50 E2842009 		b	.L225
 1803              	.LVL138:
 1804 0a54 E5CD0007 	.L317:
 1805              		.loc 4 66 0
 1806 0a58 E1A01005 		cmn	r4, #1
 1807 0a5c E3A03002 		beq	.L207
 1808 0a60 E3A00072 		cmp	r4, #48
 1809 0a64 E58D6000 		beq	.L320
 1810 0a68 EBFFFFFE 	.L210:
 1811              		.loc 4 310 0
 1812 0a6c E284200A 		and	r0, r4, #255
 1813              		bl	io_uart0_send_byte
 1814 0a70 E5CD0008 		.loc 4 311 0
 1815              		ldr	r0, .L325+88
 1816 0a74 E1A01005 		bl	uart0_printf
 1817 0a78 E3A03002 		b	.L207
 1818 0a7c E3A00072 	.L320:
 1819 0a80 E58D6000 		.loc 4 71 0
 1820 0a84 EBFFFFFE 		mov	r0, r4
 1821              		bl	io_uart0_send_byte
 1822 0a88 E284200B 		b	.L225
 1823              	.L214:
 1824 0a8c E5CD0009 		.loc 4 103 0
 1825              		mov	r0, r4
 1826 0a90 E1A01005 		bl	io_uart0_send_byte
 1827 0a94 E3A03002 		.loc 4 104 0
 1828 0a98 E3A00072 		ldr	r0, .L325+92
 1829 0a9c E58D6000 		bl	uart0_printf
 1830 0aa0 EBFFFFFE 	.L235:
 1831 0aa4 E5CD000A 		.loc 4 105 0
 1832              		bl	io_uart0_read_byte
 1833 0aa8 E1A0000A 		cmn	r0, #1
 1834 0aac EBFFFFFE 		beq	.L235
 1835 0ab0 E4840004 	.L292:
 1836              		.loc 4 106 0
 1837 0ab4 E1540007 		bl	io_uart0_read_byte
 1838 0ab8 13540902 		cmn	r0, #1
 1839 0abc 3AFFFFDD 		bne	.L292
 1840              		mov	r5, #0
 1841              	.LVL139:
 1842              		b	.L238
 1843 0ac0 E59F0480 	.LVL140:
 1844 0ac4 EBFFFFFE 	.L321:
 1845 0ac8 EAFFFF55 		.loc 4 108 0
 1846              		cmp	r5, #32768
 1847              		beq	.L283
 1848              	.LVL141:
 1849 0acc E3740001 	.L238:
 1850 0ad0 0AFFFF21 		.loc 4 109 0
 1851 0ad4 E3540030 		ldr	r4, [r5, #0]
 1852 0ad8 0A000004 	.LVL142:
 1853              		.loc 4 110 0
 1854              		mov	r0, r4, lsr #24
 1855 0adc E20400FF 		bl	io_uart0_send_byte
 1856 0ae0 EBFFFFFE 		.loc 4 111 0
 1857              		mov	r0, r4, lsr #16
 1858 0ae4 E59F0460 		bl	io_uart0_send_byte
 1859 0ae8 EBFFFFFE 		.loc 4 112 0
 1860 0aec EAFFFF1A 		mov	r0, r4, lsr #8
 1861              		bl	io_uart0_send_byte
 1862              		.loc 4 113 0
 1863 0af0 E1A00004 		mov	r0, r4
 1864 0af4 EBFFFFFE 		bl	io_uart0_send_byte
 1865 0af8 EAFFFF49 		.loc 4 115 0
 1866              		bl	io_uart0_read_byte
 1867              		cmn	r0, #1
 1868 0afc E1A00004 		.loc 4 114 0
 1869 0b00 EBFFFFFE 		add	r5, r5, #4
 1870              		.loc 4 115 0
 1871 0b04 E59F0444 		beq	.L321
 1872 0b08 EBFFFFFE 	.LVL143:
 1873              	.L283:
 1874              		.loc 4 247 0
 1875 0b0c EBFFFFFE 		ldr	r0, .L325+96
 1876 0b10 E3700001 		bl	uart0_printf
 1877 0b14 0AFFFFFC 		b	.L207
 1878              	.LVL144:
 1879              	.L318:
 1880 0b18 EBFFFFFE 		.loc 4 66 0
 1881 0b1c E3700001 		cmp	r4, #53
 1882 0b20 1AFFFFFC 		beq	.L217
 1883 0b24 E3A05000 		cmp	r4, #97
 1884              		bne	.L210
 1885 0b28 EA000001 		.loc 4 253 0
 1886              		mov	r0, r4
 1887              		bl	io_uart0_send_byte
 1888              		.loc 4 254 0
 1889 0b2c E3550902 		ldr	r0, .L325+100
 1890 0b30 0A00000C 		bl	uart0_printf
 1891              		.loc 4 255 0
 1892              		ldr	r0, .L325+104
 1893              		bl	uart0_printf
 1894 0b34 E5954000 		.loc 4 256 0
 1895              		ldr	r0, .L325+108
 1896              		bl	uart0_printf
 1897 0b38 E1A00C24 		b	.L207
 1898 0b3c EBFFFFFE 	.L253:
 1899              		.loc 4 177 0
 1900 0b40 E1A00824 		ldr	r0, .L325+112
 1901 0b44 EBFFFFFE 		bl	uart0_printf
 1902              		.loc 4 178 0
 1903 0b48 E1A00424 		mov	r0, sl
 1904 0b4c EBFFFFFE 		mov	r1, #4
 1905              		mov	r2, #0
 1906 0b50 E1A00004 		bl	uart0_scanf
 1907 0b54 EBFFFFFE 		.loc 4 179 0
 1908              		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1909 0b58 EBFFFFFE 		cmp	r3, #83
 1910 0b5c E3700001 		bne	.L255
 1911              		ldrb	r2, [sp, #8]	@ zero_extendqisi2
 1912 0b60 E2855004 		cmp	r2, #77
 1913              		beq	.L322
 1914 0b64 0AFFFFF0 	.L255:
 1915              		.loc 4 213 0
 1916              		ldr	r0, .L325+116
 1917              		bl	uart0_printf
 1918 0b68 E59F03E4 	.LVL145:
 1919 0b6c EBFFFFFE 	.L272:
 1920 0b70 EAFFFEF9 		.loc 4 214 0
 1921              		ldr	r0, .L325+120
 1922              		bl	uart0_printf
 1923              		b	.L207
 1924 0b74 E3540035 	.LVL146:
 1925 0b78 0A0000A9 	.L322:
 1926 0b7c E3540061 		.loc 4 179 0
 1927 0b80 1AFFFFD5 		ldrb	r1, [sp, #9]	@ zero_extendqisi2
 1928              		cmp	r1, #66
 1929 0b84 E1A00004 		bne	.L255
 1930 0b88 EBFFFFFE 		ldrb	r0, [sp, #10]	@ zero_extendqisi2
 1931              		cmp	r0, #82
 1932 0b8c E59F03C4 		bne	.L255
 1933 0b90 EBFFFFFE 		.loc 4 181 0
 1934              		mov	r4, #0
 1935 0b94 E59F03C0 	.LVL147:
 1936 0b98 EBFFFFFE 		strb	r3, [r4, #0]
 1937              		NOP
 1938 0b9c E59F03BC 		.loc 4 182 0
 1939 0ba0 EBFFFFFE 		strb	r2, [r4, #1]
 1940 0ba4 EAFFFEEC 		NOP
 1941              		.loc 4 183 0
 1942              		strb	r1, [r4, #2]
 1943 0ba8 E59F03B4 		NOP
 1944 0bac EBFFFFFE 		.loc 4 184 0
 1945              		strb	r0, [r4, #3]
 1946 0bb0 E1A0000A 		NOP
 1947 0bb4 E3A01004 		.loc 4 185 0
 1948 0bb8 E3A02000 		sub	r1, r1, #62
 1949 0bbc EBFFFFFE 		mov	r0, sl
 1950              		mov	r2, r4
 1951 0bc0 E5DD3007 		bl	uart0_scanf
 1952 0bc4 E3530053 		.loc 4 186 0
 1953 0bc8 1A000002 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 1954 0bcc E5DD2008 		strb	r3, [r4, #4]
 1955 0bd0 E352004D 		.loc 4 187 0
 1956 0bd4 0A000004 		ldrb	r2, [sp, #8]	@ zero_extendqisi2
 1957              		strb	r2, [r4, #5]
 1958              		.loc 4 188 0
 1959 0bd8 E59F0388 		ldrb	r3, [sp, #9]	@ zero_extendqisi2
 1960 0bdc EBFFFFFE 		strb	r3, [r4, #6]
 1961              		.loc 4 189 0
 1962              		ldrb	r2, [sp, #10]	@ zero_extendqisi2
 1963              		.loc 4 190 0
 1964 0be0 E59F0384 		mov	r0, sl
 1965 0be4 EBFFFFFE 		.loc 4 189 0
 1966 0be8 EAFFFEDB 		strb	r2, [r4, #7]
 1967              		.loc 4 190 0
 1968              		bl	qbytes_to_long
 1969              		.loc 4 191 0
 1970 0bec E5DD1009 		mov	r3, #65280
 1971 0bf0 E3510042 		add	r3, r3, #252
 1972 0bf4 1AFFFFF7 	.LVL148:
 1973 0bf8 E5DD000A 		cmp	r0, r3
 1974 0bfc E3500052 	.LVL149:
 1975 0c00 1AFFFFF4 		.loc 4 190 0
 1976              		mov	r5, r0
 1977 0c04 E3A04000 	.LVL150:
 1978              		.loc 4 191 0
 1979 0c08 E5C43000 		bhi	.L260
 1980 0c0c E1A00000 		.loc 4 196 0
 1981              		cmn	r0, #4
 1982 0c10 E5C42001 	.LVL151:
 1983 0c14 E1A00000 		addne	r4, r4, #8
 1984              		addne	r6, r0, #11
 1985 0c18 E5C41002 	.LVL152:
 1986 0c1c E1A00000 		beq	.L262
 1987              	.LVL153:
 1988 0c20 E5C40003 	.L312:
 1989 0c24 E1A00000 		.loc 4 199 0
 1990              		bl	io_uart0_read_byte
 1991 0c28 E241103E 	.LVL154:
 1992 0c2c E1A0000A 	.LVL155:
 1993 0c30 E1A02004 		.loc 4 198 0
 1994 0c34 EBFFFFFE 		cmn	r0, #1
 1995              		beq	.L312
 1996 0c38 E5DD3007 		.loc 4 196 0
 1997 0c3c E5C43004 		cmp	r6, r4
 1998              	.LVL156:
 1999 0c40 E5DD2008 		.loc 4 200 0
 2000 0c44 E5C42005 		strb	r0, [r4, #0]
 2001              		add	r4, r4, #1
 2002 0c48 E5DD3009 		.loc 4 196 0
 2003 0c4c E5C43006 		bne	.L312
 2004              	.LVL157:
 2005 0c50 E5DD200A 	.L262:
 2006              		.loc 4 202 0
 2007 0c54 E1A0000A 		ldr	r0, .L325+124
 2008              	.LVL158:
 2009 0c58 E5C42007 		bl	uart0_printf
 2010              		.loc 4 204 0
 2011 0c5c EBFFFFFE 		ldr	r0, .L325+128
 2012              		bl	uart0_printf
 2013 0c60 E3A03CFF 		.loc 4 206 0
 2014 0c64 E28330FC 		cmn	r5, #12
 2015              		beq	.L267
 2016 0c68 E1500003 		mov	r4, #0
 2017              	.LVL159:
 2018              		add	r7, r5, #12
 2019 0c6c E1A05000 		mov	r6, r4
 2020              	.L269:
 2021              		ldrb	r5, [r4, #0]	@ zero_extendqisi2
 2022 0c70 8A000095 	.LVL160:
 2023              	.L270:
 2024 0c74 E3700004 		.loc 4 208 0
 2025              		mov	r0, #119
 2026 0c78 12844008 		mov	r1, r8
 2027 0c7c 1280600B 		mov	r2, r6
 2028              		mov	r3, #2
 2029 0c80 0A000006 		str	r5, [sp, #0]
 2030              		bl	io_i2c0_byte_transfer
 2031              		cmp	r0, #0
 2032              		bne	.L270
 2033 0c84 EBFFFFFE 		.loc 4 206 0
 2034              		add	r4, r4, #1
 2035              		cmp	r4, r7
 2036              		mov	r6, r4
 2037 0c88 E3700001 		bne	.L269
 2038 0c8c 0AFFFFFC 	.LVL161:
 2039              	.L267:
 2040 0c90 E1560004 		.loc 4 210 0
 2041              		ldr	r0, .L325+132
 2042              		bl	uart0_printf
 2043 0c94 E5C40000 		b	.L272
 2044 0c98 E2844001 	.LVL162:
 2045              	.L220:
 2046 0c9c 1AFFFFF8 		.loc 4 262 0
 2047              		mov	r0, r4
 2048              		bl	io_uart0_send_byte
 2049              		.loc 4 263 0
 2050 0ca0 E59F02C8 		ldr	r0, .L325+136
 2051              		bl	uart0_printf
 2052 0ca4 EBFFFFFE 		.loc 4 264 0
 2053              		ldr	r0, .L325+140
 2054 0ca8 E59F02C4 		bl	uart0_printf
 2055 0cac EBFFFFFE 		.loc 4 265 0
 2056              		ldr	r0, .L325+144
 2057 0cb0 E375000C 		bl	uart0_printf
 2058 0cb4 0A00000F 		.loc 4 266 0
 2059 0cb8 E3A04000 		ldr	r0, .L325+148
 2060              		bl	uart0_printf
 2061 0cbc E285700C 		.loc 4 267 0
 2062 0cc0 E1A06004 		ldr	r0, .L325+152
 2063              		bl	uart0_printf
 2064 0cc4 E5D45000 		.loc 4 268 0
 2065              		ldr	r0, .L325+156
 2066              		bl	uart0_printf
 2067              		.loc 4 269 0
 2068 0cc8 E3A00077 		ldr	r0, .L325+160
 2069 0ccc E1A01008 		bl	uart0_printf
 2070 0cd0 E1A02006 		.loc 4 270 0
 2071 0cd4 E3A03002 		ldr	r0, .L325+164
 2072 0cd8 E58D5000 		bl	uart0_printf
 2073 0cdc EBFFFFFE 		.loc 4 271 0
 2074 0ce0 E3500000 		ldr	r0, .L325+168
 2075 0ce4 1AFFFFF7 		bl	uart0_printf
 2076              		.loc 4 272 0
 2077 0ce8 E2844001 		ldr	r0, .L325+172
 2078 0cec E1540007 		bl	uart0_printf
 2079 0cf0 E1A06004 		.loc 4 273 0
 2080 0cf4 1AFFFFF2 		ldr	r0, .L325+176
 2081              		bl	uart0_printf
 2082              		.loc 4 274 0
 2083              		ldr	r0, .L325+180
 2084 0cf8 E59F0278 		bl	uart0_printf
 2085 0cfc EBFFFFFE 		.loc 4 275 0
 2086 0d00 EAFFFFB6 		ldr	r0, .L325+184
 2087              		bl	uart0_printf
 2088              		.loc 4 276 0
 2089              		ldr	r0, .L325+188
 2090 0d04 E1A00004 		bl	uart0_printf
 2091 0d08 EBFFFFFE 		.loc 4 277 0
 2092              		ldr	r0, .L325+192
 2093 0d0c E59F0268 		bl	uart0_printf
 2094 0d10 EBFFFFFE 		.loc 4 278 0
 2095              		ldr	r0, .L325+196
 2096 0d14 E59F0264 		bl	uart0_printf
 2097 0d18 EBFFFFFE 		.loc 4 279 0
 2098              		ldr	r0, .L325+200
 2099 0d1c E59F0260 		bl	uart0_printf
 2100 0d20 EBFFFFFE 		.loc 4 280 0
 2101              		ldr	r0, .L325+204
 2102 0d24 E59F025C 		bl	uart0_printf
 2103 0d28 EBFFFFFE 		.loc 4 281 0
 2104              		ldr	r0, .L325+208
 2105 0d2c E59F0258 		bl	uart0_printf
 2106 0d30 EBFFFFFE 		.loc 4 282 0
 2107              		ldr	r0, .L325+212
 2108 0d34 E59F0254 		bl	uart0_printf
 2109 0d38 EBFFFFFE 		b	.L207
 2110              	.L319:
 2111 0d3c E59F0250 		.loc 4 81 0
 2112 0d40 EBFFFFFE 		ldrb	r3, [sp, #9]	@ zero_extendqisi2
 2113              		cmp	r3, #66
 2114 0d44 E59F024C 		bne	.L226
 2115 0d48 EBFFFFFE 		ldrb	r3, [sp, #10]	@ zero_extendqisi2
 2116              		cmp	r3, #82
 2117 0d4c E59F0248 		bne	.L226
 2118 0d50 EBFFFFFE 		.loc 4 82 0
 2119              		mov	r1, #4
 2120 0d54 E59F0244 		mov	r2, #0
 2121 0d58 EBFFFFFE 		mov	r0, sl
 2122              		bl	uart0_scanf
 2123 0d5c E59F0240 		.loc 4 83 0
 2124 0d60 EBFFFFFE 		mov	r0, sl
 2125              		bl	qbytes_to_long
 2126 0d64 E59F023C 		.loc 4 84 0
 2127 0d68 EBFFFFFE 		mov	r3, #32512
 2128              		add	r3, r3, #248
 2129 0d6c E59F0238 	.LVL163:
 2130 0d70 EBFFFFFE 		cmp	r0, r3
 2131              		bhi	.L260
 2132 0d74 E59F0234 		.loc 4 89 0
 2133 0d78 EBFFFFFE 		adds	r5, r0, #4
 2134              		beq	.L225
 2135 0d7c E59F0230 		.loc 4 86 0
 2136 0d80 EBFFFFFE 		mov	r4, #0
 2137              	.LVL164:
 2138 0d84 E59F022C 	.L234:
 2139 0d88 EBFFFFFE 		.loc 4 90 0
 2140              		mov	r1, #4
 2141 0d8c E59F0228 		mov	r2, #0
 2142 0d90 EBFFFFFE 		mov	r0, sl
 2143              	.LVL165:
 2144 0d94 E59F0224 		bl	uart0_scanf
 2145 0d98 EBFFFFFE 		.loc 4 91 0
 2146              		mov	r0, sl
 2147 0d9c E59F0220 		bl	qbytes_to_long
 2148 0da0 EBFFFFFE 		str	r0, [r4], #4
 2149              		.loc 4 89 0
 2150 0da4 E59F021C 		cmp	r5, r4
 2151 0da8 EBFFFFFE 		bne	.L234
 2152 0dac EAFFFE6A 		b	.L225
 2153              	.LVL166:
 2154              	.L217:
 2155 0db0 E5DD3009 		.loc 4 220 0
 2156 0db4 E3530042 		mov	r0, r4
 2157 0db8 1AFFFEEE 		bl	io_uart0_send_byte
 2158 0dbc E5DD300A 		.loc 4 221 0
 2159 0dc0 E3530052 		ldr	r0, .L325+216
 2160 0dc4 1AFFFEEB 		bl	uart0_printf
 2161              		.loc 4 222 0
 2162 0dc8 E3A01004 		mov	r0, sl
 2163 0dcc E3A02000 		mov	r1, #2
 2164 0dd0 E1A0000A 		mov	r2, #1
 2165 0dd4 EBFFFFFE 		bl	uart0_scanf
 2166              		.loc 4 223 0
 2167 0dd8 E1A0000A 		mov	r0, sl
 2168 0ddc EBFFFFFE 		mov	r1, #2
 2169              		bl	hex_string_to_long
 2170 0de0 E3A03C7F 		.loc 4 224 0
 2171 0de4 E28330F8 		ands	r6, r0, #255
 2172              	.LVL167:
 2173 0de8 E1500003 		beq	.L311
 2174 0dec 8A000036 		.loc 4 228 0
 2175              		ldr	r0, .L325+220
 2176 0df0 E2905004 		bl	uart0_printf
 2177 0df4 0AFFFE8A 		.loc 4 229 0
 2178              		ldr	r0, .L325+224
 2179 0df8 E3A04000 		bl	uart0_printf
 2180              	.L275:
 2181              		.loc 4 230 0
 2182              		bl	io_uart0_read_byte
 2183 0dfc E3A01004 		cmn	r0, #1
 2184 0e00 E3A02000 		beq	.L275
 2185 0e04 E1A0000A 	.L293:
 2186              		.loc 4 231 0
 2187 0e08 EBFFFFFE 		bl	io_uart0_read_byte
 2188              		cmn	r0, #1
 2189 0e0c E1A0000A 		bne	.L293
 2190 0e10 EBFFFFFE 		.loc 4 331 0
 2191 0e14 E4840004 		mov	r5, #0
 2192              	.LVL168:
 2193 0e18 E1550004 		b	.L313
 2194 0e1c 1AFFFFF6 	.LVL169:
 2195 0e20 EAFFFE7F 	.L324:
 2196              		.loc 4 234 0
 2197              		cmp	r4, #0
 2198              		bge	.L323
 2199 0e24 E1A00004 	.LVL170:
 2200 0e28 EBFFFFFE 	.L313:
 2201              		.loc 4 235 0
 2202 0e2c E59F0198 		mov	ip, #0
 2203 0e30 EBFFFFFE 		mov	r2, r5
 2204              		mov	r1, r6
 2205 0e34 E1A0000A 		mov	r3, #2
 2206 0e38 E3A01002 		mov	r0, #114
 2207 0e3c E3A02001 		str	ip, [sp, #0]
 2208 0e40 EBFFFFFE 		bl	io_i2c0_byte_transfer
 2209              		mov	r4, r0
 2210 0e44 E1A0000A 	.LVL171:
 2211 0e48 E3A01002 		.loc 4 236 0
 2212 0e4c EBFFFFFE 		bl	io_uart0_read_byte
 2213              		cmn	r0, #1
 2214 0e50 E21060FF 		.loc 4 245 0
 2215              		mov	r0, r4
 2216 0e54 0AFFFE97 		.loc 4 236 0
 2217              		beq	.L324
 2218 0e58 E59F0170 	.LVL172:
 2219 0e5c EBFFFFFE 		.loc 4 242 0
 2220              		ldr	r0, .L325+228
 2221 0e60 E59F016C 	.LVL173:
 2222 0e64 EBFFFFFE 		bl	uart0_printf
 2223              		b	.L283
 2224              	.LVL174:
 2225 0e68 EBFFFFFE 	.L260:
 2226 0e6c E3700001 		.loc 4 192 0
 2227 0e70 0AFFFFFC 		ldr	r0, .L325+232
 2228              	.LVL175:
 2229              		bl	uart0_printf
 2230 0e74 EBFFFFFE 		b	.L207
 2231 0e78 E3700001 	.LVL176:
 2232 0e7c 1AFFFFFC 	.L323:
 331:main.c        **** 	while(1);
 2233              	
 2234 0e80 E3A05000 		add	r5, r5, #1
 2235              		sub	r3, r3, #1
 2236 0e84 EA000001 		cmp	r5, r3
 2237              		bne	.L313
 2238              		b	.L283
 2239              	.L326:
 2240 0e88 E3540000 		.align	2
 2241 0e8c AA000011 	.L325:
 2242              		.word	.LC0
 2243              		.word	.LC1
 2244              		.word	.LC2
 2245 0e90 E3A0C000 		.word	.LC3
 2246 0e94 E1A02005 		.word	.LC4
 2247 0e98 E1A01006 		.word	.LC5
 2248 0e9c E3A03002 		.word	.LC6
 2249 0ea0 E3A00072 		.word	.LC7
 2250 0ea4 E58DC000 		.word	.LC8
 2251 0ea8 EBFFFFFE 		.word	.LC9
 2252 0eac E1A04000 		.word	.LC10
 2253              		.word	.LC18
 2254              		.word	.LC20
 2255 0eb0 EBFFFFFE 		.word	.LC57
 2256 0eb4 E3700001 		.word	.LC16
 2257              		.word	.LC17
 2258 0eb8 E1A00004 		.word	.LC21
 2259              		.word	.LC11
 2260 0ebc 0AFFFFF1 		.word	.LC13
 2261              		.word	.LC54
 2262              		.word	.LC55
 2263 0ec0 E59F0110 		.word	.LC19
 2264              		.word	.LC56
 2265 0ec4 EBFFFFFE 		.word	.LC14
 2266 0ec8 EAFFFF26 		.word	.LC15
 2267              		.word	.LC31
 2268              		.word	.LC32
 2269              		.word	.LC33
 2270 0ecc E59F0108 		.word	.LC22
 2271              		.word	.LC26
 2272 0ed0 EBFFFFFE 		.word	.LC27
 2273 0ed4 EAFFFE20 		.word	.LC23
 2274              		.word	.LC24
 2275              		.word	.LC25
 2276              		.word	.LC34
 2277 0ed8 EBFFFFFE 		.word	.LC35
 2278              		.word	.LC36
 2279 0edc E3A03801 		.word	.LC37
 2280 0ee0 E2855001 		.word	.LC38
 2281 0ee4 E2433001 		.word	.LC39
 2282 0ee8 E1550003 		.word	.LC40
 2283 0eec 1AFFFFE7 		.word	.LC41
 2284 0ef0 EAFFFF1C 		.word	.LC42
 2285              		.word	.LC43
 2286              		.word	.LC44
 2287              		.word	.LC45
 2288 0ef4 00000000 		.word	.LC46
 2289 0ef8 0000004C 		.word	.LC47
 2290 0efc 00000094 		.word	.LC48
 2291 0f00 000000DC 		.word	.LC49
 2292 0f04 00000124 		.word	.LC50
 2293 0f08 0000016C 		.word	.LC51
 2294 0f0c 000001B4 		.word	.LC52
 2295 0f10 00000220 		.word	.LC53
 2296 0f14 00000258 		.word	.LC28
 2297 0f18 000002BC 		.word	.LC29
 2298 0f1c 00000320 		.word	.LC30
 2299 0f20 000004F8 		.word	.LC58
 2300 0f24 0000055C 		.word	.LC12
 2301 0f28 00000C6C 	.LFE32:
 2303 0f30 000004D8 		.section	.debug_frame,"",%progbits
 2304 0f34 00000588 	.Lframe0:
 2305 0f38 00000370 		.4byte	.LECIE0-.LSCIE0
 2306 0f3c 00000408 	.LSCIE0:
 2307 0f40 00000BF0 		.4byte	0xffffffff
 2308 0f44 00000C20 		.byte	0x1
 2309 0f48 00000548 		.ascii	"\000"
 2310 0f4c 00000C48 		.uleb128 0x1
 2311 0f50 00000430 		.sleb128 -4
 2312 0f54 00000478 		.byte	0xe
 2313 0f58 00000744 		.byte	0xc
 2314 0f5c 00000778 		.uleb128 0xd
 2315 0f60 000007E4 		.uleb128 0x0
 2316 0f64 000005A8 		.align	2
 2317 0f68 00000650 	.LECIE0:
 2318 0f6c 00000674 	.LSFDE0:
 2319 0f70 00000608 		.4byte	.LEFDE0-.LASFDE0
 2320 0f74 00000620 	.LASFDE0:
 2321 0f78 00000640 		.4byte	.Lframe0
 2322 0f7c 00000828 		.4byte	.LFB2
 2323 0f80 00000844 		.4byte	.LFE2-.LFB2
 2324 0f84 00000864 		.align	2
 2325 0f88 000008A4 	.LEFDE0:
 2326 0f8c 000008D8 	.LSFDE2:
 2327 0f90 00000914 		.4byte	.LEFDE2-.LASFDE2
 2328 0f94 00000950 	.LASFDE2:
 2329 0f98 00000974 		.4byte	.Lframe0
 2330 0f9c 000009B0 		.4byte	.LFB3
 2331 0fa0 000009CC 		.4byte	.LFE3-.LFB3
 2332 0fa4 000009E4 		.align	2
 2333 0fa8 00000A2C 	.LEFDE2:
 2334 0fac 00000A6C 	.LSFDE4:
 2335 0fb0 00000AA4 		.4byte	.LEFDE4-.LASFDE4
 2336 0fb4 00000AC8 	.LASFDE4:
 2337 0fb8 00000B0C 		.4byte	.Lframe0
 2338 0fbc 00000B4C 		.4byte	.LFB4
 2339 0fc0 00000B78 		.4byte	.LFE4-.LFB4
 2340 0fc4 00000BA4 		.align	2
 2341 0fc8 00000BC8 	.LEFDE4:
 2342 0fcc 00000680 	.LSFDE6:
 2343 0fd0 000006BC 		.4byte	.LEFDE6-.LASFDE6
 2344 0fd4 000006FC 	.LASFDE6:
 2345 0fd8 00000C90 		.4byte	.Lframe0
 2346 0fdc 000003E4 		.4byte	.LFB5
 2347              		.4byte	.LFE5-.LFB5
 2348              		.align	2
 2711              		.4byte	.LVL14-.Ltext0
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:13     .text:00000000 io_read_gpio0_pin
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:22     .text:00000000 $a
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:39     .text:00000018 io_read_gpio0_port
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:57     .text:00000024 io_set_gpio0_pin
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:83     .text:00000040 io_clr_gpio0_pin
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:109    .text:00000064 io_toggle_gpio0_pin
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:135    .text:00000080 io_set_gpio0_port
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:155    .text:0000008c io_set_pwm
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:227    .text:00000108 io_get_pwm
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:280    .text:00000158 io_uart0_read_byte
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:302    .text:00000170 io_uart0_send_byte
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:327    .text:0000018c io_spi0_config
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:357    .text:000001b0 io_spi0_speed
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:377    .text:000001bc io_spi0_trans
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:413    .text:000001f4 io_spi0_enable
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:439    .text:00000210 io_spi0_disable
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:465    .text:00000234 io_i2c0_speed
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:498    .text:00000260 io_i2c0_byte_transfer
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:642    .text:00000390 get_syscpreg
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:657    .text:000003a0 $d
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:673    .text:000003d8 $a
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:737    .text:00000428 set_syscpreg
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:756    .text:0000043c $d
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:766    .text:0000045c $a
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:786    .text:0000047c get_cmsr
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:804    .text:00000484 set_cmsr
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:821    .text:0000048c io_enable_irq
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:841    .text:000004a0 io_disable_irq
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:861    .text:000004b4 uart0_printf
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:901    .text:000004ec uart0_scanf
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:963    .text:0000053c uart0_print_buffer
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:993    .text:00000560 long_to_hex_string
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:1063   .text:000005d0 hex_string_to_long
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:1140   .text:00000648 qbytes_to_long
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:1179   .text:00000674 delay
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:1433   .text:0000069c main
C:\Users\STNOLT~1\AppData\Local\Temp/cc4ibaaa.s:2288   .text:00000ef4 $d

NO UNDEFINED SYMBOLS
