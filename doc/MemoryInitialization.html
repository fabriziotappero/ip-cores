<html>
<title>
Memory Initialization
</title>
<body>
This file describes the contents of the memory intialization file and how to
use it for various vendor-specific tools.
<h1>Format</h1>
  Each line of the file consists of a hex address into which the values are to
  be stored and the corresponding value.  For SSBCC.9x8 these are 9-bit
  values.<br/><br/>
  The format of each line is "<tt>@%04X %03X</tt>" where the 4-digit value is
  the hex memory address and the 3-digit hex value is the 9-bit memory
  value.<br/><br/>
<h1>Xilinx <tt>data2mem</tt></h1>
  <tt>data2mem</tt> is a tool for modifying the block ram initialization
  contents of bitstreams.  Using this tool allows the micro controller assembly
  code to be modified in the bitstream without rerunning the entire build
  process.<br/><br/>
  The following illustrates how to use <tt>data2mem</tt> using
  ISE&nbsp;14.5:<br/><br/>
  <ol>
  <li>Create a <tt>BMM</tt> file named "<tt>uc.bmm</tt>" for inclusion in the
    build process:<br/><br/>
    The file should look like the following.  The text
    "<tt>top_inst/uc_inst</tt>" needs to be modified to point to your
    instantiation of the micro controller.  Sometimes
    "<tt>uc_inst/Mram_s_opcodeMemory</tt>" becomes
    "<tt>uc_inst_Mram_s_opcodeMemory</tt>"<br/><br/>
    <tt>ADDRESS_SPACE&nbsp;uc&nbsp;RAMB18&nbsp;WORD_ADDRESSING&nbsp;[0x0:0x7FF]<br/>
    &nbsp;&nbsp;BUS_BLOCK<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;top_inst/uc_inst/Mram_s_opcodeMemory&nbsp;[0:8];<br/>
    &nbsp;&nbsp;END_BUS_BLOCK;<br/>
    END_ADDRESS_SPACE;<br/></tt><br/>
    The following command can be used to verify the syntax of this <tt>BMM</tt>
    file:<br/><br/>
    <tt>&nbsp;&nbsp;data2mem&nbsp;-bm&nbsp;uc_bmm<br/></tt><br/>
    WARNING:  Using "<tt>ARCHITECTURE&nbsp;4096</tt>" on a Spartan-6 build
    produced two RAMB16's and one RAMB8, not the expected two RAMB18's.
    Changing the configuration command to "<tt>ARCHITECTURE&nbsp;2048*2</tt>"
    produced the desired results.  The following <tt>BMM</tt> extracted the two
    RAMB18 locations with the desired memory mapping:<br/><br/>
    <tt>ADDRESS_SPACE&nbsp;uc&nbsp;RAMB18&nbsp;WORD_ADDRESSING&nbsp;[0x0:0xFFF]<br/>
    &nbsp;&nbsp;BUS_BLOCK<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;top_inst/uc_inst_Mram_s_opcodeMemory_0&nbsp;[0:8];<br/>
    &nbsp;&nbsp;END_BUS_BLOCK;<br/>
    &nbsp;&nbsp;BUS_BLOCK<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;top_inst/uc_inst_Mram_s_opcodeMemory_1&nbsp;[0:8];<br/>
    &nbsp;&nbsp;END_BUS_BLOCK;<br/>
    END_ADDRESS_SPACE;<br/></tt><br/>
    Note:  For a Spartan-3A the bit indices <tt>[0:8]</tt> may need to be reversed.<br/><br/>
  <li>Add this file to the build process.<br/><br/>
    For a command-line build this is done by adding "<tt>-bm&nbsp;uc.bmm</tt>"
    to the argument list for ngdbuild.<br/><br/>
    When <tt>bitgen</tt> is run it will create a file named "<tt>uc_bd.bmm</tt>
    which will include the memory block address required to run
    <tt>data2mem</tt>.<br/><br/>
  <li>Perform the build and ensure that <tt>uc_bd.bmm</tt> has the address for
    the memory block.<br/><br/>
  <li>Run <tt>data2mem</tt> as follows, where "<tt>orig.bit</tt>" is the
    assumed name for the original bitstream generated by Xilinx' tools:<br/><br/>
    <tt>data2mem&nbsp;-bm&nbsp;uc_bd.bmm&nbsp;-bt&nbsp;orig.bit&nbsp;-bd&nbsp;uc.mem&nbsp;-o&nbsp;b&nbsp;new.bit;<br/></tt><br/>
  <li>Compare the original bitstream to the modified bitstream as follows to
    ensure this process worked.<br/><br/>
    <tt>data2mem&nbsp;-bm&nbsp;uc.bmm&nbsp;-bt&nbsp;orig.bit&nbsp;-d&nbsp;&gt;&nbsp;orig.dump;<br/>
    data2mem&nbsp;-bm&nbsp;uc.bmm&nbsp;-bt&nbsp;new.bit&nbsp;-d&nbsp;&gt;&nbsp;new.dump;<br/>
    diff&nbsp;orig.dump&nbsp;new.dump&nbsp;|&nbsp;less;<br/></tt><br/>
    The only differences other than file names and dates and such should be the
    initialization values for the memory block.<br/><br/>
    You can validate this process by using the original memory initialization
    file, in which case the above differences should be limited to the file
    name, data, etc., but not the memory contents.<br/><br/>
  </ol>
  If you didn't include the <tt>BMM</tt> file in the build process you can use
  <tt>fpga_editor</tt> to get the memory names and memory locations.  The
  command to invoke it is:<br/><br/>
  <tt>&nbsp;&nbsp;fpga_editor&nbsp;-r&nbsp;file.ncd&nbsp;file.pcf<br/></tt><br/>
  Then, under "<tt>Name&nbsp;Filter</tt>" type "<tt>*opcodeMemory*</tt>" and hit
  the <tt>ENTER</tt> key.
<h1>Xilinx <tt>Vivado</tt></h1>
  As of this writing, Xilinx' Vivado does not have clean non-SDK support for
  generating the files required to modify the processor instruction memory.
  However, the TCL scripting language can be used for the following work-around
  to this problem:
  <ol>
  <li>Determine the name of the memory.<br/><br/>
    The following commands lists the names of all the block rams.  This
    obviously needs to be done after place and route.<br/><br/>
    <tt>join [get_cells -hierarchical -filter { LOC =~ "RAMB*" }] "\n";<br/></tt><br/>
    or<br/><br/>
    <tt>join [filter [get_cells -hierarchical] { BEL =~ "RAMB*" }] "\n"<br/></tt><br/>
    Alternatively, the following command lists the names of the block rams, the
    type of the block ram, and their locations:<br/><br/>
    <tt>foreach a [filter [get_cells -hierarchical] { BEL =~ "RAMB*" }] {
      puts "$a [lindex [report_property -return_string $a BEL] 7] [lindex
      [report_property -return_string $a LOC] 7]"; }<br/></tt><br/>
    Any of these can be included in the build script or can be cut and pasted
    into the TCL console in the GUI after place and route.<br/><br/>
    Note:  The "<tt>list_property_value</tt>" seems to be more natural to use
    than the "<tt>[lindex&nbsp;...</tt>" commands, but can only be used for
    enumerated types, i.e., not for <tt>BEL</tt> and <tt>LOC</tt>
    properties.<br/><br/>
    </li>
  <li>Once you've identified the name(s) of the memories, add the following
    command to the build script or use it on a checkpoint.  Here,
    uc/inst/s_PC_reg_rep was the single memory in the micro controller.<br/><br/>
    <tt>foreach&nbsp;memName&nbsp;[list&nbsp;"uc/inst/s_PC_reg_rep"] {<br/>
    &nbsp;&nbsp;set&nbsp;memBel&nbsp;[lindex&nbsp;[report_property&nbsp;-return_string&nbsp;[get_cells&nbsp;$memName]&nbsp;BEL]&nbsp;7];<br/>
    &nbsp;&nbsp;set&nbsp;memLoc&nbsp;[lindex&nbsp;[report_property&nbsp;-return_string&nbsp;[get_cells&nbsp;$memName]&nbsp;LOC]&nbsp;7];<br/>
    &nbsp;&nbsp;puts "MYBMMINFO:&nbsp;$memName&nbsp;$memBel&nbsp;$memLoc]";<br/>
    }<br/></tt><br/>
    This should add lines starting with "<tt>MYBMMINFO:</tt>" to the Vivado log
    file with each memory name, type, and location.<br/><br/>
    Note:  If the processor uses more than one block ram, simply append the name
    to the "<tt>list</tt>" in this TCL script.<br/><br/>
    </li>
  <li>Use the following <tt>gawk</tt> script or similar to generate a
    <tt>BMM</tt> file from the "<tt>MYBMMINFO:</tt>" lines.  Here, the
    "<tt>vivado.log</tt>" is the Vivado log file and "<tt>build-bmm</tt> is the
    name of this file.<br/><br/>
    <tt>#!/bin/bash<br/>
    #<br/>
    #&nbsp;Generate&nbsp;a&nbsp;BMM&nbsp;file&nbsp;for&nbsp;the&nbsp;micro&nbsp;controller&nbsp;from&nbsp;the&nbsp;MYBMMINFO&nbsp;lines&nbsp;in&nbsp;the<br/>
    #&nbsp;Vivado&nbsp;log&nbsp;file.<br/>
    #<br/>
    #&nbsp;Usage:&nbsp;&nbsp;./build-bmm<br/>
    <br/>
    gawk&nbsp;--&nbsp;'<br/>
    BEGIN&nbsp;{<br/>
    &nbsp;&nbsp;nMemories&nbsp;=&nbsp;0;<br/>
    &nbsp;&nbsp;memName[nMemories++]&nbsp;=&nbsp;"uc/inst/s_PC_reg_rep";<br/>
    }<br/>
    /^MYBMMINFO:/&nbsp;{&nbsp;bel[$2]&nbsp;=&nbsp;$3;&nbsp;loc[$2]&nbsp;=&nbsp;$4;&nbsp;}<br/>
    END&nbsp;{<br/>
    &nbsp;&nbsp;for&nbsp;(ix=0;&nbsp;ix&lt;nMemories;&nbsp;++ix)<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!(memName[ix]&nbsp;in&nbsp;bel))&nbsp;{<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("FATAL&nbsp;ERROR:&nbsp;&nbsp;MYBMMINFO&nbsp;record&nbsp;not&nbsp;found&nbsp;for&nbsp;\"%s\"\n",&nbsp;memName)&nbsp;&gt;&nbsp;"/dev/stderr";<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit&nbsp;1;<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    &nbsp;&nbsp;memType&nbsp;=&nbsp;"";<br/>
    &nbsp;&nbsp;for&nbsp;(ix=0;&nbsp;ix&lt;nMemories;&nbsp;++ix)&nbsp;{<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;split(loc[memName[ix]],splitLoc,"_");<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(memType&nbsp;==&nbsp;"")&nbsp;{<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memType&nbsp;=&nbsp;splitLoc[1];<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(memType&nbsp;=&nbsp;"RAMB18")&nbsp;L&nbsp;=&nbsp;2048;<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(memType&nbsp;=&nbsp;"RAMB36")&nbsp;L&nbsp;=&nbsp;4096;<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;*=&nbsp;nMemories;<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("ADDRESS_SPACE&nbsp;uc&nbsp;%s&nbsp;WORD_ADDRESSING&nbsp;[0x0:0x%x]\n",memType,L-1);<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(splitLoc[1]&nbsp;!=&nbsp;memType)&nbsp;{<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Inconsistent&nbsp;memory&nbsp;types:&nbsp;&nbsp;%s&nbsp;is&nbsp;%s&nbsp;instead&nbsp;of&nbsp;%s\n",memName[ix],splitLoc[1],memType)&nbsp;>&nbsp;"/dev/stderr";<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit&nbsp;1;<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;BUS_BLOCK\n");<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;%s&nbsp;[8:0]&nbsp;PLACED&nbsp;=&nbsp;%s;\n",memName[ix],splitLoc[2]);<br/>
    &nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;END_BUS_BLOCK;\n");<br/>
    &nbsp;&nbsp;}<br/>
    &nbsp;&nbsp;printf("END_ADDRESS_SPACE;\n");<br/>
    }<br/>
    '&nbsp;vivado.log&nbsp;&gt;&nbsp;build_uc.bmm<br/></tt><br/>
    </li>
  <li>Update the contents of the bitstream file as follows.  Here,
    <tt>build.bit</tt> is the original bitstream and <tt>build_uc.bit</tt> is
    the bitstream updated with the new micro controller instructions.<br/><br/>
    <tt>data2mem&nbsp;-bm&nbsp;build_uc.bmm&nbsp;-bt&nbsp;build.bit&nbsp;-bd&nbsp;uc/uc.mem&nbsp;-o&nbsp;b
    build_uc.bit<br/></tt><br/>
    Alternatively, use something like the following as an "<tt>update_uc</tt>"
    script file:<br/><br/>
    <tt>#!/bin/bash<br/>
    #<br/>
    #&nbsp;Update&nbsp;the&nbsp;micro&nbsp;controller&nbsp;instruction&nbsp;memory&nbsp;in&nbsp;the&nbsp;BIT&nbsp;file.<br/>
    #<br/>
    #&nbsp;Usage:&nbsp;&nbsp;./update-uc<br/>
    <br/>
    if&nbsp;test&nbsp;!&nbsp;-f&nbsp;build_uc.bmm&nbsp;-o&nbsp;vivado.log&nbsp;-nt&nbsp;build_uc.bmm;&nbsp;then<br/>
    &nbsp;&nbsp;./build-bmm&nbsp;||&nbsp;{&nbsp;echo&nbsp;"build-bmm&nbsp;failed"&nbsp;>&nbsp;/dev/stderr;&nbsp;exit&nbsp;1;&nbsp;}<br/>
    fi<br/>
    <br/>
    (&nbsp;cd&nbsp;uc;&nbsp;ssbcc&nbsp;-q&nbsp;--define-clog2&nbsp;uc.9x8&nbsp;)&nbsp;\<br/>
    ||&nbsp;{&nbsp;echo&nbsp;"ssbcc&nbsp;failed"&nbsp;>&nbsp;/dev/stderr;&nbsp;exit&nbsp;1;&nbsp;}<br/>
    <br/>
    data2mem&nbsp;-bm&nbsp;build_uc.bmm&nbsp;-bt&nbsp;build.bit&nbsp;-bd&nbsp;uc/uc.mem&nbsp;-o&nbsp;b&nbsp;build_uc.bit&nbsp;\<br/>
    ||&nbsp;{&nbsp;echo&nbsp;"data2mem&nbsp;failed"&nbsp;>&nbsp;/dev/stderr;&nbsp;exit&nbsp;1;&nbsp;}<br/></tt><br/>
    </li>
  </ol>
  Note:  If you want to use these procedures to identify the memories after
  you've run Vivado, you must include a "<tt>write_checkpoint</tt>" command in
  your TCL script.  For example, include the following command after
  "<tt>write_bitstream&nbsp;-force&nbsp;build.bit</tt>"<br/><br/>
  <tt>write_checkpoint&nbsp;-force&nbsp;build;<br/></tt><br/>
  and then use the following command in a subsequent Vivado session to open the
  checkpoint:<br/><br/>
  <tt>read_checkpoint&nbsp;build;<br/></tt><br/>
  Once these are done you can examine the memory names and so forth.<br/><br/>
</body>
</html>
