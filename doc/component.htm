<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<META name="GENERATOR" content="IBM WebSphere Studio Homepage Builder Version 9.0.2.0 for Windows">
<META http-equiv="Content-Style-Type" content="text/css">
<TITLE></TITLE>
</HEAD>
<BODY>
<P><B>2.2 Component Design</B><BR>
<B>2.2.1 ALU</B><BR>
</P>
<P>No sequential logic. Very simple. </P>
<TABLE border="1">
  <TBODY>
    <TR>
      <TH width="28" height="14" align="left">
      <PRE>`include &quot;define.h&quot;
//Apr.14.2005  Stratix 2 workaround Quartus 4.1/4.2 
//Feb.25.2005 Verilog2001 Style
//Jan.20.2005 implict event list
//Jun.14.2004 Initial Version
//Jul.4.2004 sensibity list bug fix
//Jul.5.2004 less area version

module substruct (input [31:0] a,b,
                  output [31:0] c);
       assign c=a+~b+1;//NG Quartus 4.1/4.2 a-b Why ? I do not know.
endmodule

module alu (input [31:0] a,b,
            output reg [31:0] alu_out,
            input [3:0]        alu_func);
                
            wire [31:0] c;
                                

parameter   [3:0] alu_nop                 =4'b0000,
                  alu_add                 =4'b0001,
                  alu_sub                 =4'b0010,
                  alu_less_than_unsigned  =4'b0101, //Jul.5.2004
                  alu_less_than_signed    =4'b0100, //Jul.5.2004
                  alu_OR                  =4'b0011,
                  alu_AND                 =4'b0110,
                  alu_XOR                 =4'b0111,
                  alu_NOR =4'b1000;
  
        reg [32:0] sum;

        always @* begin //
                case (alu_func)
                        alu_nop       : alu_out=32'h0000;
                        alu_add        : alu_out=a+b;
                        alu_sub        : alu_out=c;//Apr.14.2005 NG a-b Quartus 4.1/4.2
                        alu_OR         : alu_out=a | b;
                        alu_AND        : alu_out=a &amp; b;
                        alu_XOR        : alu_out=a ^ b;
                        alu_NOR        : alu_out=~(a | b);
                        alu_less_than_unsigned : alu_out=a &lt; b;//Jun.29.2004
                        alu_less_than_signed: begin 
                                                 sum={a[31],a}+~{b[31],b}+33'h0_0000_0001;//Apr.14.2005 1'b1;//Important 33'h0_0000_000 :a-b                                                                      $signed(a) &gt; $signed(b);
                                                 alu_out={31'h0000_0000,sum[32]};//{31'h0000_0000,sum[32]}; 
                                               end                      
                        default : alu_out=32'h0000_0000;


                endcase
        end

                substruct sub(a,b,c);

endmodule




</PRE>
      </TH>
    </TR>
  </TBODY>
</TABLE>
<P><B>2.2.2 Shifter</B><BR>
</P>
<P>No sequential logic. Very simple.</P>
<TABLE border="1">
  <TBODY>
    <TR>
      <TH width="28" height="14" align="left">
      <PRE>//Jul.5.2004 redushift_oute shift_outritishift_outal path shift_outell
//Apr.5.2005 always @(*)
//Apr.8.2005 rewritten using verilog2001 shift_outoding style
`include &quot;define.h&quot;
module 
shifter(input [31:0] a,
        output reg [31:0] shift_out,
        input [1:0] shift_func,
        input [4:0] shift_amount);
        
   localparam [1:0] shift_left=`SHIFT_LEFT,
                    shift_right_unsigned=`SHIFT_RIGHT_UNSIGNED,
                    shift_right_signed=`SHIFT_RIGHT_SIGNED;

        always @ (*) begin //
                 if (!shift_func[1]  ) begin
                        case (shift_amount[4:0] )
                                5'b00000: shift_out=a;
                                5'b00001: shift_out={a[30:0],1'b0};
                                5'b00010: shift_out={a[29:0],2'b00};
                                5'b00011: shift_out={a[28:0],3'b000};
                                5'b00100: shift_out={a[27:0],4'b0000};
                                5'b00101: shift_out={a[26:0],5'b0_0000};
                                5'b00110: shift_out={a[25:0],6'b00_0000};
                                5'b00111: shift_out={a[24:0],7'b000_0000};
                                5'b01000: shift_out={a[23:0],8'b0000_0000};
                                5'b01001: shift_out={a[22:0],9'b0_0000_0000};
                                5'b01010: shift_out={a[21:0],10'b00_0000_0000};
                                5'b01011: shift_out={a[20:0],11'b000_0000_0000};
                                5'b01100: shift_out={a[19:0],12'b0000_0000_0000};
                                5'b01101: shift_out={a[18:0],13'b0_0000_0000_0000};
                                5'b01110: shift_out={a[17:0],14'b00_0000_0000_0000};
                                5'b01111: shift_out={a[16:0],15'b000_0000_0000_0000};
                                5'b10000: shift_out={a[15:0],16'b0000_0000_0000_0000};
                                5'b10001: shift_out={a[14:0],16'b0000_0000_0000_0000,1'b0};
                                5'b10010: shift_out={a[13:0],16'b0000_0000_0000_0000,2'b00};
                                5'b10011: shift_out={a[12:0],16'b0000_0000_0000_0000,3'b000};
                                5'b10100: shift_out={a[11:0],16'b0000_0000_0000_0000,4'b0000};
                                5'b10101: shift_out={a[10:0],16'b0000_0000_0000_0000,5'b0_0000};
                                5'b10110: shift_out={a[9:0],16'b0000_0000_0000_0000,6'b00_0000};
                                5'b10111: shift_out={a[8:0],16'b0000_0000_0000_0000,7'b000_0000};
                                5'b11000: shift_out={a[7:0],16'b0000_0000_0000_0000,8'b0000_0000};
                                5'b11001: shift_out={a[6:0],16'b0000_0000_0000_0000,9'b0_0000_0000};
                                5'b11010: shift_out={a[5:0],16'b0000_0000_0000_0000,10'b00_0000_0000};
                                5'b11011: shift_out={a[4:0],16'b0000_0000_0000_0000,11'b000_0000_0000};
                                5'b11100: shift_out={a[3:0],16'b0000_0000_0000_0000,12'b0000_0000_0000};
                                5'b11101: shift_out={a[2:0],16'b0000_0000_0000_0000,13'b0_0000_0000_0000};
                                5'b11110: shift_out={a[1:0],16'b0000_0000_0000_0000,14'b00_0000_0000_0000};
                                5'b11111: shift_out={a[0],16'b0000_0000_0000_0000,15'b000_0000_0000_0000};
                        endcase
                end else if (shift_func==`SHIFT_RIGHT_UNSIGNED) begin
                        case (shift_amount)
                                5'b00000: shift_out=a;
                                5'b00001: shift_out={1'b0,a[31:1]};
                                5'b00010: shift_out={2'b00,a[31:2]};
                                5'b00011: shift_out={3'b000,a[31:3]};
                                5'b00100: shift_out={4'b0000,a[31:4]};
                                5'b00101: shift_out={5'b0_0000,a[31:5]};
                                5'b00110: shift_out={6'b00_0000,a[31:6]};
                                5'b00111: shift_out={7'b000_0000,a[31:7]};
                                5'b01000: shift_out={8'b0000_0000,a[31:8]};
                                5'b01001: shift_out={9'b0_0000_0000,a[31:9]};
                                5'b01010: shift_out={10'b00_0000_0000,a[31:10]};
                                5'b01011: shift_out={11'b000_0000_0000,a[31:11]};                       
                                5'b01100: shift_out={12'b0000_0000_0000,a[31:12]};
                                5'b01101: shift_out={13'b0_0000_0000_0000,a[31:13]};                                    
                                5'b01110: shift_out={14'b00_0000_0000_0000,a[31:14]};
                                5'b01111: shift_out={15'b000_0000_0000_0000,a[31:15]};          
                                5'b10000: shift_out={16'b0000_0000_0000_0000,a[31:16]};
                                5'b10001: shift_out={16'b0000_0000_0000_0000,1'b0,a[31:17]};
                                5'b10010: shift_out={16'b0000_0000_0000_0000,2'b00,a[31:18]};
                                5'b10011: shift_out={16'b0000_0000_0000_0000,3'b000,a[31:19]};
                                5'b10100: shift_out={16'b0000_0000_0000_0000,4'b0000,a[31:20]};
                                5'b10101: shift_out={16'b0000_0000_0000_0000,5'b0_0000,a[31:21]};
                                5'b10110: shift_out={16'b0000_0000_0000_0000,6'b00_0000,a[31:22]};
                                5'b10111: shift_out={16'b0000_0000_0000_0000,7'b000_0000,a[31:23]};
                                5'b11000: shift_out={16'b0000_0000_0000_0000,8'b0000_0000,a[31:24]};
                                5'b11001: shift_out={16'b0000_0000_0000_0000,9'b0_0000_0000,a[31:25]};
                                5'b11010: shift_out={16'b0000_0000_0000_0000,10'b00_0000_0000,a[31:26]};
                                5'b11011: shift_out={16'b0000_0000_0000_0000,11'b000_0000_0000,a[31:27]};                       
                                5'b11100: shift_out={16'b0000_0000_0000_0000,12'b0000_0000_0000,a[31:28]};
                                5'b11101: shift_out={16'b0000_0000_0000_0000,13'b0_0000_0000_0000,a[31:29]};                                    
                                5'b11110: shift_out={16'b0000_0000_0000_0000,14'b00_0000_0000_0000,a[31:30]};
                                5'b11111: shift_out={16'b0000_0000_0000_0000,15'b000_0000_0000_0000,a[31:31]};          
                        endcase
                end else begin// SHIFT_RIGHT_SIGNED
                        case (shift_amount)     
                                5'b00000: shift_out=a;
                                5'b00001: shift_out={a[31],a[31:1]};
                                5'b00010: shift_out={{2{a[31]}},a[31:2]};
                                5'b00011: shift_out={{3{a[31]}},a[31:3]};
                                5'b00100: shift_out={{4{a[31]}},a[31:4]};
                                5'b00101: shift_out={{5{a[31]}},a[31:5]};
                                5'b00110: shift_out={{6{a[31]}},a[31:6]};
                                5'b00111: shift_out={{7{a[31]}},a[31:7]};
                                5'b01000: shift_out={{8{a[31]}},a[31:8]};
                                5'b01001: shift_out={{9{a[31]}},a[31:9]};
                                5'b01010: shift_out={{10{a[31]}},a[31:10]};
                                5'b01011: shift_out={{11{a[31]}},a[31:11]};                     
                                5'b01100: shift_out={{12{a[31]}},a[31:12]};
                                5'b01101: shift_out={{13{a[31]}},a[31:13]};                                     
                                5'b01110: shift_out={{14{a[31]}},a[31:14]};
                                5'b01111: shift_out={{15{a[31]}},a[31:15]};             
                                5'b10000: shift_out={{16{a[31]}},a[31:16]};
                                5'b10001: shift_out={{17{a[31]}},a[31:17]};
                                5'b10010: shift_out={{18{a[31]}},a[31:18]};
                                5'b10011: shift_out={{19{a[31]}},a[31:19]};
                                5'b10100: shift_out={{20{a[31]}},a[31:20]};
                                5'b10101: shift_out={{21{a[31]}},a[31:21]};
                                5'b10110: shift_out={{22{a[31]}},a[31:22]};
                                5'b10111: shift_out={{23{a[31]}},a[31:23]};
                                5'b11000: shift_out={{24{a[31]}},a[31:24]};
                                5'b11001: shift_out={{25{a[31]}},a[31:25]};
                                5'b11010: shift_out={{26{a[31]}},a[31:26]};
                                5'b11011: shift_out={{27{a[31]}},a[31:27]};                     
                                5'b11100: shift_out={{28{a[31]}},a[31:28]};
                                5'b11101: shift_out={{29{a[31]}},a[31:29]};                                     
                                5'b11110: shift_out={{30{a[31]}},a[31:30]};
                                5'b11111: shift_out={{31{a[31]}},a[31:31]};             
                        endcase
                end
        end






endmodule</PRE>
      </TH>
    </TR>
  </TBODY>
</TABLE>
<P><B>2.2.3 mul_div_module</B></P>
<P>&nbsp;Multiplier:</P>
<UL>
  <LI>singed/unsigned 32bits input
  <LI>singed/unsigned 64 bits output
  <LI>scalable 2-32clocks processing time
</UL>
<P>Divider</P>
<UL>
  <LI>signed/unsigned 32bits input
  <LI>signed/unsigned 32bits quotient and remainder
  <LI>fixed 32 clocks processing time
</UL>
<P>Starts calculation by &quot;mul_div_enable&quot; signal, &quot;stop_state&quot;
signal becomes high during calculation.<BR>
</P>
<TABLE border="1">
  <TBODY>
    <TR>
      <TH width="28" height="14" align="left">
      <PRE>//Jun.2.2004
//Jun.27.2004
//Jun.28.2004
//Jun.30.2004 mulfunc output bug fix
//                         still 16x16 sign extension
//Jul.2.2004  mul 32x32=&gt;64bit w/ w/o sign
//Jul.2.2004  address MUL_WIDTH==1
//Jul.4.2004  input critical path : =&gt; add carry_ff;
//Jul.5.2004                             :=&gt; less fanout 
//Jul.13.2004 signed mul bug fix
//Jul.15.2004 32/32 div 
//Jul.16.2004 diet
//Jul.17.2004 add `ifdef less path delay for interface port
//Apr.7.2005 ADDRESS to XILINX Specific problem 
//Apr.14.2005 Add Stratix2

// mul/div module

// a[31:0] /b[31:0]  =&gt;  
//   mul_div_out[15:0]  &lt;=a/b
//   mul_div_out[31:16] &lt;=a%b
// No detection of overflow
// Algorithm
//  answer_reg = (answer_reg &lt;&lt; 1);
// multout_reg&lt;={sum,a_reg[31]};
//    if (multout_reg &gt;= b_reg) {
//       answer_reg += 1;
//       multout_reg -= b_reg;
//    }
//    a_reg &lt;= a_reg &lt;&lt; 1;
`include &quot;define.h&quot;
module mul_div(clock,sync_reset,a,b,mul_div_out,mul_div_sign,mul_div_word,mul_div_mode,state,stop_state,mul_div_enable,lohi);
`ifdef RAM4K

         `ifdef XILINX
                parameter MUL_WIDTH=16;//Must be 2,4,8,16 2=&gt; less area less speed 16=&gt; greater area but faster
                parameter MUL_STATE_MSB=2;//should be 32/MUL_WIDTH-1+1;
                // XILINX fails using ISE7.1 if MUL_WIDTH==1,2
                // if MULWIDTH==1 synthesis is possible but post synthesis simulation fails
                // if MULWIDTH==2 synthesis fails;
                // MUL_WIDTH==16 shows good.

         `else
                        parameter MUL_WIDTH=1;//Must be 2,4,8,16 2=&gt; less area less speed 16=&gt; greater area but faster
                        parameter MUL_STATE_MSB=32;//should be 32/MUL_WIDTH-1+1;
         `endif
`else
        `ifdef XILINX
                parameter MUL_WIDTH=16;//Must be 2,4,8,16 2=&gt; less area less speed 16=&gt; greater area but faster
                parameter MUL_STATE_MSB=2;//should be 32/MUL_WIDTH-1+1;
                // XILINX fails using ISE7.1 if MUL_WIDTH==1,2
                // if MULWIDTH==1 synthesis is possible but post synthesis simulation fails
                // if MULWIDTH==2 synthesis fails;
                // MUL_WIDTH==16 shows good.

         `else
                `ifdef Stratix2
                                        parameter MUL_WIDTH=16;//Must be 2,4,8,16 2=&gt; less area less speed 16=&gt; greater area but faster
                                        parameter MUL_STATE_MSB=2;//should be 32/MUL_WIDTH-1+1;
                        `else 
                                        parameter MUL_WIDTH=1;//Must be 2,4,8,16 2=&gt; less area less speed 16=&gt; greater area but faster
                                        parameter MUL_STATE_MSB=32;//should be 32/MUL_WIDTH-1+1;
                        `endif
                `endif
`endif
        input clock,sync_reset;
        input [31:0] a,b;
        input [7:0] state;
        input lohi;
        input mul_div_enable,mul_div_sign,mul_div_word,mul_div_mode;
        output stop_state;
        output [31:0] mul_div_out;
        
        reg [31:0] a_reg;
        reg [31:0] b_reg;
        reg [31:0] answer_reg;
        
        reg stop_state_reg;// For state control
        reg [5:0] counter;
        reg mul_div_sign_ff,mul_div_mode_ff;
        reg a31_latch,b31_latch;
        reg breg31;
//mult64
        wire [63:0] ab62={1'b0,a_reg[31]*breg31,62'h0};//Jul.5.2004
        wire [63:0] shift_a31=mul_div_sign_ff  ? ~{2'b0,a_reg[30:0],31'h0}+1'b1: {2'b0,a_reg[30:0],31'h0} ;//Jul.13.2004 Jul.2.2004
        wire [63:0] shift_b31=mul_div_sign_ff  ? ~{2'b0,b_reg[30:0],31'h0}+1'b1: {2'b0,b_reg[30:0],31'h0};//Jul.13.2004 Jul.2.2004

        wire [30:0] init_lower  =breg31*shift_a31[30:0] +a_reg[31]*shift_b31[30:0]+ab62[30:0];//Jul.5.2004
        wire [63:31] init_upper=breg31*shift_a31[63:31]+a_reg[31]*shift_b31[63:31]+ab62[63:31];//+carry;Jul.5.2004
        wire [63:0] init_val={init_upper,init_lower};
        wire [MUL_WIDTH+30    :0] mult32x4out_temp=a_reg[30:0]*b_reg[MUL_WIDTH-1:0];//Jul.5.2004                
        wire [MUL_WIDTH+31 :0] mult32x4out={1'b0,mult32x4out_temp};
        reg  [63:0] mult64_reg;
        reg  [31:0] multout_reg;
        wire [63:0] mult64_out;
        wire [63:0] mult64=a_reg* b_reg;
        reg  [MUL_WIDTH+31-1+1 :0] mult32x4out_reg;


        wire finish_operation;
        wire pre_stop;
        wire [32:0] sum;
        wire [31:0] answer_inc;
        wire [31:0] aminus=-a;
        wire [31:0] div_out,div_out_tmp;
        
        
        wire mul_div_mode_w;
        reg mul_state_reg;
        reg div_msb_ff; 

        assign mul_div_mode_w=pre_stop ? mul_div_mode: mul_div_mode_ff;

`ifdef RAM4K
//less area
                
        assign mul_div_out=!lohi ?  !mul_div_mode_ff ?  mult64_out[31:0] : div_out  : 
                                          !mul_div_mode_ff ? mult64_out[63:32]  :       div_out;//Jul.16.2004   

        assign div_out_tmp=!lohi ? answer_reg: {div_msb_ff,multout_reg[31:1]};
        assign div_out= (!lohi &amp;&amp; (a31_latch ^ b31_latch)  &amp;&amp;  mul_div_sign_ff) || 
                                           (lohi &amp;&amp; mul_div_sign_ff &amp;&amp; a31_latch) ? ~div_out_tmp+1'b1 : div_out_tmp;

`else

// faster
        reg [31:0] div_out_multout_latch,answer_reg_latch;//

        assign mul_div_out=!lohi ?  !mul_div_mode_ff ? mult64_out[31:0]   : answer_reg_latch  : 
                                    !mul_div_mode_ff ? mult64_out[63:32]  : div_out_multout_latch;//Jul.16.2004 
         


        always @(posedge clock) begin
                if ( (a31_latch ^ b31_latch)  &amp;&amp;  mul_div_sign_ff) 
                        answer_reg_latch&lt;=~answer_reg+1'b1;
                else    answer_reg_latch&lt;= answer_reg;

                if  ( mul_div_sign_ff &amp;&amp; a31_latch) 
                        div_out_multout_latch&lt;=~{div_msb_ff,multout_reg[31:1]}+1'b1;
                else div_out_multout_latch&lt;={div_msb_ff,multout_reg[31:1]};
                

        end
                

`endif

//mul64
        //mul_state 
        always @(posedge clock) begin
                 breg31&lt;=b[31];
        end
        always @(posedge clock) begin
                mult32x4out_reg&lt;=mult32x4out;
        end

//Jul.16.2004
        always @(posedge clock) begin
                if (sync_reset) mul_state_reg&lt;=0;
                else if (pre_stop &amp;&amp; mul_div_mode_w==`MUL_DIV_MUL_SEL ) mul_state_reg&lt;=1;
                else if (finish_operation) mul_state_reg&lt;=0; 
        end

        //mult64_reg multout_reg
        always @(posedge clock) begin
                if (mul_state_reg &amp;&amp; counter==0 )begin
                                mult64_reg&lt;=init_val;//Jul.13.2004 Jul.5.2004 Jul.4.2004
                end
                else 
                        if (mul_state_reg) begin  
                                                {mult64_reg,multout_reg[31:31-MUL_WIDTH+1]}&lt;={{MUL_WIDTH {1'b0}},mult64_reg+mult32x4out_reg};
                                                multout_reg[31-MUL_WIDTH:0] &lt;=multout_reg[31:MUL_WIDTH];
        
                //Division
                end  else if (pre_stop &amp;&amp; counter==0 ) multout_reg&lt;=0; //First
                else if (mul_div_mode_ff &amp;&amp; stop_state_reg ) begin
                                if (sum[32]==1'b0) begin //if (a_reg &gt;=b_reg)
                                        if (finish_operation) div_msb_ff&lt;=sum[31];
                                                        multout_reg&lt;={sum,a_reg[31]};
                                end else begin 
                                        if (finish_operation) div_msb_ff&lt;=multout_reg[31];
                                        multout_reg[0]&lt;=a_reg[31];
                                        multout_reg[31:1] &lt;=multout_reg[30:0];
                                end
                end
        end

        assign mult64_out={mult64_reg[31:0],multout_reg[31:0]};
//input FFs

        always @(posedge clock) begin
                if (sync_reset) begin
                        mul_div_sign_ff&lt;=0;
                        mul_div_mode_ff&lt;=0;


                end else if (pre_stop) begin
                        mul_div_sign_ff&lt;=mul_div_sign;
                        a31_latch&lt;=a[31];
                        b31_latch&lt;=b[31];                       
                        mul_div_mode_ff&lt;=mul_div_mode;
                end
        end



//state_machine
        assign pre_stop=mul_div_enable ;
        assign finish_operation=(mul_div_mode_ff &amp;&amp; counter==32) || (mul_state_reg &amp;&amp; counter==MUL_STATE_MSB) ;//Jul.2.2004
                        

        always @(posedge clock) begin
                if (sync_reset) stop_state_reg &lt;=0;
                else if (pre_stop &amp;&amp; !stop_state_reg )  stop_state_reg&lt;=1;
                else if (stop_state_reg &amp;&amp; finish_operation) stop_state_reg&lt;=0;  
        end

        assign stop_state=stop_state_reg;

        always @(posedge clock) begin
                if (sync_reset) counter &lt;=0;
                else if (!stop_state_reg) counter &lt;=0;
                else if (stop_state_reg ) counter &lt;=counter+1;
        end

//a_reg
        always @(posedge clock) begin
                if(mul_div_mode_w==`MUL_DIV_MUL_SEL &amp;&amp; pre_stop)  a_reg &lt;=a;//
                        else if(mul_div_mode_w !=`MUL_DIV_MUL_SEL )begin//
                        if (!stop_state_reg &amp;&amp; !pre_stop) a_reg &lt;=a_reg;//
                        else if (pre_stop &amp;&amp; counter==0  ) begin //
                                if (mul_div_sign) begin//
                                        if (a[31])       a_reg &lt;=aminus;//
                                                        else a_reg &lt;=a;
                                end else  a_reg &lt;=a;//
                        end else begin//div 
                                                        a_reg &lt;={a_reg[30:0],1'b0};// a_reg &lt;&lt;=1;
                        end
                        
                end
        end

//b_reg
        always @(posedge clock) begin
                if (pre_stop &amp;&amp; mul_div_mode_w==`MUL_DIV_MUL_SEL )      b_reg&lt;={1'b0,b[30:0]};
                else if ( mul_state_reg) b_reg&lt;=b_reg[31:MUL_WIDTH];
                                else if( mul_div_mode_w !=`MUL_DIV_MUL_SEL) begin//
                        if (!stop_state_reg &amp;&amp; !pre_stop ) b_reg &lt;=b_reg;//
                        else if (pre_stop &amp;&amp; counter==0 ) begin //
                                if (mul_div_sign) begin//
                                        if ( b[31])  b_reg &lt;=-b[31:0];//
                                                        else  b_reg &lt;=b[31:0];//
                                end else begin
                                        b_reg &lt;=b[31:0];//
                                end
                        end else begin//div 
                                        b_reg &lt;=b_reg;//;
                        end
                end
         end

//answer_reg
        always @(posedge clock) begin

                if (mul_div_mode_w !=`MUL_DIV_MUL_SEL) begin//
                        if (!stop_state_reg &amp;&amp; !pre_stop) answer_reg &lt;=answer_reg;//
                        else if (pre_stop &amp;&amp; counter==0  ) answer_reg&lt;=0; //
                        else  begin//div 
                                if ( !sum[32] ) begin//
                                                if (finish_operation) answer_reg &lt;=answer_inc;
                                                else answer_reg &lt;={answer_inc[30:0],1'b0};   //Jun.7.2004  a_reg -= b_reg
                                end else begin
                                                if  (finish_operation ) begin
                                                        answer_reg &lt;=answer_reg;
                                         end else answer_reg &lt;={answer_reg[30:0],1'b0};   // answer_reg &lt;&lt;=1;
                                end
                        end
                end
         end


        assign sum={1'b0,multout_reg}+~{1'b0,b_reg}+1'b1;//
        assign answer_inc=answer_reg+1'b1;//Jun.7.2004

endmodule
</PRE>
      </TH>
    </TR>
  </TBODY>
</TABLE>
<P><B>2.2.4 RAM_Module</B></P>
<P>In this module,8bitsx4 dual port RAM is necessary for both Altera and Xilinx.<BR>
Dual Port makes it possible to access independently for program and data.</P>
<TABLE border="1">
  <TBODY>
    <TR>
      <TH width="28" height="14" align="left">
      <PRE>//Jun.29.2004 w0,w1,w2,w3 bug fix
//Jun.30.2004 endian bug fix
//Jul.1.2004 endian bug fix
//Apr.2.2005 Change Port Address
`include &quot;define.h&quot;
`define COMB_MOUT
`define COMB_MOUT_IR


`define NO_SIGNED_MOUT
module ram_module_altera(clock,sync_reset,IR,MOUT,Paddr,Daddr,wren,datain,access_mode,M_signed,
         uread_port,write_busy);
        input clock,sync_reset;
        input wren;
        input [31:0] datain;
        input M_signed;
        input [7:0] uread_port;
        input write_busy;//Apr.2.2005
`ifdef RAM32K

        input [14:0] Paddr,Daddr;//4KB address
        reg  [14:0] DaddrD;

  
`endif

`ifdef  RAM16K

        input [13:0] Paddr,Daddr;//4KB address
        reg  [13:0] DaddrD;


`endif

`ifdef RAM4K
        input [11:0] Paddr,Daddr;//4KB address
      reg  [11:0] DaddrD;

`endif

        output [31:0] IR;//Instrcuntion Register
        output [31:0] MOUT;//data out
        input [1:0] access_mode;

        reg [31:0] IR;
        reg [31:0] MOUT;
        reg [1:0] access_modeD;
        
        wire [7:0] a0,a1,a2,a3;
        wire [7:0] b0,b1,b2,b3;
        wire [7:0] dport0,dport1,dport2,dport3;
        wire w0,w1,w2,w3;
        wire uread_port_access=`UART_PORT_ADDRESS==Daddr;
        
        reg  uread_access_reg;

        assign dport0=datain[7:0] ;
        assign dport1=access_mode !=`BYTE_ACCESS ? datain[15:8] : datain[7:0];
        assign dport2=access_mode==`LONG_ACCESS ? datain[23:16] : datain[7:0];
        assign dport3=access_mode==`LONG_ACCESS ? datain[31:24] : 
                      access_mode==`WORD_ACCESS ? datain[15:8]  : datain[7:0];
        

`ifdef RAM32K
ram8192x8_3 ram0(.data_a(8'h00),.wren_a(1'b0),.address_a(Paddr[14:2]),
                      .data_b(dport0),.address_b(Daddr[14:2]),.wren_b(w0),.clock(clock),
                      .q_a(a0),.q_b(b0));

ram8192x8_2 ram1(.data_a(8'h00),.wren_a(1'b0),.address_a(Paddr[14:2]),
                      .data_b(dport1),.address_b(Daddr[14:2]),.wren_b(w1),.clock(clock),
                      .q_a(a1),.q_b(b1));

ram8192x8_1  ram2(.data_a(8'h00),.wren_a(1'b0),.address_a(Paddr[14:2]),
                      .data_b(dport2),.address_b(Daddr[14:2]),.wren_b(w2),.clock(clock),
                      .q_a(a2),.q_b(b2));

ram8192x8_0 ram3(.data_a(8'h00),.wren_a(1'b0),.address_a(Paddr[14:2]),
                      .data_b(dport3),.address_b(Daddr[14:2]),.wren_b(w3),.clock(clock),
                      .q_a(a3),.q_b(b3));

`endif
`ifdef  RAM16K
`ifdef ALTERA
ram4096x8_3 ram0(.data_a(8'h00),.wren_a(1'b0),.address_a(Paddr[13:2]),
                      .data_b(dport0),.address_b(Daddr[13:2]),.wren_b(w0),.clock(clock),
                      .q_a(a0),.q_b(b0));

ram4096x8_2 ram1(.data_a(8'h00),.wren_a(1'b0),.address_a(Paddr[13:2]),
                      .data_b(dport1),.address_b(Daddr[13:2]),.wren_b(w1),.clock(clock),
                      .q_a(a1),.q_b(b1));

ram4092x8_1  ram2(.data_a(8'h00),.wren_a(1'b0),.address_a(Paddr[13:2]),
                      .data_b(dport2),.address_b(Daddr[13:2]),.wren_b(w2),.clock(clock),
                      .q_a(a2),.q_b(b2));

ram4092x8_0 ram3(.data_a(8'h00),.wren_a(1'b0),.address_a(Paddr[13:2]),
                      .data_b(dport3),.address_b(Daddr[13:2]),.wren_b(w3),.clock(clock),
                      .q_a(a3),.q_b(b3));
`else
                ram1k3 ram0(.addra(Paddr[13:2]),
                      .dinb(dport0),.addrb(Daddr[13:2]),.web(w0),.clka(clock),.clkb(clock),
                      .douta(a0),.doutb(b0));
                ram1k2 ram1(.addra(Paddr[13:2]),
                      .dinb(dport1),.addrb(Daddr[13:2]),.web(w1),.clka(clock),.clkb(clock),
                      .douta(a1),.doutb(b1));
                ram1k1 ram2(.addra(Paddr[13:2]),
                      .dinb(dport2),.addrb(Daddr[13:2]),.web(w2),.clka(clock),.clkb(clock),
                      .douta(a2),.doutb(b2));
                ram1k0 ram3(.addra(Paddr[13:2]),
                      .dinb(dport3),.addrb(Daddr[13:2]),.web(w3),.clka(clock),.clkb(clock),
                      .douta(a3),.doutb(b3));
`endif
`endif

`ifdef RAM4K
ram_1k_3 ram0(.data_a(8'h00),.wren_a(1'b0),.address_a(Paddr[11:2]),
                      .data_b(dport0),.address_b(Daddr[11:2]),.wren_b(w0),.clock(clock),
                      .q_a(a0),.q_b(b0));

ram_1k_2 ram1(.data_a(8'h00),.wren_a(1'b0),.address_a(Paddr[11:2]),
                      .data_b(dport1),.address_b(Daddr[11:2]),.wren_b(w1),.clock(clock),
                      .q_a(a1),.q_b(b1));

ram_1k_1 ram2(.data_a(8'h00),.wren_a(1'b0),.address_a(Paddr[11:2]),
                      .data_b(dport2),.address_b(Daddr[11:2]),.wren_b(w2),.clock(clock),
                      .q_a(a2),.q_b(b2));

ram_1k_0 ram3(.data_a(8'h00),.wren_a(1'b0),.address_a(Paddr[11:2]),
                      .data_b(dport3),.address_b(Daddr[11:2]),.wren_b(w3),.clock(clock),
                      .q_a(a3),.q_b(b3));

`endif

        wire temp=( access_mode==`BYTE_ACCESS &amp;&amp;  Daddr[1:0]==2'b00);


        assign w3= wren &amp;&amp; 
                   (  access_mode==`LONG_ACCESS ||   
                   (  access_mode==`WORD_ACCESS &amp;&amp; !Daddr[1]    ) ||
                   (  access_mode==`BYTE_ACCESS &amp;&amp;  Daddr[1:0]==2'b00));
        assign w2= wren &amp;&amp; 
                   (  access_mode==`LONG_ACCESS ||   
                   (  access_mode==`WORD_ACCESS &amp;&amp; !Daddr[1])  ||
                   ( Daddr[1:0]==2'b01));
        assign w1= wren &amp;&amp; 
                   (  access_mode==`LONG_ACCESS ||   
                   (  access_mode==`WORD_ACCESS &amp;&amp; Daddr[1]) ||
                   (  Daddr[1:0]==2'b10));
        assign w0= wren &amp;&amp; 
                   (  access_mode==`LONG_ACCESS ||   
                   (  access_mode==`WORD_ACCESS &amp;&amp; Daddr[1]) ||
                   (  Daddr[1:0]==2'b11));


//IR

`ifdef COMB_MOUT_IR

        always @(*) IR={a3,a2,a1,a0};


`else
        always @(posedge clock) begin
                if (sync_reset)      IR &lt;=0;
                else  IR &lt;={a3,a2,a1,a0};
        
        end
`endif

        always @(posedge clock) begin
                if (access_modeD==`LONG_ACCESS) begin
                                if(uread_access_reg) begin
                                                        MOUT &lt;={23'h00_0000,write_busy,uread_port};
                                end else
                                                        MOUT &lt;={b3,b2,b1,b0};
                        
                end else if (access_modeD==`WORD_ACCESS) begin
                     case (DaddrD[1]) 
                                                1'b0: if(M_signed) MOUT &lt;={{16{b3[7]}},b3,b2};//Jul.1.2004
                                                      else MOUT &lt;={16'h0000,b3,b2};
                                                1'b1: if(M_signed) MOUT &lt;={{16{b1[7]}},b1,b0};//Jul.1.2004
                                                      else MOUT &lt;={16'h0000,b1,b0};
                     endcase
                end else  begin//BYTE ACCESSS
                        case (DaddrD[1:0]) 
                                                        2'b00:if(M_signed) MOUT &lt;={{24{b3[7]}},b3};
                                                                                else MOUT &lt;={16'h0000,8'h00,b3};
                                                2'b01:if(M_signed) MOUT &lt;={{24{b2[7]}},b2};
                                                                    else MOUT &lt;={16'h0000,8'h00,b2};
                                                        2'b10:if(M_signed) MOUT &lt;={{24{b1[7]}},b1};
                                                                          else MOUT &lt;={16'h0000,8'h00,b1};
                                                        2'b11:if(M_signed) MOUT &lt;={{24{b0[7]}},b0};
                                                                                else MOUT &lt;={16'h0000,8'h00,b0};
                        endcase
                end
        end 

        always @(posedge clock) begin
                access_modeD&lt;=access_mode;
                DaddrD&lt;=Daddr;
                uread_access_reg&lt;=uread_port_access;//Jul.7.2004
        end
endmodule

        </PRE>
      </TH>
    </TR>
  </TBODY>
</TABLE>
<P><B>2.2.5 Decode</B>r</P>
<P>Includes disassembler for debug use.<BR>
$sprintf is the same as $sformat in Verilog-2001.</P>
<TABLE border="1">
  <TBODY>
    <TR>
      <TH width="28" height="14" align="left">
      <PRE>//Jun.28.2004
//Jun.30.2004 jump bug fix
//Jul.11.2004 target special zero 
//Jan.20.2005 apply @*
`include &quot;define.h&quot;
//`define ALTERA
module decoder(clock,sync_reset,MWriteD1,RegWriteD2,A_Right_SELD1,RF_inputD2,
RF_input_addr,M_signD1,M_signD2,M_access_modeD1,M_access_modeD2,
ALU_FuncD2,Shift_FuncD2,source_addrD1,target_addrD1,IMMD2,
source_addrD2,target_addrD2,Shift_amountD2,PC_commandD1,IMMD1,IRD1,takenD3,takenD2,beqQ,bneQ,blezQ,bgtzQ,
DAddress,PC,memory_indata,MOUT,IMM,branchQQ,jumpQ,int_req,clear_int,int_address,
A_Left_SELD1,RRegSelD1,MWriteD2,NOP_Signal,mul_alu_selD2,mul_div_funcD2,
pause_out,control_state,Shift_Amount_selD2,uread_port,int_stateD1,bgezQ,bltzQ,write_busy);

        input clock,sync_reset;
        input takenD3,takenD2;
        output MWriteD1,RegWriteD2;
        output [1:0] A_Right_SELD1;
        output [1:0] RF_inputD2;
        output M_signD1,M_signD2;
        output [1:0] M_access_modeD1,M_access_modeD2;
        output [3:0] ALU_FuncD2;
        output [1:0] Shift_FuncD2;
        output [25:0] IMMD2,IMMD1;
        output [4:0] source_addrD2,target_addrD2;
        output [4:0] source_addrD1,target_addrD1,Shift_amountD2;
        output [4:0] RF_input_addr;
        output [2:0] PC_commandD1;
        output [31:0] IRD1;
        output beqQ,bneQ,blezQ,bgtzQ;
        output bgezQ,bltzQ;
        input [7:0] uread_port;
        output int_stateD1;
        input write_busy;//Apr.2.2005

`ifdef RAM4K
        input  [11:0] DAddress,PC;
        input [11:0] int_address;
`else   
        input  [25:0] DAddress,PC;
        input [25:0] int_address;
`endif


        input [31:0] memory_indata;
        output [31:0] MOUT;
        output [25:0] IMM;
        output branchQQ,jumpQ;
        input int_req;
        output clear_int;

        output  A_Left_SELD1;
        output [1:0] RRegSelD1;
        output MWriteD2;
        output NOP_Signal;
        output [1:0] mul_alu_selD2;
        output [3:0] mul_div_funcD2;
        input pause_out;
        output [7:0] control_state;
        output Shift_Amount_selD2;
//For Debug Use
        localparam [4:0] zero_=0,
                                     at_=1,
                                     v0_=2,
                                     v1_=3,
                                     a0_=4,
                                     a1_=5,
                                     a2_=6,
                                     a3_=7,
                                     t0_=8, t1_=9,t2_=10,t3_=11,t4_=12,t5_=13,t6_=14,t7_=15,
                                     s0_=16,s1_=17,s2_=18,s3_=19,s4_=20,s5_=21,s6_=22,s7_=23,t8_=24,t9_=25,
                                     k0_=26,k1_=27,gp_=28,sp_=29,s8_=30,ra_=31; 


//regsiters
        reg [31:0] IRD1;
        reg [31:0] IRD2;
        reg [1:0] RF_input_addr_selD1;
        reg [4:0] RF_input_addr;
        reg [1:0] Shift_FuncD1,Shift_FuncD2;
        reg [3:0] ALU_FuncD2;
        reg [1:0] A_Right_SELD1;
        reg [1:0] RF_inputD2,RF_inputD1;
        reg [1:0] M_access_modeD1,M_access_modeD2;
        reg M_signD1,M_signD2;
        
        reg MWriteD1,RegWriteD2,RegWriteD1,MWriteD2;
        reg [2:0] PC_commandD1;
        reg beqQ,bneQ,blezQ,bgtzQ;
        reg bltzQ,bgezQ;//Jul.11.2004
        reg branchQ,branchQQ,jumpQ;
        reg [7:0] control_state;
        reg sync_resetD1;
        reg [31:0] memory_indataD2;
        reg  A_Left_SELD1;
        reg  [1:0] RRegSelD1;
        reg takenD4,takenD5;
        reg nop_bit;
        reg [1:0] mul_alu_selD2;
        reg mul_div_funcD1;
        reg div_mode_ff;
        reg [3:0] mul_div_funcD2;
        reg excuting_flag;
        reg excuting_flagD,excuting_flagDD;
        reg Shift_Amount_selD2;
        reg int_seqD1;
//wires                                 
        wire [31:0] IR;

        wire [5:0] opecode=IR[31:26];
        wire [5:0] opecodeD1=IRD1[31:26];
        wire [5:0] opefuncD1=IRD1[5:0];
        wire [5:0] opefunc=IR[5:0];
        wire [4:0] destination_addrD1;//Apr.8.2005

        wire NOP_Signal;
        wire finish_operation;

        

        assign int_stateD1=control_state==5;

        assign IMMD2=IRD2[25:0];
        assign IMMD1=IRD1[25:0];
        assign source_addrD2=IRD2[25:21];
        assign target_addrD2=IRD2[20:16];
        assign source_addrD1=IRD1[25:21];
        assign target_addrD1=IRD1[20:16];
        assign destination_addrD1=IRD1[15:11];
        assign Shift_amountD2=IRD2[10:6];
        assign IMM=IR[25:0];

`ifdef  Veritak //Disassenblar
        reg [30*8:1] inst;
        wire [5:0] op=IR[31:26];
        wire [25:0] bra=PC+{{10{IR[15]}},IR[15:0]}*4;//+4;
        wire [4:0] rs=IR[25:21];
        wire [4:0] rt=IR[20:16];
        wire [4:0] rd=IR[15:11];
        wire [4:0] sh=IR[10:6];
        reg [5*8:1] reg_name=&quot;abcd&quot;;

     reg [30*8:1] instD1,instD2;

        function [4*8:1] get_reg_name;
                input [4:0] field;
                begin
                        case (field)
                                0: get_reg_name=&quot;$z0&quot;;
                                1: get_reg_name=&quot;$at&quot;;
                                2: get_reg_name=&quot;$v0&quot;;
                                3: get_reg_name=&quot;$v1&quot;;
                                4: get_reg_name=&quot;$a0&quot;;
                                5: get_reg_name=&quot;$a1&quot;;
                                6: get_reg_name=&quot;$a2&quot;;
                                7: get_reg_name=&quot;$a3&quot;;
                                8,9,10,11,12,13,14,15:
                                   $sprintf(get_reg_name,&quot;$t%1d&quot;,field-8);
                                16,17,18,19,20,21,22,23,24,25: $sprintf(get_reg_name,&quot;$s%1d&quot;,field-16);
                                26:get_reg_name=&quot;$k0&quot;;
                                27:get_reg_name=&quot;$k1&quot;;
                                28:get_reg_name=&quot;$gp&quot;;
                                29:get_reg_name=&quot;$sp&quot;;
                                30:get_reg_name=&quot;$s8&quot;;
                                31:get_reg_name=&quot;$ra&quot;;
                        endcase
                end
        endfunction

        always @(posedge clock) begin
                instD1&lt;=inst;
                instD2&lt;=instD1;
        end

        always @*begin:sprintf //Jan.20.2005  @ (IR,op,bra,rs,rt,rd,sh) begin :sprintf
          reg [4*8:1] rdn;//Mar.15.2005 =get_reg_name(rd);//
          reg [4*8:1] rsn;//Mar.15.2005=get_reg_name(rs);
          reg [4*8:1] rtn;//Mar.15.2005 =get_reg_name(rt);
          rdn=get_reg_name(rd); 
          rsn=get_reg_name(rs);
          rtn=get_reg_name(rt);
          case (op)
           0:   
                case (IR[5:0])
                        0: if (rd==0 &amp;&amp; rt==0 &amp;&amp; rs==0 ) $sprintf(inst,&quot;nop&quot;);
                           else $sprintf(inst,&quot;sll %s,%s,%2d\n&quot;,rdn,rtn,sh);
                        2:
                                $sprintf(inst,&quot; srl %s,%s,%2d\n&quot;,rdn,rtn,sh);
                        
                      3:
                                $sprintf(inst,&quot; sra %s,%s,%2d\n&quot;,rdn,rtn,sh);
                        
                       4:
                                $sprintf(inst,&quot; sllv %s,%s,%s\n&quot;,rdn,rtn,rsn);
                        
                       6:
                                $sprintf(inst,&quot; srlv %s,%s,%s\n&quot;,rdn,rtn,rsn);
                        
                 7:
                        $sprintf(inst,&quot; srav %s,%s,%s\n&quot;,rdn,rtn,rsn);
                        
                 8:
                        $sprintf(inst,&quot; jr %s\n&quot;,rsn);
                        
                 9:
                        $sprintf(inst,&quot; jalr %s\n&quot;,rsn);
                        
                 12:
                        $sprintf(inst,&quot; syscall\n&quot;);
                        
                 13:
                        $sprintf(inst,&quot; break&quot;);
                        
                 16:
                        $sprintf(inst,&quot; mfhi %s\n&quot;,rdn);
                        
                 17:
                        $sprintf(inst,&quot; mthi %s\n&quot;,rsn);
                        
                 18:
                        $sprintf(inst,&quot; mflo %s\n&quot;,rdn);
                        
                 19:
                        $sprintf(inst,&quot; mtlo %s\n&quot;,rsn);
                        
                 24:
                        $sprintf(inst,&quot; mult %s,%s\n&quot;,rsn,rtn);
                        
                 25:
                        $sprintf(inst,&quot; multu %s,%s\n&quot;,rsn,rtn);
                        
                 26:
                        $sprintf(inst,&quot; div %s,%s\n&quot;,rsn,rtn);
                        
                 27:
                        $sprintf(inst,&quot; divu %s,%s\n&quot;,rsn,rtn);
                        
                 32:
                        
                        $sprintf(inst,&quot; add %s,%s,%s&quot;,rdn,rsn,rtn);
                        
                 33:
                        if(rt==0)
                                $sprintf(inst,&quot; move %s,%s\n&quot;,rdn,rsn);
                        else
                                $sprintf(inst,&quot; addu %s,%s,%s\n&quot;,rdn,rsn,rtn);
                        
                 34:
                        $sprintf(inst,&quot; sub %s,%s,%s\n&quot;,rdn,rsn,rtn);
                        
                 35:
                        $sprintf(inst,&quot; subu %s,%s,%s\n&quot;,rdn,rsn,rtn);
                        
                 36:
                        $sprintf(inst,&quot; and %s,%s,%s\n&quot;,rdn,rsn,rtn);
                        
                 37:
                        if(rt==0) 
                                $sprintf(inst,&quot; move %s,%s\n&quot;,rdn,rsn);
                         else
                                $sprintf(inst,&quot; or %s,%s,%s\n&quot;,rdn,rsn,rtn);
                        
                 38:
                        $sprintf(inst,&quot; xor %s,%s,%s\n&quot;,rdn,rsn,rtn);
                        
                 39:
                        $sprintf(inst,&quot; nor %s,%s,%s\n&quot;,rdn,rsn,rtn);
                        
                 42:
                        $sprintf(inst,&quot; slt %s,%s,%s\n&quot;,rdn,rsn,rtn);
                        
                 43:
                        $sprintf(inst,&quot; sltu %s,%s,%s\n&quot;,rdn,rsn,rtn);
                        
                default:
                        $sprintf(inst,&quot;Unknown Func. %08h\n&quot;,IR);
                        
                
                

                endcase
            1:
                case (IR[20:16])
                 0:
                        $sprintf(inst,&quot; bltz %s,$%08h\n&quot;,rsn,bra);
                        
                 1:
                        $sprintf(inst,&quot; bgez %s,$%08h\n&quot;,rsn,bra);
                        
                 16:
                        $sprintf(inst,&quot; bltzal %s,$%08h\n&quot;,rsn,bra);
                        
                 17:
                        $sprintf(inst,&quot; bgezal %s,$%08h\n&quot;,rsn,bra);
                        
                default:
                        $sprintf(inst,&quot;Unknown1 %08h\n&quot;,IR);
                        
                endcase
                
         2:
                $sprintf(inst,&quot; j $%08h\n&quot;,((IR*4)&amp;32'h0ffffffc)+(PC&amp;32'hf0000000));
                
         3:
                $sprintf(inst,&quot; jal $%08h\n&quot;,((IR*4)&amp;32'h0ffffffc)+(PC&amp;32'hf0000000));
                
         4:
                if(rs==0 &amp;&amp; rt==0)
                        $sprintf(inst,&quot; bra $%08h\n&quot;,bra);
                else
                        $sprintf(inst,&quot; beq %s,%s,$%08h\n&quot;,rsn,rtn,bra);
                
         5:
                $sprintf(inst,&quot; bne %s,%s,$%08h\n&quot;,rsn,rtn,bra);
                
         6:
                $sprintf(inst,&quot; blez %s,$%08h\n&quot;,rsn,bra);
                
         7:
                $sprintf(inst,&quot; bgtz %s,$%08h\n&quot;,rsn,bra);
                
         8:
                $sprintf(inst,&quot; addi %s,%s,#$%04h\n&quot;,rtn,rsn,IR[15:0]);
                
         9:
                if(rs==0)
                        $sprintf(inst,&quot; li %s,#$%08h\n&quot;,rtn,IR[15:0]);
                else
                        $sprintf(inst,&quot; addiu %s,%s,#$%04h\n&quot;,rtn,rsn,IR[15:0]);
                
         10:
                $sprintf(inst,&quot; slti %s,%s,#$%04h\n&quot;,rtn,rsn,IR[15:0]);
                
         11:
                $sprintf(inst,&quot; sltiu %s,%s,#$%04h\n&quot;,rtn,rsn,IR[15:0]);
                
         12:
                $sprintf(inst,&quot; andi %s,%s,#$%04h\n&quot;,rtn,rsn,IR[15:0]);
                
         13:
                if(rs==0)
                        $sprintf(inst,&quot; li %s,#$%08h\n&quot;,rtn,IR[15:0]);
                else
                        $sprintf(inst,&quot; ori %s,%s,#$%04h\n&quot;,rtn,rsn,IR[15:0]);
                
         14:
                $sprintf(inst,&quot; xori %s,%s,#$%04h\n&quot;,rtn,rsn,IR[15:0]);
                
         15://load upper immediate

                        $sprintf(inst,&quot; lui %s,#$%04h&quot;,rtn,IR[15:0]);
                
         16, 17, 18, 19: begin
                if(rs&gt;=16)
                        $sprintf(inst,&quot; cop%d $%08h\n&quot;,op&amp;3,IR[25:0]);
                 else
                case(rsn)
                 0:
                        $sprintf(inst,&quot; mfc%d %s,%s\n&quot;,op&amp;3,rtn,rdn);
                        
                 2:
                        $sprintf(inst,&quot; cfc%d %s,%s\n&quot;,op&amp;3,rtn,rdn);
                        
                 4:
                        $sprintf(inst,&quot; mtc%d %s,%s\n&quot;,op&amp;3,rtn,rdn);
                        
                 6:
                        $sprintf(inst,&quot; ctc%d %s,%s\n&quot;,op&amp;3,rtn,rdn);
                        
                 8, 12:
                        if(rt&amp;1)
                                $sprintf(inst,&quot; bc%dt %d,%08h\n&quot;,op&amp;3,rs*32+rt,bra);
                         else 
                                $sprintf(inst,&quot; bc%df %d,%08h\n&quot;,op&amp;3,rs*32+rt,bra);
                        
                        
                 default:
                        $sprintf(inst,&quot;Unknown16 %08h\n&quot;,IR);
                 endcase
                end
         32:
                $sprintf(inst,&quot; lb %s,$%04h(%s)\n&quot;,rtn,IR[15:0],rsn);
                
         33:
                $sprintf(inst,&quot; lh %s,$%04h(%s)\n&quot;,rtn,IR[15:0],rsn);
                
         34:
                $sprintf(inst,&quot; lwl %s,$%04h(%s)\n&quot;,IR[15:0],rsn);
                
         35:
                $sprintf(inst,&quot; lw %s,$%04h(%s)\n&quot;,rtn,IR[15:0],rsn);
                
         36:
                $sprintf(inst,&quot; lbu %s,$%04h(%s)\n&quot;,rtn,IR[15:0],rsn);
                
         37:
                $sprintf(inst,&quot; lhu %s,$%04h(%s)\n&quot;,rtn,IR[15:0],rsn);
                
         38:
                $sprintf(inst,&quot; lwr %s,$%04h(%s)\n&quot;,rtn,IR[15:0],rsn);
                
         40:
                $sprintf(inst,&quot; sb %s,$%04h(%s)\n&quot;,rtn,IR[15:0],rsn);
                
         41:
                $sprintf(inst,&quot; sh %s,$%04h(%s)\n&quot;,rtn,IR[15:0],rsn);
                
         42:
                $sprintf(inst,&quot; swl %s,$%04h(%s)\n&quot;,rtn,IR[15:0],rsn);
                
         43:
                $sprintf(inst,&quot; sw %s,$%04h(%s)\n&quot;,rtn,IR[15:0],rsn);
                
         46:
                $sprintf(inst,&quot; swr %s,$%04h(%s)\n&quot;,rtn,IR[15:0],rsn);
                
         48, 49, 50, 51:
                $sprintf(inst,&quot; lwc%d %s,$%04h(%s)\n&quot;,op&amp;3,rtn,IR[15:0],rsn);
                
         56, 57, 58, 59:
                $sprintf(inst,&quot; swc%d %s,$%04h(%s)\n&quot;,op&amp;3,rtn,IR[15:0],rsn);
                
        default:
                $sprintf(inst,&quot;UnknownOp %08h\n&quot;,IR);
                
        

         
        endcase
   end


`endif
//
                always @ (posedge clock)        sync_resetD1 &lt;=sync_reset; 


//IRD1
        always @ (posedge clock) begin
                if (sync_resetD1) IRD1 &lt;=32'h00;
                else if ((control_state[5:0]==6'b00_0000 &amp;&amp; int_req)  ) IRD1&lt;=int_address&gt;&gt;2;
                else if (opecode==6'b000_001) IRD1&lt;={IR[31:21],5'b00000,IR[15:0]};//Jul.11.2004 target Special zero
                else IRD1 &lt;=IR;
        end

//IRD2
        always @ (posedge clock) begin
          IRD2 &lt;=IRD1;
        end

//RF_input_addr [4:0]
        always @ (posedge clock) begin
                 case (RF_input_addr_selD1)
                        `RF_Ert_sel: RF_input_addr &lt;=target_addrD1;
                        `RF_Erd_sel: RF_input_addr &lt;=destination_addrD1;
                        `RF_R15_SEL: RF_input_addr &lt;=`Last_Reg;
                        `RF_INTR_SEL:RF_input_addr &lt;=`Intr_Reg;
                         default   : RF_input_addr &lt;=target_addrD1;
                     endcase
        end

//int_seqD1     
        always @(posedge clock) begin
                if (sync_reset) int_seqD1&lt;=0;
                else  int_seqD1&lt;=control_state[5:0]==6'b00_0000 &amp;&amp; int_req;

        end


// [1:0] Shift_FuncD1,Shift_FuncD2;
        always @ (posedge clock) begin
                Shift_FuncD2&lt;=Shift_FuncD1;
        end

// [3:0] ALU_FuncD1,ALU_FuncD2;



        always @ (posedge clock) begin
                M_access_modeD2&lt;=M_access_modeD1;
        end

//M_signD1,M_signD2;
        always @ (posedge clock) begin
                M_signD2&lt;=M_signD1;
        end

//takenD4
        always @ (posedge clock) begin
                if (sync_resetD1) takenD4&lt;=1'b0;
                else if (NOP_Signal) takenD4&lt;=1'b0;//TRY
                else                  takenD4&lt;=takenD3;
        end
//takenD5
        always @ (posedge clock) begin
                if (sync_resetD1) takenD5&lt;=1'b0;
                else              takenD5&lt;=takenD4;
        end
//RegWriteD2,RegWriteD1;
        always @ (posedge clock) begin
                if (sync_resetD1) begin
                        RegWriteD2&lt;=1'b0;
                end else if (takenD4 ||takenD5  || NOP_Signal ) RegWriteD2&lt;=1'b0;//NOP
                else    RegWriteD2&lt;=RegWriteD1;
                
        end




//Combination logics
//RegWrite;
        always @ (posedge clock) begin
                if (sync_resetD1)                          RegWriteD1&lt;=1'b0;
                else if (control_state[5:0]==6'b00_0000 &amp;&amp; int_req) RegWriteD1&lt;=1'b1;
                else case (opecode)
                        `loadbyte_signed    :      RegWriteD1&lt;=1'b1;            
                   `loadbyte_unsigned :       RegWriteD1&lt;=1'b1;
                   `loadword_signed    :       RegWriteD1&lt;=1'b1;
                   `loadword_unsigned :      RegWriteD1&lt;=1'b1;
                   `loadlong       :            RegWriteD1&lt;=1'b1;
                        `jump_and_link_im:         RegWriteD1&lt;=1'b1;
                        `andi             :        RegWriteD1&lt;=1'b1;            
                   `addi             :     RegWriteD1&lt;=1'b1 ;
                        `addiu           :         RegWriteD1&lt;=1'b1;
                    `ori              :            RegWriteD1&lt;=1'b1;
                        `xori             :        RegWriteD1&lt;=1'b1;
                        `lui              :               RegWriteD1&lt;=1'b1;
                     `comp_im_signed    : RegWriteD1&lt;=1'b1;
                      `comp_im_unsigned : RegWriteD1&lt;=1'b1;
                        6'b00_0000:
                                         case (opefunc)
                                                        `divs: RegWriteD1&lt;=1'b0;
                                                        `divu: RegWriteD1&lt;=1'b0;
                                                        `muls: RegWriteD1&lt;=1'b0;
                                                        `mulu: RegWriteD1&lt;=1'b0;
                                                      default:   RegWriteD1&lt;=1'b1;
                                         endcase        
                        default:                   RegWriteD1&lt;=1'b0;
                endcase
        end
//
        always @ (posedge clock) begin
                if (sync_resetD1)                          mul_div_funcD1&lt;=1'b0;
                else if (control_state[5:0]==6'b00_0000 &amp;&amp; int_req) mul_div_funcD1&lt;=1'b0;
                else case (opecode)
                
                        6'b00_0000:
                                         case (opefunc)
                                                        `divs: begin
                                                                        mul_div_funcD1&lt;=1'b1;
                                                                        div_mode_ff&lt;=1'b1;
                                                                   end  
                                                        `divu: begin 
                                                                        mul_div_funcD1&lt;=1'b1;
                                                                        div_mode_ff&lt;=1'b1;
                                                                   end
                                                        `muls: begin 
                                                                        mul_div_funcD1&lt;=1'b1;
                                                                        div_mode_ff&lt;=1'b0;
                                                                   end
                                                        `mulu: begin 
                                                                        mul_div_funcD1&lt;=1'b1;
                                                                        div_mode_ff&lt;=1'b0;
                                                                    end
                                                      default:   mul_div_funcD1&lt;=1'b0;
                                         endcase        
                        default:                   mul_div_funcD1&lt;=1'b0;
                endcase
        end

//mu_div_func
//mul_alu_selD2/excuting_flag
always @ (posedge clock) begin
                if (sync_resetD1)       begin
                                mul_div_funcD2 &lt;=`mult_nothing;
                                mul_alu_selD2&lt;=2'b00;
                end else if ( mul_div_funcD2 [3] ) mul_div_funcD2[3]&lt;=1'b0;////

                else if( !NOP_Signal) //
                                case (opecodeD1)
                               6'b00_0000:
                                case   (opefuncD1)
                                `divs:  begin
                                                mul_div_funcD2&lt;=`mult_signed_divide;

                                                end
                                `divu:  begin
                                                mul_div_funcD2&lt;=`mult_divide;
                                                end     
                         `muls: begin
                                                mul_div_funcD2&lt;=`mult_signed_mult;
                                                end
                         `mulu: begin
                                                mul_div_funcD2&lt;=`mult_mult;
                                                end

                                `mfhi : begin
                                                        if (!pause_out)mul_div_funcD2&lt;=`mult_read_hi;
                                                        mul_alu_selD2&lt;=`MUL_hi_SEL;
                                                   end
                                `mflo : begin 
                                                        if(!pause_out) mul_div_funcD2&lt;=`mult_read_lo;
                                                        mul_alu_selD2&lt;=`MUL_lo_SEL;
                                                   end
                                 default:       begin 
                                                        mul_div_funcD2 &lt;=`mult_read_lo;
                                                mul_alu_selD2&lt;=2'b00;
                                                end
                                endcase
                                default:              mul_alu_selD2&lt;=2'b00;
                     endcase

end

always @ (posedge clock) begin
                if (sync_resetD1) excuting_flagD&lt;=1'b0;
                else                  excuting_flagD&lt;=excuting_flag;
end

always @ (posedge clock) begin
                if (sync_resetD1) excuting_flagDD&lt;=1'b0;
                else                  excuting_flagDD&lt;=excuting_flagD;
end
        assign finish_operation=excuting_flag &amp;&amp; !pause_out;


//MWrite
        always @ (posedge clock) begin
                if (sync_resetD1)               MWriteD1&lt;=1'b0;
        
                else case (opecode)
                        `storebyte:     MWriteD1&lt;=1'b1; 
                        `storeword:     MWriteD1&lt;=1'b1;
                        `storelong:     MWriteD1&lt;=1'b1;
                        default:        MWriteD1&lt;=1'b0;
                     endcase
     end

        always @ (posedge clock) begin
                if (sync_resetD1)               MWriteD2&lt;=1'b0;
                else if (  NOP_Signal ) MWriteD2&lt;=1'b0;
                else                            MWriteD2&lt;=MWriteD1;//taken NOP 
        end


//M_sign
        always @ (posedge clock) begin
                if (sync_resetD1)                           M_signD1&lt;=`M_unsigned;
                else case (opecode)
                             `loadbyte_signed  :     M_signD1&lt;=`M_signed;               
                        `loadbyte_unsigned :   M_signD1&lt;=`M_unsigned;
                        `loadword_signed  :     M_signD1&lt;=`M_signed;
                        `loadword_unsigned :  M_signD1&lt;=`M_unsigned;
                        `loadlong          :       M_signD1&lt;=`M_unsigned;
                             `storebyte:                    M_signD1&lt;=`M_unsigned;      
                             `storeword:                    M_signD1&lt;=`M_unsigned;
                        `storelong:                 M_signD1&lt;=`M_unsigned;
                                default:                          M_signD1&lt;=`M_unsigned;
                     endcase
        end




// [1:0] M_access_mode
        always @ (posedge clock) begin
                if (sync_resetD1)                         M_access_modeD1&lt;=`LONG_ACCESS;
                else case (opecode)
                        `loadbyte_signed  :       M_access_modeD1&lt;=`BYTE_ACCESS;                
                   `loadbyte_unsigned :     M_access_modeD1&lt;=`BYTE_ACCESS;
                   `loadword_signed  :       M_access_modeD1&lt;=`WORD_ACCESS;
                   `loadword_unsigned :    M_access_modeD1&lt;=`WORD_ACCESS;
                   `loadlong       :          M_access_modeD1&lt;=`LONG_ACCESS;
                      `storebyte:                      M_access_modeD1&lt;=`BYTE_ACCESS;   
                        `storeword:                    M_access_modeD1&lt;=`WORD_ACCESS;
                   `storelong:                 M_access_modeD1&lt;=`LONG_ACCESS;
                        default:                             M_access_modeD1&lt;=`LONG_ACCESS;
                     endcase
        end




// [2:0] RF_input Shift_Amount_sel
        always @ (posedge clock) begin
                if (sync_resetD1)               begin 
                        RF_inputD2 &lt;=`RF_ALU_sel;
                        Shift_Amount_selD2&lt;=`SHIFT_AMOUNT_IMM_SEL;
                end
             else if ((int_seqD1)  || NOP_Signal ) RF_inputD2&lt;=`RF_PC_SEL;//Jul.7.2004
             else       
                 case (opecodeD1)
                        `lui    :RF_inputD2     &lt;=`SHIFT16_SEL;
                        `jump_and_link_im:      RF_inputD2&lt;=`RF_PC_SEL;
                        
                        6'b00_0000:
                                case   (opefuncD1)
                                     `jump_and_link_register : RF_inputD2&lt;=`RF_PC_SEL;
                                           `lsl              :    begin
                                                                                 RF_inputD2&lt;=`RF_Shifter_sel ;
                                                                                 Shift_Amount_selD2&lt;=`SHIFT_AMOUNT_IMM_SEL;
                                                                                end 
                                                `sllv           :      begin
                                                                                  RF_inputD2&lt;=`RF_Shifter_sel ;
                                                                                  Shift_Amount_selD2&lt;=`SHIFT_AMOUNT_REG_SEL;
                                                                                 end            
                                             `asr                    : begin
                                                                                    RF_inputD2&lt;=`RF_Shifter_sel ;
                                                                                    Shift_Amount_selD2&lt;=`SHIFT_AMOUNT_IMM_SEL;
                                                                                 end
                                        `srav                    : begin
                                                                                    RF_inputD2&lt;=`RF_Shifter_sel ;
                                                                                    Shift_Amount_selD2&lt;=`SHIFT_AMOUNT_REG_SEL;
                                                                                 end
   
                                     `lsr                    :  begin
                                                                                     RF_inputD2&lt;=`RF_Shifter_sel;
                                                                                     Shift_Amount_selD2&lt;=`SHIFT_AMOUNT_IMM_SEL;
                                                                                 end
                                                `srlv                    :  begin
                                                                                     RF_inputD2&lt;=`RF_Shifter_sel;
                                                                                     Shift_Amount_selD2&lt;=`SHIFT_AMOUNT_REG_SEL;
                                                                                 end


                                                `mfhi           :       RF_inputD2&lt;=`RF_PC_SEL;
                                                `mflo           :       RF_inputD2&lt;=`RF_PC_SEL;
                                        default              :      begin
                                                                        RF_inputD2&lt;=`RF_ALU_sel;
                                                                        Shift_Amount_selD2&lt;=`SHIFT_AMOUNT_IMM_SEL;
                                                                        end
                                endcase
                        default: begin
                                                RF_inputD2&lt;=`RF_ALU_sel;
                                                 Shift_Amount_selD2&lt;=`SHIFT_AMOUNT_IMM_SEL;
                                        end
                     endcase
        end


//[1:0] A_Right_SEL
        always @ (posedge clock) begin
                 casex (opecode)        
                        `storebyte:     A_Right_SELD1&lt;=`A_RIGHT_ERT;
                        `storeword:     A_Right_SELD1&lt;=`A_RIGHT_ERT;
                        `storelong:     A_Right_SELD1&lt;=`A_RIGHT_ERT;
                        `andi     :     A_Right_SELD1&lt;=`Imm_unsigned ;          
                  `addi     :       A_Right_SELD1&lt;=`Imm_signed  ;
                        `addiu    :     A_Right_SELD1&lt;=`Imm_signed;
                  `ori      :         A_Right_SELD1&lt;=`Imm_unsigned;
                        `xori     :     A_Right_SELD1&lt;=`Imm_unsigned;

                        `beq         :          A_Right_SELD1&lt;=`A_RIGHT_ERT;  
                        `bgtz        :          A_Right_SELD1&lt;=`A_RIGHT_ERT;            
                        `blez        :          A_Right_SELD1&lt;=`A_RIGHT_ERT; 
                        `bne         :          A_Right_SELD1&lt;=`A_RIGHT_ERT;


                        `comp_im_signed   : A_Right_SELD1&lt;=`Imm_signed;
                        `comp_im_unsigned : A_Right_SELD1&lt;=`Imm_signed;

                        //6'b00_0000:
                        6'b00_000?://Jul.11.2004 target select
                                case   (opefunc)
                                        
                                        default           : A_Right_SELD1&lt;=`A_RIGHT_ERT;
                                endcase
                        default: A_Right_SELD1&lt;=`Imm_signed;
                    endcase
        end


//Interim A_Left_SELD1RRegSelD1
        always @ (posedge clock) begin
                 case (opecode) 
                        default: A_Left_SELD1&lt;=0;//always Left_latch
                    endcase
        end

        always @ (posedge clock) begin
                if ((control_state[5:0]==6'b00__0000 &amp;&amp; int_req)  )  RRegSelD1&lt;=`NREG_SEL;//Jul.13.2004
                else case (opecode)     
                            `loadbyte_signed  : RRegSelD1&lt;=`MOUT_SEL;           
                        `loadbyte_unsigned :    RRegSelD1&lt;=`MOUT_SEL;
                        `loadword_signed  :     RRegSelD1&lt;=`MOUT_SEL;
                        `loadword_unsigned :    RRegSelD1&lt;=`MOUT_SEL;
                        `loadlong          :    RRegSelD1&lt;=`MOUT_SEL;
                        default:                RRegSelD1&lt;=`NREG_SEL;//Interim MULSEL
                  endcase
        end

// [3:0] ALU_Func[1:0] ;
        always @ (posedge clock) begin
                
                case (opecodeD1)
                                `andi    : ALU_FuncD2&lt;=`ALU_AND;
                                `addi    : ALU_FuncD2&lt;=`ALU_ADD  ;
                                `addiu  :  ALU_FuncD2&lt;=`ALU_ADD;
                                `ori     : ALU_FuncD2&lt;=`ALU_OR;
                                `xori    : ALU_FuncD2&lt;=`ALU_XOR;
                                 `comp_im_signed     : ALU_FuncD2&lt;=`ALU_LESS_THAN_SIGNED;
                         `comp_im_unsigned   : ALU_FuncD2&lt;=`ALU_LESS_THAN_UNSIGNED;
                                6'b00_0000: 
                                case   (opefuncD1)
                                        `add    : ALU_FuncD2&lt;=`ALU_ADD ;
                                        `addu   :        ALU_FuncD2&lt;=`ALU_ADD ;         
                                `sub     : ALU_FuncD2&lt;=`ALU_SUBTRACT;
                                        `subu   : ALU_FuncD2&lt;=`ALU_SUBTRACT;
                                        `and     : ALU_FuncD2&lt;=`ALU_AND;
                                        `nor     : ALU_FuncD2&lt;=`ALU_NOR;
                                        `or      : ALU_FuncD2&lt;=`ALU_OR;
                                        `xor     : ALU_FuncD2&lt;=`ALU_XOR;
                               `comp_signed      : ALU_FuncD2&lt;=`ALU_LESS_THAN_SIGNED;   
                              `comp_unsigned     : ALU_FuncD2&lt;=`ALU_LESS_THAN_UNSIGNED; 
                            
                                        default           : ALU_FuncD2&lt;=`ALU_NOTHING;//Jul.6.2004 ALU_NOTHING;
                                endcase
                              default: ALU_FuncD2&lt;=`ALU_NOTHING;//Jul.6.2004 ALU_NOTHING;
                endcase
        end


// [1:0] Shift_Func;
        always @ (posedge clock) begin
                 case (opecode)
                        6'b00_0000: 
                                case   (opefunc)
                                        `lsl             : Shift_FuncD1&lt;=`SHIFT_LEFT;
                                      `sllv         : Shift_FuncD1&lt;=`SHIFT_LEFT;
                                `asr             : Shift_FuncD1&lt;=`SHIFT_RIGHT_SIGNED;
                                        `srav           : Shift_FuncD1&lt;=`SHIFT_RIGHT_SIGNED;
                                        `lsr             : Shift_FuncD1&lt;=`SHIFT_RIGHT_UNSIGNED;
                                        `srlv           : Shift_FuncD1&lt;=`SHIFT_RIGHT_UNSIGNED;
                                        default          : Shift_FuncD1&lt;=`SHIFT_LEFT;//Jul.5.2004 `SHIFT_NOTHING;
                                endcase
                        default: Shift_FuncD1&lt;=`SHIFT_LEFT;//Jul.5.2004`SHIFT_NOTHING;
                     endcase
        end



//RF_input_addr_sel
        always @ (posedge clock) begin
                 if ((control_state[5:0]==6'b00__0000 &amp;&amp; int_req)  ) RF_input_addr_selD1&lt;=`RF_INTR_SEL;
                 else
                 case (opecode)
                                `andi            : RF_input_addr_selD1&lt;=`RF_Ert_sel;            
                                `addi            : RF_input_addr_selD1&lt;=`RF_Ert_sel;
                                `ori             : RF_input_addr_selD1&lt;=`RF_Ert_sel;
                                `xori            : RF_input_addr_selD1&lt;=`RF_Ert_sel;
                                `jump_and_link_im: RF_input_addr_selD1&lt;=`RF_R15_SEL;
                                `lui             : RF_input_addr_selD1&lt;=`RF_Ert_sel;
                                `comp_im_signed  : RF_input_addr_selD1&lt;=`RF_Ert_sel;
                                `comp_im_unsigned: RF_input_addr_selD1&lt;=`RF_Ert_sel;
                        6'b00_0000: 
                                case   (opefunc)
                                        `jump_and_link_register: RF_input_addr_selD1&lt;=`RF_R15_SEL;
                                
                                        default          : RF_input_addr_selD1&lt;=`RF_Erd_sel;
                                endcase
                        default: RF_input_addr_selD1&lt;=`RF_Ert_sel;
                    endcase
        end





//PC_command decoder    
//      always @ (posedge clock) begin
        always @(opecode,control_state,int_req,opefunc,NOP_Signal,takenD3,takenD4) begin//Jul.2.2004    
                 if (takenD3 || takenD4)         PC_commandD1&lt;=`PC_INC;//
                   else case (opecode)
        
                         6'b00_0000:
                                        case (opefunc)
                                        `jmp_register : PC_commandD1&lt;=`PC_REG;
                                         default:         PC_commandD1&lt;=`PC_INC;
                                        endcase
                         default      : PC_commandD1&lt;=`PC_INC;
                endcase
        end
//unsuppurted command detector Jul.11.2004
       always @(posedge clock) begin
                case (opecode)
                        6'b000_001://Jul.11.2004 simple decode
                                case (IR[20:16]) 
                                        
                                        `bltzal  :begin
                                                        $display(&quot;unsupported command&quot;);
                                                        $stop;
                                                end   
                                        `bgezal : begin
                                                        $display(&quot;unsupported command&quot;);
                                                        $stop;
                                                end   
                                         
                                        `bltzall:begin
                                                        $display(&quot;unsupported command&quot;);
                                                        $stop;
                                                end  
                                        `bltzl:begin
                                                        $display(&quot;unsupported command&quot;);
                                                        $stop;
                                                end   
                                        `bgezall:begin
                                                        $display(&quot;unsupported command&quot;);
                                                        $stop;
                                                end   
                                        `bgezl: begin
                                                        $display(&quot;unsupported command&quot;);
                                                        $stop;
                                                end   
                                endcase
                endcase 
        

        end



        always @ (posedge clock) begin
                   if ((control_state[5:0]==6'b00_0000 &amp;&amp; int_req)  ) begin
                                                                jumpQ&lt;=1'b1;
                                                              branchQ&lt;=1'b0;////Jun.30.2004
                   end else if (takenD3)        begin
                                                                jumpQ&lt;=1'b0;//inhibit jump at delayed slot2
                                                                branchQ&lt;=1'b0;//TRY Jun.30.2004
                   end else     
                     case (opecode)
                        `jump:                begin
                                                                jumpQ&lt;=1'b1;
                                                                branchQ&lt;=1'b0;//Jun.30.2004
                                                        end
                        `jump_and_link_im:      begin
                                                                 jumpQ&lt;=1'b1;
                                                                 branchQ&lt;=1'b0;//Jun.30.2004
                                                        end
                        `beq         :        begin
                                                                        jumpQ&lt;=1'b0;//Jun.30.2004
                                                                        branchQ&lt;=1'b1;
                                                                end
                        `bgtz        :        begin
                                                                        jumpQ&lt;=1'b0;//Jun.30.2004
                                                                        branchQ&lt;=1'b1;
                                                                end             
                        `blez          :        begin
                                                                        jumpQ&lt;=1'b0;//Jun.30.2004
                                                                        branchQ&lt;=1'b1;
                                                                end
                  `bne           :              begin
                                                                        jumpQ&lt;=1'b0;//Jun.30.2004
                                                                        branchQ&lt;=1'b1;
                                                                end
                        6'b000_001://Jul.11.2004 simple decode
                                                begin
                                                                jumpQ&lt;=1'b0;
                                                                branchQ&lt;=1'b1;
                                                end
                                
                         default      : begin
                                         jumpQ&lt;=1'b0;
                                         branchQ&lt;=1'b0;
                                        end             
                     endcase
        end

         always @ (posedge clock) begin
                if (NOP_Signal) branchQQ&lt;=1'b0;
                else branchQQ&lt;=branchQ;
        end
         


//For Critical Path
        always @(posedge clock) begin
                if (sync_resetD1)    beqQ&lt;=0;
                else  if ((control_state[5:0]==6'b00_0000 &amp;&amp; int_req)  ) beqQ&lt;=1'b0;
                else if (opecode==`beq) beqQ&lt;=1'b1;
                else               beqQ&lt;=1'b0;
        end

//Jul.11.2004 bltz
        always @(posedge clock) begin
                if (sync_resetD1)    bltzQ&lt;=0;
                else  if ((control_state[5:0]==6'b00_0000 &amp;&amp; int_req)  ) bltzQ&lt;=1'b0;
                else if (opecode==6'b000_001 &amp;&amp; IR[20:16]==`bltz) bltzQ&lt;=1'b1;//Jul.13.2004
                else               bltzQ&lt;=1'b0;
        end
//Jul.11.2004 bgez
        always @(posedge clock) begin
                if (sync_resetD1)    bgezQ&lt;=0;
                else  if ((control_state[5:0]==6'b00_0000 &amp;&amp; int_req)  ) bgezQ&lt;=1'b0;
                else if (opecode==6'b000_0001 &amp;&amp; IR[20:16]==`bgez) bgezQ&lt;=1'b1;//Jul.13.2004
                else               bgezQ&lt;=1'b0;
        end


        always @(posedge clock) begin
                if (sync_resetD1)     bgtzQ&lt;=0;
                else  if ((control_state[5:0]==6'b00_0000 &amp;&amp; int_req)  ) bgtzQ&lt;=1'b0;
                else if (opecode==`bgtz) bgtzQ&lt;=1'b1;
                else                bgtzQ&lt;=1'b0;
        end
        always @(posedge clock) begin
                if (sync_resetD1)     blezQ&lt;=0;
                else  if ((control_state[5:0]==6'b00_0000 &amp;&amp; int_req)   ) blezQ&lt;=1'b0;
                else if (opecode==`blez) blezQ&lt;=1'b1;
                else                blezQ&lt;=1'b0;
        end
        always @(posedge clock) begin
                if (sync_resetD1)    bneQ&lt;=0;
                else  if ((control_state[5:0]==6'b00_0000 &amp;&amp; int_req)  ) bneQ&lt;=1'b0;
                else if (opecode==`bne) bneQ&lt;=1'b1;
                else               bneQ&lt;=1'b0;
        end

//
        always @(posedge clock) begin
                if (sync_resetD1)   begin 
                                
                                                 excuting_flag&lt;=1'b0;//
                end else
                 begin
                        if (!pause_out &amp;&amp; excuting_flagDD) excuting_flag&lt;=1'b0;
                        else case (opecode)
                                                6'b00_0000:
                                                        case (opefunc)
                                                                `divs:                   excuting_flag&lt;=1'b1;
                                                                `divu:                   excuting_flag&lt;=1'b1;   
                                                        `muls:                   excuting_flag&lt;=1'b1;
                                                        `mulu:                   excuting_flag&lt;=1'b1;
                                                        endcase
                              endcase
                end             
        end
      
        always @(posedge clock) begin
                if (sync_resetD1)   begin 
                                                 control_state&lt;=6'b00_0000;
                end else
                 begin
                        casex (control_state[5:0])
                        6'b00_0000:
                                begin
                                        if(int_req) control_state&lt;=6'b000_101;//
                                        else 
                                                case (opecode)
                                                `jump:                control_state&lt;=6'b100_000;
                                                `jump_and_link_im:    control_state&lt;=6'b100_000;
                                                `beq         :        control_state&lt;=6'b110_000;
                                                `bgtz        :        control_state&lt;=6'b110_000;                
                                                `blez        :        control_state&lt;=6'b110_000;
                                        `bne         :        control_state&lt;=6'b110_000;
                                                6'b000_001:             control_state&lt;=6'b110_000;//Jul.11.2004 Special Branch
                                                6'b00_0000:
                                                        case (opefunc)
                                                        `jump_and_link_register: control_state&lt;=6'b101_000;
                                                        `jmp_register :          control_state&lt;=6'b101_000;
                                
                                                        `mfhi:                   if (excuting_flag) control_state&lt;=8'b00_000_010;
                                                        `mflo:                   if (excuting_flag) control_state&lt;=8'b00_000_010;
                                                        default:                       control_state&lt;=6'b00_0000;//for safety
                                                        endcase
                                                endcase 



                                end
                        6'b???_101:     control_state&lt;=6'b000_000;//interrupt_nop state
                        6'b100_000:     control_state&lt;=6'b000_000;//fixed_jump state
                        6'b101_000:     control_state&lt;=6'b001_100;//jump&amp;link state
                        6'b001_100:   control_state&lt;=6'b000_000;//NOP2 state
                        6'b110_000:     control_state&lt;=6'b000_100;//delayed branch 
                        6'b000_100:    `ifdef RAM4K//Priotiry Area 
                                         if (takenD3)   control_state&lt;=6'b001_100;//NOP1 state
                                                else    case (opecode)
                                                        `jump:                control_state&lt;=6'b100_000;
                                                        `jump_and_link_im:    control_state&lt;=6'b100_000;
                                                        `beq         :        control_state&lt;=6'b110_000;
                                                        `bgtz        :        control_state&lt;=6'b110_000;                
                                                        `blez        :        control_state&lt;=6'b110_000;
                                                        `bne         :        control_state&lt;=6'b110_000;
                                                        6'b000_001:             control_state&lt;=6'b110_000;//Jul.11.2004 Special Branch
                                                        6'b00_0000:
                                                                case (opefunc)
                                                                `jump_and_link_register: control_state&lt;=6'b101_000;
                                                                `jmp_register :          control_state&lt;=6'b101_000;
                                                                `mfhi:                   if (excuting_flag) control_state&lt;=8'b00_000_010;
                                                                `mflo:                   if (excuting_flag) control_state&lt;=8'b00_000_010;
                                                                default:                       control_state&lt;=6'b00_0000;//for safety
                                                                endcase
                                                        endcase
                                        `else//Priority Speed
                                                        case (opecode)
                                                        `jump:          if (takenD3)    control_state&lt;=6'b001_100;//NOP1 state      
                                                                        else control_state&lt;=6'b100_000;
                                                        `jump_and_link_im:   if (takenD3)       control_state&lt;=6'b001_100;//NOP1 state 
                                                                             else control_state&lt;=6'b100_000;
                                                        `beq         :       if (takenD3)       control_state&lt;=6'b001_100;//NOP1 state
                                                                             else control_state&lt;=6'b110_000;
                                                        `bgtz        :       if (takenD3)       control_state&lt;=6'b001_100;//NOP1 state
                                                                             else control_state&lt;=6'b110_000;            
                                                        `blez        :       if (takenD3)       control_state&lt;=6'b001_100;//NOP1 state
                                                                             else  control_state&lt;=6'b110_000;
                                                        `bne         :       if (takenD3)       control_state&lt;=6'b001_100;//NOP1 state
                                                                             else control_state&lt;=6'b110_000;
                                                        6'b000_001:          if (takenD3)       control_state&lt;=6'b001_100;//NOP1 state
                                                                             else control_state&lt;=6'b110_000;//Jul.11.2004 Special Branch
                                                        6'b00_0000:
                                                                case (opefunc)
                                                                `jump_and_link_register: if (takenD3)   control_state&lt;=6'b001_100;//NOP1 state
                                                                                         else control_state&lt;=6'b101_000;
                                                                `jmp_register :          if (takenD3)   control_state&lt;=6'b001_100;//NOP1 state
                                                                                         else control_state&lt;=6'b101_000;
                                                                `mfhi:                   if (excuting_flag) begin
                                                                                          if (takenD3)  control_state&lt;=6'b001_100;//NOP1 state 
                                                                                          else control_state&lt;=8'b00_000_010;
                                                                                         end else if (takenD3)  control_state&lt;=6'b001_100;//NOP1 state 
                                                                `mflo:                   if (excuting_flag) begin
                                                                                                if (takenD3)    control_state&lt;=6'b001_100;//NOP1 state
                                                                                                else  control_state&lt;=8'b00_000_010;
                                                                                         end else if (takenD3)  control_state&lt;=6'b001_100;//NOP1 state

                                                                default:                 if (takenD3)   control_state&lt;=6'b001_100;//NOP1 state
                                                                                         else   control_state&lt;=6'b00_0000;//for safety
                                                                endcase
                                                        default :        if (takenD3)   control_state&lt;=6'b001_100;//NOP1 state  
                                                        endcase


                                        `endif          
                        6'b???_010:     case (control_state[7:6]) 
                                                2'b00:   control_state&lt;=8'b01_000_010;
                                                2'b01:   if (!pause_out) control_state&lt;=8'b11_000_010;//mul/div
                                                2'b11:   control_state&lt;=8'b10_000_010;
                                                2'b10:   control_state&lt;=8'b00_000_110;//NOP
                                                default: control_state&lt;=8'h00;
                                              endcase
                        6'b???_110:     control_state&lt;=8'h01;//Jul.12.2004 PCC=save_pc;
                        6'b???_001:   control_state&lt;=8'h00;     //Jul.12.2004 MUL IDLE avoid interrupt                                  
                        default:        control_state&lt;=8'h00;//for safety       
                 endcase
                end             
        end

        assign clear_int=control_state[2:0]==3'b101;//Jul.12.2004 interrupt_nop_state

        always @(posedge clock) begin
                if (sync_reset) nop_bit&lt;=1'b0;
                else if (6'b000_100==control_state[5:0] &amp;&amp; !takenD3) nop_bit&lt;=1'b0;//Not taken
                else              nop_bit&lt;=control_state[2];
        end
        assign NOP_Signal=nop_bit |  control_state[1];//Jul.7.2004 int_bit mul_bit
        

         ram_module_altera
          


`ifdef RAM4K

ram(.clock(clock),.sync_reset(sync_reset),.IR(IR),.MOUT(MOUT),
             .Paddr(PC[11:0]),.Daddr(DAddress[11:0]),.wren(MWriteD2),
             .datain(memory_indata),.access_mode(M_access_modeD2),
             .M_signed(M_signD2),.uread_port(uread_port),.write_busy(write_busy));
`endif
`ifdef RAM16K
   
        ram(.clock(clock),.sync_reset(sync_reset),.IR(IR),.MOUT(MOUT),
             .Paddr(PC[13:0]),.Daddr(DAddress[13:0]),.wren(MWriteD2),
             .datain(memory_indata),.access_mode(M_access_modeD2),
             .M_signed(M_signD2),.uread_port(uread_port),.write_busy(write_busy));
         


`endif

`ifdef RAM32K
ram(.clock(clock),.sync_reset(sync_reset),.IR(IR),.MOUT(MOUT),
             .Paddr(PC[14:0]),.Daddr(DAddress[14:0]),.wren(MWriteD2),
             .datain(memory_indata),.access_mode(M_access_modeD2),
             .M_signed(M_signD2),.uread_port(uread_port),.write_busy(write_busy));
`endif




endmodule</PRE>
      </TH>
    </TR>
  </TBODY>
</TABLE>
<P><B>2.2.6 PC module</B></P>
<P>This module handles PC(program counter)</P>
<TABLE border="1">
  <TBODY>
    <TR>
      <TH width="28" height="14" align="left">
      <PRE>//Jun.30.2004 NOP_DISABLE BUG FIX
`include &quot;define.h&quot;
module pc_module(clock,sync_reset,pc_commandD1,PCC,imm,ea_reg_source,takenD2,
        takenD3 ,branchQQ,jumpQ,NOP_Signal,control_state,IMMD1, PCCDD);
        input clock;
        input sync_reset;
        input [31:0] ea_reg_source;
        input [2:0] pc_commandD1;
        input takenD2;
        input [25:0] imm;
        input [25:0] IMMD1;
`ifdef RAM4K
        output [11:0] PCC;
`else
        output [25:0] PCC;
`endif


        input takenD3;
        input  branchQQ,jumpQ;
        input NOP_Signal;
        input [7:0] control_state;
        
        reg [2:0] pc_commandD2,pc_commandD3;

`ifdef RAM4K
        reg [11:0] PC;
        reg [11:0] pcimm1D1,pcimm2D1;
        reg [15:0] immD1;//
        reg [11:0] pcimm1D2,pcimm2D2,pcimm2D3;
        reg [11:0] save_pc;
        wire [11:0] PCC;
        output [11:0] PCCDD;
        reg [11:0] PCCD,PCCDD;
`else
        reg [25:0] PC;
        reg [25:0] pcimm1D1,pcimm2D1;
        reg [15:0] immD1;// 
        reg [25:0] pcimm1D2,pcimm2D2,pcimm2D3;
        reg [25:0] save_pc;
        wire [25:0] PCC;
        output [25:0] PCCDD;
        reg [25:0] PCCD,PCCDD;
        
`endif

        reg takenD4;
        reg branchQQQtakenD4;



//combination
        
        always@(posedge clock) PCCD&lt;=PCC;
        always@(posedge clock) PCCDD&lt;=PCCD;


        always @(posedge clock) begin
                        pc_commandD2 &lt;=pc_commandD1;

        end
//
        always @(posedge clock) begin
                if (NOP_Signal) pc_commandD3&lt;=3'b000;//Jun.30.2004
                else    pc_commandD3 &lt;=pc_commandD2;

        end

        always @(IMMD1 ) begin
                pcimm1D1={IMMD1,2'b00};//Jul.7.2004 {imm[23:0],2'b00};//+{PC[25:2],2'b00};
                
        end
        

`ifdef RAM4K
        always @(posedge clock) begin
                pcimm2D1&lt;={PC[11:2],2'b00};
        end
`else

        always @(posedge clock) begin
                pcimm2D1&lt;={PC[25:2],2'b00};
        end

`endif

        always @(posedge clock) begin
                 pcimm1D2&lt;=pcimm1D1;
                
        end

        always @(posedge clock) begin

                        pcimm2D2&lt;={{8 {immD1[15]}},immD1[15:0],2'b00}+pcimm2D1;//Jul.14.2004
        end
        always @(posedge clock) begin
                 pcimm2D3&lt;=pcimm2D2;
        end


        always @(posedge clock) begin
                 immD1&lt;=imm[15:0];//Jul.14.2004
        end


        always @(posedge clock) begin
                if (control_state==8'b00_000_010) save_pc&lt;=PCCDD;
        end





        always @(posedge clock) begin
                if (sync_reset) PC&lt;=26'h0_00_0000_0000;

                else if (branchQQQtakenD4) PC&lt;=pcimm2D3+4;//NOP
                else if (jumpQ &amp;&amp; !NOP_Signal) PC&lt;=pcimm1D1+4;

                else if (pc_commandD3==`PC_REG) PC&lt;=ea_reg_source[25:0]+4;
                else if (control_state[2:0]==3'b110) PC&lt;=save_pc+4;//mul/div    
                else  case(pc_commandD1) 
                                                `PC_INC:        PC&lt;=PC+4;
                                                default:        PC&lt;=PC+4;
                             endcase
                
                        

        end
        always @(posedge clock) begin
                if (sync_reset) takenD4&lt;=1'b0;
                else    takenD4&lt;=takenD3;

        end

        always @(posedge clock) begin
                if (sync_reset) branchQQQtakenD4&lt;=1'b0;
                else            branchQQQtakenD4&lt;=branchQQ &amp;&amp; takenD3;
        end

        assign PCC=  branchQQQtakenD4  ? pcimm2D3 :
                                jumpQ  &amp;&amp; !NOP_Signal ? pcimm1D1 :
                                pc_commandD3==`PC_REG ?   ea_reg_source[25:0] :
                                control_state[2:0] ==3'b110 ? save_pc:PC;//Jun.27.2004

endmodule</PRE>
      </TH>
    </TR>
  </TBODY>
</TABLE>
<P><BR>
<B>2.2.7 Pipelined Regfile</B> <BR>
</P>
<P>32bitsx32word Register is rather big for FPGA. Therefore I implemented
by using 3port RAM(or 2port RAMx2).<BR>
Data forwarding mechanism is must for pipelined processor.</P>
<P><IMG src="pipelined_reg.gif" width="1091" height="767" border="0"></P>
<TABLE border="1">
  <TBODY>
    <TR>
      <TH width="28" height="14" align="left">
      <PRE>//Jun.30.2004 Mux sentibity list bug fix
//Jul.2.2004 Cleanup
//Jul.7.2004 int bug fix
//Jan.20.2005 apply @*
`include &quot;define.h&quot;
module Pipelined_RegFile(clock,sync_reset,
        dest_addrD2,source_addr,target_addr,    wren,memory_wdata,
      A_Right_SELD1,A_Left_SELD1,PCD1,IMMD1,ALU_FuncD2,Shift_FuncD2,
      Shift_amountD2,RRegSelD1,MOUT,RF_inputD2,alu_source,alu_target,
        MWriteD2,MWriteD1,mul_alu_selD2,mul_div_funcD2,pause_out,
        Shift_Amount_selD2,int_stateD1,PCCDD
        );
    parameter adder_type=&quot;GENERIC&quot;;
`ifdef RAM4K
        input   [11:0]  PCD1;
`else
        input   [25:0]  PCD1;
`endif
        input     [15:0] IMMD1;//Jul.6.2004
        input   [4:0]  dest_addrD2;
        input   [4:0]  source_addr;
        input   [4:0]  target_addr;
        input   wren;
        input   clock;
        input   A_Left_SELD1;
        input  [3:0] ALU_FuncD2;
        input  [4:0] Shift_amountD2;
        input  [1:0]  Shift_FuncD2;
        input [1:0] A_Right_SELD1;
        input sync_reset;
        input [1:0] RRegSelD1;
        output  [31:0]  alu_target,alu_source;
        output  [31:0]  memory_wdata;
        input [31:0] MOUT;
        input [1:0] RF_inputD2;
        input MWriteD2,MWriteD1;
        input   [1:0] mul_alu_selD2;
        input [3:0]  mul_div_funcD2;
        output pause_out;
        input Shift_Amount_selD2;       
        input int_stateD1;
        
        reg [31:0] AReg,NReg,RReg,DReg;
        reg [31:0] alu_left_latch,alu_right_latch;
        reg [31:0] memory_wdata;

`ifdef RAM4K
        input [11:0] PCCDD;
        reg [11:0] PCD2;
`else
        input [25:0] PCCDD;
        reg [25:0] PCD2;
`endif

        reg [15:0] IMMD2;//Jul.6.2004

        reg [4:0]  dadrD3,dadrD4,dadrD5,dadrD6;
        reg [4:0]  sadrD1,sadrD2;
        reg [4:0]  tadrD1,tadrD2;
        reg WD3,WD4,WD5,WD6;
        reg [1:0] A_Right_SELD2;
        reg [1:0] RRegSelD2,  RRegSelD3, RRegSelD4;
        reg [31:0] RRegin;
        reg test1D,test2D;              
        wire  [31:0] alu_right;
        reg [31:0] alu_left;
        
        wire [31:0] source_out,target_out;
        wire [31:0] alu_out,shift_out;
        wire [31:0] alu_source=alu_left;
        wire [31:0] alu_target=alu_right;
        wire [31:0] regfile_in;
        wire [31:0] test,test2;
        wire test1;

        reg  stest1D,stest2D;
        reg  stest1D_dup1,stest1D_dup2,stest1D_dup3,stest1D_dup4;
        reg [31:0] mul_alu_out;
        reg div_mode_ff;
        reg sign_ff;
        reg RRegSelD4_dup1,RRegSelD4_dup2,RRegSelD4_dup3;


        wire  mul_div_enable,mul_div_sign,mul_div_mode;
        
        wire  [31:0] mul_div_out;
        wire [31:0] c_mult;
        wire [4:0] Shift_Amount;

        localparam [4:0] zero_=0,
                                     at_=1,
                                     v0_=2,
                                     v1_=3,
                                     a0_=4,
                                     a1_=5,
                                     a2_=6,
                                     a3_=7,
                                     t0_=8, t1_=9,t2_=10,t3_=11,t4_=12,t5_=13,t6_=14,t7_=15,
                                     s0_=16,s1_=17,s2_=18,s3_=19,s4_=20,s5_=21,s6_=22,s7_=23,t8_=24,t9_=25,
                                     k0_=26,k1_=27,gp_=28,sp_=29,s8_=30,ra_=31;                              





        always @(posedge clock) begin
                        
                        dadrD3&lt;=dest_addrD2;
                        dadrD4&lt;=dadrD3;
                        dadrD5&lt;=dadrD4;
                        dadrD6&lt;=dadrD5;

                        tadrD1&lt;=target_addr;
                        tadrD2&lt;=tadrD1;
                
                        sadrD1&lt;=source_addr;
                        sadrD2&lt;=sadrD1;


                        if ( (mul_div_funcD2 ==4'b0000 ) || 
                             (mul_div_funcD2 ==4'b0001 ) ||
                             (mul_div_funcD2 ==4'b0010 ) ) WD3&lt;=wren;//NOTHING,READLO/HI ȊOł̓Cg~߂
                        else                    WD3&lt;=1'b0;

                        WD4&lt;=WD3;
                        WD5&lt;=WD4;
                        WD6&lt;=WD5;                       

                        A_Right_SELD2&lt;=A_Right_SELD1;
                   
                        IMMD2&lt;=IMMD1;
                        if (int_stateD1) PCD2&lt;=PCCDD;//Jul.7.2004
                        else PCD2&lt;=PCD1;


                        RRegSelD2&lt;=RRegSelD1;
                        RRegSelD3&lt;=RRegSelD2;
                        RRegSelD4&lt;=RRegSelD3;
                        RRegSelD4_dup1&lt;=RRegSelD3[0];
                        RRegSelD4_dup2&lt;=RRegSelD3[0];
                        RRegSelD4_dup3&lt;=RRegSelD3[0];

        
        end



//AReg
        always @(posedge clock) begin
        
                        case (RF_inputD2) 
                                `RF_ALU_sel :     AReg&lt;=alu_out;
                                `RF_Shifter_sel:  AReg&lt;=shift_out;
                                `SHIFT16_SEL:     AReg&lt;= {IMMD2[15:0],16'h00};
                                `RF_PC_SEL :      AReg&lt;=mul_alu_out;
                        endcase
        end
        
//ARegSel
        always @(*) begin//Mar.5.2005
                        if (! mul_alu_selD2[1] ) mul_alu_out={6'b00_0000,PCD2};
                        else    mul_alu_out=c_mult;
        end
        



//NReg
        always @(posedge clock)         NReg&lt;=AReg;
        

//RReg
        always @(posedge clock)         begin
                case (RRegSelD4_dup1) 
                                `MOUT_SEL :     RReg&lt;=MOUT;
                                `NREG_SEL:      RReg&lt;=NReg;
                                default :       RReg&lt;=MOUT;
                        endcase
        end

//DReg
        always @(posedge clock)         begin
                                        DReg&lt;=RReg;
        end




        always @(*) begin 
                        case (RRegSelD4_dup2) 
                                `MOUT_SEL :     RRegin=MOUT;
                                `NREG_SEL:      RRegin=NReg;
                                 default :      RRegin=MOUT;
                        endcase
        end
//target_reg
        always @(*)     memory_wdata=alu_right;

mul_div MulDiv(.clock(clock),.sync_reset(sync_reset),.a(alu_left),.b(alu_right),
                          .mul_div_out(c_mult),.mul_div_sign(mul_div_funcD2[1]),
                          .mul_div_word(1'b1),.mul_div_mode(mul_div_funcD2[2]),
                          .stop_state(pause_out),.mul_div_enable(mul_div_funcD2[3]),.lohi(mul_div_funcD2[0]));

assign mul_div_enable= mul_div_funcD2;
        always @(posedge clock) begin 
                if (sync_reset) div_mode_ff&lt;=1'b0;
                else if (mul_div_enable) div_mode_ff&lt;=mul_div_mode;
        end

        always @(posedge clock) begin
                if (sync_reset) sign_ff&lt;=1'b0; 
                else if (mul_div_enable) sign_ff&lt;=mul_div_sign;
        end

assign mul_div_mode=!(IMMD2[1] ==`MUL_DIV_MUL_SEL);//div high / mul low
assign mul_div_sign=!IMMD2[0];



alu  alu1(.a(alu_left),.b(alu_right),.alu_func(ALU_FuncD2),.alu_out(alu_out));


        
shifter sh1(.a(alu_right),.shift_out(shift_out),.shift_func(Shift_FuncD2),
                                                .shift_amount(Shift_Amount));

        assign Shift_Amount=Shift_Amount_selD2==`SHIFT_AMOUNT_REG_SEL ?
                                                alu_left[4:0] : Shift_amountD2;


//alu left latch
        always @(posedge clock) begin
        begin
                        if (sadrD1==dadrD4 &amp;&amp; WD4) alu_left_latch&lt;=RRegin;
//OK
                        else if       (sadrD1==dadrD5 &amp;&amp; WD5)   alu_left_latch&lt;=RReg;//This must be priority encoder
                        else if    (sadrD1==dadrD6 &amp;&amp; WD6)   alu_left_latch&lt;=DReg;
                        else  alu_left_latch&lt;=source_out;
                                end
        end


//alu right latch
        always @(posedge clock) begin
        begin
                        case (A_Right_SELD1)
                                `Imm_signed   :         alu_right_latch&lt;={ {16{IMMD1[15]}},IMMD1[15:0]};
                                `Imm_unsigned :         alu_right_latch&lt;={ 16'h000,IMMD1[15:0]};
                                `A_RIGHT_ERT  : begin
                                                                                                
                                                                                                        if (tadrD1==dadrD4 &amp;&amp; WD4 ) alu_right_latch&lt;=RRegin;
                                                                                                        else   //OK
                                                                                                                if (tadrD1==dadrD5 &amp;&amp; WD5 )  alu_right_latch&lt;=RReg;
                                                                                                                else if (tadrD1==dadrD6 &amp;&amp; WD6) alu_right_latch&lt;=DReg;
                                                                                                                else alu_right_latch&lt;=target_out;
                                                                                        end
                                `IMM_26_SEL             : begin
                                                                                                        alu_right_latch&lt;={6'b00_0000,IMMD1};
                                                                                                end
                                default                         : alu_right_latch&lt;={ {16{IMMD1[15]}},IMMD1[15:0]};
                        endcase
                end
        end
`ifdef ALTERA   
ram_regfile32xx32 RFile(
        .data(regfile_in),
        .wraddress(dadrD5),
        .rdaddress_a(target_addr),
        .rdaddress_b(source_addr),
        .wren(WD5),
        .clock(clock),
        .qa(target_out),
        .qb(source_out));
`else

ram32x32_xilinx  RFile (
        .data(regfile_in),
        .wraddress(dadrD5),
        .rdaddress_a(target_addr),
        .rdaddress_b(source_addr),
        .wren(WD5),
        .clock(clock),
        .qa(target_out),
        .qb(source_out));
`endif
        assign regfile_in=dadrD5==5'b0_0000 ? 32'h0000_0000 :RReg;




        always @* begin //
                case (stest1D_dup1) 
                        1'b1: alu_left[7:0]=AReg[7:0];
                        1'b0: 
                                case(stest2D)
                                        1'b1:
                                                case (RRegSelD4_dup3) 
                                                        `MOUT_SEL :     alu_left[7:0]=MOUT[7:0];
                                                        `NREG_SEL:      alu_left[7:0]=NReg[7:0];
                                                endcase
                                        1'b0:   alu_left[7:0]=alu_left_latch[7:0];
                                endcase
                endcase
        end

      always @* begin //
                case (stest1D_dup2) 
                        1'b1: alu_left[15:8]=AReg[15:8];
                        1'b0: 
                                case(stest2D)
                                        1'b1:
                                                case (RRegSelD4_dup3) 
                                                        `MOUT_SEL :     alu_left[15:8]=MOUT[15:8];
                                                        `NREG_SEL:      alu_left[15:8]=NReg[15:8];
                                                endcase
                                        1'b0:   alu_left[15:8]=alu_left_latch[15:8];
                                endcase
                endcase
        end

always @* begin//
                case (stest1D_dup3) 
                        1'b1: alu_left[23:16]=AReg[23:16];
                        1'b0: 
                                case(stest2D)
                                        1'b1:
                                                case (RRegSelD4_dup3) 
                                                        `MOUT_SEL :     alu_left[23:16]=MOUT[23:16];
                                                        `NREG_SEL:      alu_left[23:16]=NReg[23:16];
                                                endcase
                                        1'b0:   alu_left[23:16]=alu_left_latch[23:16];
                                endcase
                endcase
        end

always @* begin //
                case (stest1D_dup4) 
                        1'b1: alu_left[31:24]=AReg[31:24];
                        1'b0: 
                                case(stest2D)
                                        1'b1:
                                                case (RRegSelD4_dup3) 
                                                        `MOUT_SEL :     alu_left[31:24]=MOUT[31:24];
                                                        `NREG_SEL:      alu_left[31:24]=NReg[31:24];
                                                endcase
                                        1'b0:   alu_left[31:24]=alu_left_latch[31:24];
                                endcase
                endcase
        end




        assign alu_right=test1D ? AReg :
                         test2D ?   RRegin : alu_right_latch;

        always @(posedge clock) begin
                        stest1D&lt;=(sadrD1==dest_addrD2) &amp;&amp; wren;
                        stest1D_dup1&lt;=(sadrD1==dest_addrD2) &amp;&amp; wren;
                        stest1D_dup2&lt;=(sadrD1==dest_addrD2) &amp;&amp; wren;
                        stest1D_dup3&lt;=(sadrD1==dest_addrD2) &amp;&amp; wren;
                        stest1D_dup4&lt;=(sadrD1==dest_addrD2) &amp;&amp; wren;

        end
        always @(posedge clock) begin
                stest2D&lt;=(sadrD1==dadrD3) &amp;&amp; WD3  ;
        end




        always @(posedge clock) begin
                        test1D&lt;=tadrD1==dest_addrD2 &amp;&amp; (wren )  &amp;&amp; A_Right_SELD1==`A_RIGHT_ERT;
        end

        always @(posedge clock) begin
                        test2D&lt;=tadrD1==dadrD3 &amp;&amp; (WD3 )  &amp;&amp; A_Right_SELD1==`A_RIGHT_ERT;
        end


`ifdef Veritak
        reg [30*8:1] alu_function;
        reg [30*8:1] shift_function;
        reg [30*8:1] AReg_Input_Sel;

        always @*//Jan.20.2005 @(ALU_FuncD2,alu_left,alu_right)
                case (ALU_FuncD2)
                        `ALU_NOTHING : $sprintf(alu_function,&quot;non_operation&quot;);
                        `ALU_ADD        : $sprintf(alu_function,&quot;ADD %h,%h&quot;,alu_left,alu_right);
                        `ALU_SUBTRACT :$sprintf(alu_function,&quot;SUB %h,%h,alu_left,alu_right&quot;);
                        `ALU_LESS_THAN_UNSIGNED :$sprintf(alu_function ,&quot;LT_Unsigned %h,%h&quot;,alu_left,alu_right);
                        `ALU_LESS_THAN_SIGNED   : $sprintf(alu_function,&quot;LT_Signed %h,%h&quot;,alu_left,alu_right);
                        `ALU_OR   : $sprintf(alu_function,&quot;OR %h,%h&quot;,alu_left,alu_right);
                        `ALU_AND : $sprintf(alu_function,&quot;XOR %h,%h,alu_left,alu_right&quot;);
                        `ALU_XOR : $sprintf(alu_function,&quot;AND %h,%h&quot;,alu_left,alu_right);
                        `ALU_NOR : $sprintf(alu_function,&quot;NOR %h,%h&quot;,alu_left,alu_right);
                        default: $sprintf(alu_function,&quot;non_operation&quot;);
                endcase

        always @* begin //
                case (Shift_FuncD2)
                        `SHIFT_LEFT : $sprintf(shift_function,&quot;SLL %d&quot;,Shift_Amount);
                        `SHIFT_RIGHT_UNSIGNED : $sprintf(shift_function,&quot;SLR %d&quot;,Shift_Amount);
                        `SHIFT_RIGHT_SIGNED : $sprintf(shift_function,&quot;SAR %d&quot;,Shift_Amount);
                        default: $sprintf(shift_function,&quot;non_operation&quot;);
                endcase
        end        


        always @* begin //
                        case (RF_inputD2) 
                                `RF_ALU_sel :     $sprintf(AReg_Input_Sel,&quot;ALU&quot;);
                                `RF_Shifter_sel:  $sprintf(AReg_Input_Sel,&quot;Shifter&quot;);
                                `SHIFT16_SEL:     $sprintf(AReg_Input_Sel,&quot;IMM16&lt;&lt;16&quot;);
                                `RF_PC_SEL :      $sprintf(AReg_Input_Sel,&quot;PC/MulOutSEL&quot;);
                        endcase
        end


`endif




endmodule</PRE>
      </TH>
    </TR>
  </TBODY>
</TABLE>
<P><B>2.2.8 UART&nbsp;Write&nbsp;Port</B> <BR>
<BR>
With 512 Bytes FIFO Uart Write Port.115.2KBPS in 50MHz System Clock.</P>
<TABLE border="1">
  <TBODY>
    <TR>
      <TH width="28" height="14" align="left">
      <PRE>`include &quot;define.h&quot;
//Apr.5.2005 Tak.Sugawara
//Jul.14.2004


module  uart_write( sync_reset, clk, txd, data_in , write_request,write_done,write_busy);
        input sync_reset,clk;
        input [7:0] data_in;
        input write_request;
        output txd,write_done;
        output write_busy;

        
 
        wire            queue_full;
        wire    queing, read_request;
        wire [7:0] queue_data;
        reg read_request_ff;
        

//________|--|___write_request (upper  module :     its period should be 1clock time.)
//__________________________|-|______write_done    (Responds by this module posedge interrupt)
//With 512Bytes FIFO.
//No error handling is supported.

        reg             [8:0] clk_ctr;
        reg             [2:0] bit_ctr;
        reg             [2:0] ua_state;
        reg             [7:0] tx_sr;
        reg             write_done_n;
        reg             txd;

        wire     clk_ctr_equ15, clk_ctr_equ31,  bit_ctr_equ7,
                           clk_ctr_enable_state, bit_ctr_enable_state  ;
        wire    tx_state;
        wire empty;
        assign write_busy=queue_full;//Apr.2.2005

        always @ (posedge clk) begin
                if (sync_reset) read_request_ff&lt;=1'b0;
                else                    read_request_ff&lt;=read_request;
        end

        assign queing=  !empty;
        assign read_request      = queing &amp;&amp; ua_state==3'b000;//Jul.14.2004 

        assign write_done=ua_state==3'b101;

`ifdef ALTERA
 fifo512_cyclone  fifo(
        .data(data_in),
        .wrreq(write_request),
        .rdreq(read_request),
        .clock(clk),
        .q(queue_data),
        .full(queue_full),
        .empty(empty));
`else//XILINX coregen

 fifo    fifo(
        .clk(clk),
        .sinit(sync_reset),
        .din(data_in),
        .wr_en(write_request),
        .rd_en(read_request),
        .dout(queue_data),
        .full(queue_full),
        .empty(empty));


`endif



// 7bit counter
        always @(posedge clk ) begin
                if (sync_reset)
                        clk_ctr &lt;= 0;
                else if (clk_ctr_enable_state &amp;&amp; clk_ctr_equ31)  clk_ctr&lt;=0;    
                else if (clk_ctr_enable_state)                   clk_ctr &lt;= clk_ctr + 1;
                else    clk_ctr &lt;= 0;
        end


        assign  clk_ctr_equ15 = clk_ctr==`COUNTER_VALUE1;  
        assign  clk_ctr_equ31 = clk_ctr==`COUNTER_VALUE2;

        // 3bit counter
        always @(posedge clk) begin
                if (sync_reset)
                        bit_ctr &lt;= 0;
                else if (bit_ctr_enable_state) begin
                        if (clk_ctr_equ15)
                                bit_ctr &lt;= bit_ctr + 1;
                end
                else
                        bit_ctr &lt;= 0;
        end

        assign  bit_ctr_equ7 = (bit_ctr==7);



        assign  clk_ctr_enable_state = bit_ctr_enable_state ||  ua_state==3'b001 ||  ua_state==3'b100 ;
        assign  bit_ctr_enable_state =  ua_state==3'b010 || ua_state==3'b011;


        always @(posedge clk ) begin
                if (sync_reset) ua_state &lt;= 3'b000;
                else begin
                        case (ua_state)
                                3'b000: if (queing)  ua_state &lt;= 3'b001;        //wait write_request
                                3'b001: if ( clk_ctr_equ15) ua_state &lt;= 3'b010; // write start bit
                                3'b010: if (bit_ctr_equ7 &amp; clk_ctr_equ15) ua_state &lt;= 3'b011;           // start bit, bit0-7 data  send
                                3'b011: if (clk_ctr_equ15) ua_state &lt;= 3'b100;                                  // bit7 data send
                                3'b100: if (clk_ctr_equ15) ua_state &lt;= 3'b101;  // stop bit                             // stop bit send
                                3'b101:  ua_state &lt;= 3'h0;      // TAK                                  // byte read cycle end
                                default: ua_state &lt;= 3'h0;
                        endcase
                end
        end












// tx shift reg.
        always @(posedge clk ) begin
                if (sync_reset) tx_sr&lt;=0;
                else if (read_request_ff) tx_sr &lt;= queue_data[7:0]; //data_in[7:0]; // load
                else if (tx_state ) tx_sr &lt;= {1'b0, tx_sr[7:1]};
        end
        
        assign  tx_state=(  ua_state==3'h2 || ua_state==3'h3)           &amp;&amp;      clk_ctr_equ15;


// tx
        always @(posedge clk ) begin
                if (sync_reset) txd &lt;=1'b1;
                else if (sync_reset)                      txd&lt;=1'b1;
                else if (ua_state==3'h0)                  txd&lt;=1'b1;
                else if (ua_state==3'h1 &amp;&amp; clk_ctr_equ15) txd&lt;=1'b0;    // start bit
                else if (ua_state==3'h2 &amp;&amp; clk_ctr_equ15) txd&lt;=tx_sr[0];
                else if (ua_state==3'h3 &amp;&amp; clk_ctr_equ15) txd&lt;=1'b1;     // stop bit
        end
endmodule
</PRE>
      </TH>
    </TR>
  </TBODY>
</TABLE>
<P><BR>
<B>2.2.9 UART READ PORT</B><BR>
<BR>
Host must service within 1-byte time because of no fifo.</P>
<TABLE border="1">
  <TBODY>
    <TR>
      <TH width="28" height="14" align="left">
      <PRE>`include &quot;define.h&quot;





module  uart_read( sync_reset, clk, rxd,buffer_reg, int_req);
        input sync_reset;
        input   clk, rxd;
        output  [7:0] buffer_reg;
        output  int_req;
        

//________|-|______int_req (This module,, posedge interrupt)
//
//Spec. Upper module must service within 115.2Kbpsx8bit time. Maybe enough time...
//
//No error handling (overrun ) is supported.
        
        reg             rxq1;
        reg             [8:0] clk_ctr;
        reg             [2:0] bit_ctr;
        reg             [2:0] ua_state;
        reg             [7:0] rx_sr;             //.,tx_sr;
        reg             int_req;
        reg             [7:0] buffer_reg;       

        wire     clk_ctr_equ15, clk_ctr_equ31, bit_ctr_equ7, 
                           clk_ctr_enable_state, bit_ctr_enable_state  ;
        wire    clk_ctr_equ0;
            

        
         
//sync_reset

//synchronization
        always @(posedge clk ) begin
                rxq1 &lt;=rxd ;
        end
        
// 7bit counter
        always @(posedge clk ) begin
                if (sync_reset)
                        clk_ctr &lt;= 0;
                else if (clk_ctr_enable_state &amp;&amp; clk_ctr_equ31)  clk_ctr&lt;=0;    
                else if (clk_ctr_enable_state)                   clk_ctr &lt;= clk_ctr + 1;
                else    clk_ctr &lt;= 0;
        end
        assign  clk_ctr_equ15 =  (clk_ctr==`COUNTER_VALUE1)  ;//
        assign  clk_ctr_equ31 =  (clk_ctr==`COUNTER_VALUE2) ;//
        assign  clk_ctr_equ0=    (clk_ctr==`COUNTER_VALUE3);    //


        // 3bit counter
        always @(posedge clk) begin
                if (sync_reset)
                        bit_ctr &lt;= 0;
                else if (bit_ctr_enable_state) begin
                        if (clk_ctr_equ15)
                                bit_ctr &lt;= bit_ctr + 1;
                end
                else
                        bit_ctr &lt;= 0;
        end

        assign  bit_ctr_equ7 = (bit_ctr==7);

        
        assign  clk_ctr_enable_state =  ua_state !=3'b000  &amp;&amp; ua_state&lt;=3'b011;
        assign  bit_ctr_enable_state = ua_state==3'h2;

//      
        always @(posedge clk ) begin
                if (sync_reset) ua_state &lt;= 3'h0;
                else begin
                        case (ua_state)
                                3'h0:   if (rxq1==0) ua_state &lt;= 3'h1;  // if rxd==0 then goto next state and enable clock                                              // start bit search
                                3'h1:   if (clk_ctr_equ15) ua_state &lt;= 3'h2;                                    // start bit receive
                                3'h2:   if (bit_ctr_equ7 &amp; clk_ctr_equ15) ua_state &lt;= 3'h3;     
                                3'h3:   if (clk_ctr_equ15)     ua_state &lt;=3'h4;                                                                 // stop bit receive
                                3'h4:   ua_state &lt;= 3'b000;
                                default: ua_state &lt;= 3'b000;                    
                        endcase
                end
        end


//reg_we
        always @(posedge clk ) begin
                if (sync_reset)                            buffer_reg&lt;=8'h00;
                else if (ua_state==3'h3 &amp;&amp; clk_ctr_equ0)  buffer_reg&lt;=rx_sr;
        end

//int_req
        always @(posedge clk ) begin
                if (sync_reset)                             int_req&lt;=1'b0;
                else if (ua_state==3'h4 )   int_req&lt;=1'b1;      //
                else                                        int_req&lt;=1'b0;
        end


// rx shift reg.
        always @(posedge clk ) begin
                if (sync_reset) rx_sr &lt;= 0;
                else if (clk_ctr_equ15) rx_sr &lt;= {rxq1, rx_sr[7:1]};
        end
        
endmodule</PRE>
      </TH>
    </TR>
  </TBODY>
</TABLE>
</BODY>
</HTML>