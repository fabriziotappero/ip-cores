
ECO32 Architecture
==================

General
-------

The ECO32 is a general purpose 32-bit integer processor.
It is a big endian machine with a byte addressable memory.
32 integer registers (each 32 bits wide) are provided
within the CPU. The data path is 32 bits wide. Each machine
instruction is stored in a single 32 bit word. Addresses as
generated by a program are 32 bits wide.

The CPU can operate in one of two modes, kernel or user mode.
When running in user mode, certain operations are illegal
and result in an exception when the program tries to execute
such an operation.

Memory addresses as generated by a running program are virtual
addresses; a memory management unit (which is part of the CPU)
converts these into physical addresses. The unit of translation
is called a page. Pages are 4096 bytes in size. The hardware
support for paging is minimalistic: only a TLB is provided.
This implies a wide range of possibilities for the operating
system designer how to manage page tables.

The ECO32 is a RISC processor strongly resembling MIPS.
It references memory (and thus I/O) only by load and store
instructions. Instructions operating on data usually come
in two forms: either with two source registers and a target
register, or a 16 bit wide immediate constant (coded within
the instruction) instead of the second source register. All
operations on data are carried out on all 32 bits ("word")
in parallel; the load and store instructions can also transfer
16 bits ("half-word") and 8 bits ("byte"). Memory access to
words must be aligned on word boundaries (addresses are evenly
divisible by 4); access to half-words must be aligned on
half-word boundaries (addresses are evenly divisible by 2).
The load instructions dealing with half-words and bytes can
either sign-extend their data or zero-extend it. All the load
and store instructions do only use one single addressing mode.
The memory address is computed as the sum of the contents of
a general purpose register and a sign-extended 16 bit immediate
offset coded within the instruction.


Physical Address Space Utilisation
----------------------------------

The main memory extends from address 0 to MEMORY_SIZE,
which has an upper limit of 512 MB. The ROM is located
at 0x20000000; its size, ROM_SIZE, is at most 256 MB.
The I/O is memory-mapped and located at 0x30000000; its
size is again at most 256 MB. The I/O address space is
divided evenly into 256 devices; each device may occupy
up to 1 MB of address space.


Virtual Address Space Utilisation
---------------------------------


Registers
---------

The 32 general purpose registers $0..$31 are 32 bits wide. The
value of $0 is always 0; write operations to this register don't
have any effect. Procedure calls place their return address in
register $31. Interrupts and exceptions place the address of the
next instruction (in case of an interrupt) or the address of the
offending instruction (in case of an exception) in register $30.
