/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:31:25 2011
//--
//-- Source file: dma_ch_wr_slicer.v
//---------------------------------------------------------


  
module  dma_ahb32_core0_ch_wr_slicer (clk,reset,ch_update,rd_clr_line,fifo_wr,fifo_wdata,fifo_wsize,wr_align,wr_ptr,rd_incr,end_swap,slice_wr,slice_wr_fifo,slice_wr_ptr,slice_bsel,slice_wdata,slice_wsize);

   input               clk;
   input               reset;

   input               ch_update;
   input               rd_clr_line;
   
   input               fifo_wr;
   input [32-1:0]      fifo_wdata;
   input [3-1:0]      fifo_wsize;
   input [2-1:0]      wr_align;
   input [5-1:0]      wr_ptr;
   input               rd_incr;
   input [1:0]               end_swap;
   
   output               slice_wr;
   output               slice_wr_fifo;
   output [5-1:0]     slice_wr_ptr;
   output [4-1:0]     slice_bsel;
   output [32-1:0]     slice_wdata;
   output [3-1:0]     slice_wsize;
   

   
   reg [3-1:0]           line_remain;                  
   wire [3-1:0]       join_wsize;
   wire [3-1:0]       append_wsize;
   wire [3-1:0]       direct_wsize;
   reg                   append;
   reg [3-1:0]           next_size;
   
   reg [32-1:0]           align_wdata;
   reg [32-1:0]           align_wdata_d;
   wire [2-1:0]       wr_align_valid;
   reg [32-1:0]           next_wdata;
   wire [4-1:0]       bsel_dec;
   reg [4-1:0]           bsel_shift;

   wire               next_wr;
   
   wire               slice_wr_pre;
   wire [5-1:0]       slice_wr_ptr_pre;
   wire [4-1:0]       slice_bsel_pre;
   wire [4-1:0]       slice_bsel_swap;
   wire [32-1:0]       slice_wdata_pre;
   reg [32-1:0]           slice_wdata_pre_d;
   wire [32-1:0]       slice_wdata_swap;
   wire [3-1:0]       slice_wsize_pre;

   wire               slice_wr;
   wire               slice_wr_fifo;
   reg [5-1:0]           slice_wr_ptr;
   reg [4-1:0]           slice_bsel;
   reg [32-1:0]           slice_wdata;
   reg [3-1:0]           slice_wsize;


   always @(posedge clk or posedge reset)
     if (reset)
       line_remain <= #1 3'd4;
     else if (ch_update |  rd_clr_line)
       line_remain <= #1 3'd4;
     else if (slice_wr_pre & (line_remain == slice_wsize_pre))
       line_remain <= #1 3'd4;
     else if (slice_wr_pre)
       line_remain <= #1 line_remain - slice_wsize_pre;
   
   assign               join_wsize = next_size + fifo_wsize;

   prgen_min2 #(3) min2_append(
                     .a(join_wsize),
                     .b(3'd4),
                     .min(append_wsize)
                     );
   
   prgen_min2 #(3) min2_direct(
                     .a(line_remain),
                     .b(fifo_wsize),
                     .min(direct_wsize)
                     );
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       append  <= #1 1'b0;
     else if (next_wr)
       append  <= #1 1'b0;
     else if (fifo_wr & (slice_wsize_pre == join_wsize))
       append  <= #1 1'b0;
     else if (fifo_wr)
       append  <= #1 1'b1;

   
   always @(posedge clk or posedge reset)
     if (reset)
       next_size  <= #1 {3{1'b0}};
     else if (next_wr)
       next_size  <= #1 {3{1'b0}};
     else if (fifo_wr & append)
       next_size  <= #1 join_wsize - append_wsize;
     else if (fifo_wr)
       next_size  <= #1 join_wsize - direct_wsize;

   
   //WDATA
   always @(posedge clk or posedge reset)
     if (reset)
       align_wdata_d <= #1 {32{1'b0}};
     else if (fifo_wr)
       align_wdata_d <= #1 align_wdata;

   
   assign               wr_align_valid = 
                  rd_incr ? wr_align : 
                  wr_align - wr_ptr[2-1:0];

   //always @(/*AUTOSENSE*/) - no AUTOSENSE because of fifo_wr
   always @(fifo_wdata or wr_align_valid or fifo_wr)
     begin
    case (wr_align_valid[2-1:0])
      2'd0 : align_wdata = fifo_wdata;
      2'd1 : align_wdata = {fifo_wdata[7:0],  fifo_wdata[31:8]};
      2'd2 : align_wdata = {fifo_wdata[15:0], fifo_wdata[31:16]};
      2'd3 : align_wdata = {fifo_wdata[23:0], fifo_wdata[31:24]};
    endcase
     end


   always @(/*AUTOSENSE*/align_wdata or align_wdata_d or next_size)
     begin
    case (next_size[2-1:0])
      2'd0 : next_wdata = align_wdata_d;
      2'd1 : next_wdata = {align_wdata[31:8],  align_wdata_d[7:0]};
      2'd2 : next_wdata = {align_wdata[31:16], align_wdata_d[15:0]};
      2'd3 : next_wdata = {align_wdata[31:24], align_wdata_d[23:0]};
    endcase
     end

   
   //BSEL
   assign bsel_dec = 
      slice_wsize == 4'd1 ? 4'b0001 :
      slice_wsize == 4'd2 ? 4'b0011 :
      slice_wsize == 4'd3 ? 4'b0111 :
      slice_wsize == 4'd4 ? 4'b1111 :
             {4{1'b0}};

   
   always @(/*AUTOSENSE*/bsel_dec or wr_ptr)
     begin
    case (wr_ptr[2-1:0])
      2'd0 : bsel_shift = bsel_dec;
      2'd1 : bsel_shift = {bsel_dec[2:0], 1'b0};
      2'd2 : bsel_shift = {bsel_dec[1:0], 2'b0};
      2'd3 : bsel_shift = {bsel_dec[0],   3'b0};
    endcase
     end


   //CMD
   assign next_wr             = (~fifo_wr) & (|next_size);
   
   assign slice_wr_pre        = fifo_wr | next_wr;
      
   assign slice_wsize_pre     =  
      next_wr ? next_size    : 
      append  ? append_wsize : direct_wsize;
    
   assign slice_wr_ptr_pre    = wr_ptr;

   assign slice_wdata_pre     = append ? next_wdata : align_wdata;

   assign slice_bsel_pre      = bsel_shift;
   

   prgen_delay #(1) delay_wr0(.clk(clk), .reset(reset), .din(slice_wr_pre), .dout(slice_wr));
   prgen_delay #(1) delay_wr(.clk(clk), .reset(reset), .din(slice_wr), .dout(slice_wr_fifo));

   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
      slice_wsize       <= #1 {3{1'b0}};
      slice_wdata_pre_d <= #1 {32{1'b0}};
       end
     else if (slice_wr_pre)
       begin
      slice_wsize       <= #1 slice_wsize_pre;
      slice_wdata_pre_d <= #1 slice_wdata_pre;
       end

   
   prgen_swap32 swap32(
               .end_swap(end_swap),
               .data_in(slice_wdata_pre_d),
               .data_out(slice_wdata_swap),
               .bsel_in(slice_bsel_pre),
               .bsel_out(slice_bsel_swap)
               );
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
      slice_wdata   <= #1 {32{1'b0}};
      slice_wr_ptr  <= #1 {5{1'b0}};
      slice_bsel    <= #1 {4{1'b0}};
       end
     else if (slice_wr)
       begin
      slice_wdata   <= #1 slice_wdata_swap;
      slice_wr_ptr  <= #1 slice_wr_ptr_pre;
      slice_bsel    <= #1 slice_bsel_swap;
       end
   
endmodule



   


