/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:36:56 2011
//--
//-- Source file: dma_ch_remain.v
//---------------------------------------------------------



module dma_axi64_core0_ch_remain(clk,reset,ch_update,wr_outstanding,rd_outstanding,load_req_in_prog,rd_line_cmd,rd_burst_start,rd_burst_size,rd_transfer,rd_transfer_size,wr_clr_line,wr_burst_start,wr_burst_size,wr_transfer,wr_transfer_size,rd_gap,wr_fullness);

   input                    clk;
   input             reset;

   input             ch_update;
   input             wr_outstanding;
   input             rd_outstanding;
   input             load_req_in_prog;
   
   input             rd_line_cmd;
   input             rd_burst_start; 
   input [8-1:0]   rd_burst_size; 
   input             rd_transfer;
   input [4-1:0]    rd_transfer_size;
   
   input             wr_clr_line;
   input             wr_burst_start;
   input [8-1:0]   wr_burst_size;  
   input             wr_transfer;
   input [4-1:0]    wr_transfer_size;
   
   output [5:0]     rd_gap;
   output [5:0]     wr_fullness; 
   


   wire             rd_line_cmd_valid;
   reg [5+1:0]         rd_gap_reg; //signed
   reg [5+1:0]         wr_fullness_reg; //signed

   wire             rd_burst_qual;
   wire             wr_burst_qual;
   reg [8-1:0]     rd_burst_size_valid; 
   wire [4-1:0]     rd_transfer_size_valid;
   wire [4-1:0]     wr_transfer_size_valid;
   reg [8-1:0]     wr_burst_size_valid; 



   
   assign             rd_line_cmd_valid = rd_line_cmd & rd_burst_start;
   
   assign             rd_burst_qual = rd_burst_start & (~load_req_in_prog);
   assign             wr_burst_qual = wr_burst_start;
   
   always @(posedge clk or posedge reset)
     if (reset)
       rd_burst_size_valid <= #1 {8{1'b0}};
     else if (rd_burst_qual)
       rd_burst_size_valid <= #1 rd_burst_size;
     else
       rd_burst_size_valid <= #1 {8{1'b0}};
   
   always @(posedge clk or posedge reset)
     if (reset)
       wr_burst_size_valid <= #1 {8{1'b0}};
     else if (wr_burst_qual)
       wr_burst_size_valid <= #1 wr_burst_size;
     else
       wr_burst_size_valid <= #1 {8{1'b0}};
   
   assign             rd_transfer_size_valid = {4{rd_transfer}} & rd_transfer_size;
   assign             wr_transfer_size_valid = {4{wr_transfer}} & wr_transfer_size;
   
   
   //for rd bursts
   always @(posedge clk or posedge reset)
     if (reset)
       rd_gap_reg <= #1 {1'b0, 1'b1, {5{1'b0}}};
     else if (ch_update)
       rd_gap_reg <= #1 {1'b0, 1'b1, {5{1'b0}}};
     else
       rd_gap_reg <= #1 rd_gap_reg - 
             rd_burst_size_valid +
             wr_transfer_size_valid;
   
   
   assign rd_gap = rd_gap_reg[5+1] ? 'd0 : rd_gap_reg[5:0];

   
   //for wr bursts
   always @(posedge clk or posedge reset)
     if (reset)
       wr_fullness_reg <= #1 {5+1{1'b0}};
     else if (ch_update)
       wr_fullness_reg <= #1 {5+1{1'b0}};
     else
       wr_fullness_reg <= #1 wr_fullness_reg -
              wr_burst_size_valid +
              rd_transfer_size_valid; 

   
   assign wr_fullness = wr_fullness_reg[5+1] ? 'd0 : wr_fullness_reg[5:0];
   
endmodule





